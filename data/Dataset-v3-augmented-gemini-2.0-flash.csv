Question,CoT,Response
"Develop a Clarity smart contract for the Stacks blockchain to establish a decentralized STX lending platform. The contract should facilitate user deposits, collateralized borrowing, and yield generation. Include functions to handle deposits, manage loans with block-height-based interest, distribute yield, and implement a 50% loan-to-value limit with a 10% interest rate. The contract must incorporate error handling and read-only functions for displaying user balances and loan details. Ensure secure STX transfer mechanisms. Provide detailed comments throughout the code.","First, I must outline the logical steps for creating the lending protocol in Clarity, accounting for the core features: deposit management, collateralized borrowing, interest accrual, and yield generation. The protocol requires two core data structures to manage deposits and loans. Deposits will be mapped to user addresses storing deposit amounts. Loans will store the borrower's loan amount plus a block height used for interest calculations. Essential global variables are also needed: total deposits for calculating yield, pool reserve for accumulating accrued interest. The loan-interest-rate is set as requested, and error constants are defined for error management. 

Deposit function: allows users to deposit STX using 'stx-transfer?', updating the user's balance and the total deposits. The borrowing process demands compliance with a 50% Loan-To-Value (LTV) ratio. Borrow calculates a borrowing limit, considering the user's deposit, and then applies a private function to handle accrued interest from any existing loans. It then updates the loan record with the new amount and current block height. 

Repayment function: calculates the total loan repayment amount (principal and interest), ensures no overpayment occurs using 'stx-transfer?', and updates the loan record. Interest is transferred to 'pool-reserve'. 

Claim-yield function: distributes interest to depositors, proportionally based on their contribution to total deposits. 

Read-only functions will include 'get-balance-by-sender', 'get-balance', and 'get-amount-owed' to allow users to query their positions. 'Calculate-accrued-interest' (private) will determine interest accrual using the block height to measure elapsed time, then calculate and compound interest based on rates.

Correction: The borrow function requires correction; The new loan calculation is missing accrued interest from prior loan amounts. The implementation addresses core criteria: depositing, loans, interest, yield, LTV, read-only. STX transfers must be secure.",";; Define the contract's data variables

;; Maps a user's principal address to their deposited amount.
(define-map deposits { owner: principal } { amount: uint })

;; Maps a borrower's principal address to their loan details: amount and the last interaction block.
(define-map loans principal { amount: uint, last-interaction-block: uint })

;; Holds the total amount of deposits in the contract, initialized to 0.
(define-data-var total-deposits uint u0)

;; Represents the reserve funds in the pool, initialized to 0.
(define-data-var pool-reserve uint u0)

;; The interest rate for loans, represented as 10% (out of a base of 100).
(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate

;; Error constants for various failure scenarios.
(define-constant err-no-interest (err u100))
(define-constant err-overpay (err u200))
(define-constant err-overborrow (err u300))

;; Public function for users to deposit STX into the contract.
;; Updates their balance and the total deposits in the contract.
(define-public (deposit (amount uint))
    (let (
        ;; Fetch the current balance or default to 0 if none exists.
        (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        )
        ;; Transfer the STX from sender = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM"" to recipient = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.stx-defi (ie: contract identifier on the chain!)"".
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's deposit amount in the map.
        (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
        ;; Update the total deposits variable.
        (var-set total-deposits (+ (var-get total-deposits) amount))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to borrow STX based on their deposits.
(define-public (borrow (amount uint))
    (let (
        ;; Fetch user's deposit or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)
        (allowed-borrow (/ user-deposit u2))
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
        ;; Calculate the new loan total after borrowing additional amount.
        (new-loan (+ amount))
    )
        ;; Ensure the requested borrow amount does not exceed the allowed amount.
        (asserts! (<= new-loan allowed-borrow) err-overborrow)
        ;; Transfer the borrowed STX to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? amount tx-sender recipient)))
        )
        ;; Update the user's loan details in the map.
        (map-set loans tx-sender { amount: new-loan, last-interaction-block: burn-block-height })
        ;; Return success.
        (ok true)
    )
)

;; Read-only function to get the total balance by tx-sender
(define-read-only (get-balance-by-sender)
    (ok (map-get? deposits { owner: tx-sender }))
)

;; Read-only function to get the total balance 
(define-read-only (get-balance)
    (ok (var-get total-deposits))
)

;; Read-only function to get the total amount owed by the user.
(define-read-only (get-amount-owed)
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
    )
    ;; Return the total amount due.
    (ok total-due)
    )
)

;; Public function for users to repay their STX loans.
(define-public (repay (amount uint))
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest since the last interaction.
        (accrued-interest (unwrap! (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)) err-no-interest))
        ;; Calculate the total amount due including accrued interest.
        (total-due (+ (get amount current-loan-details) accrued-interest))
    )
        ;; Ensure the repayment amount is not more than the total due.
        (asserts! (>= total-due amount) err-overpay)
        ;; Transfer the repayment amount from the user to the contract.
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's loan details in the map with the new total due.
        (map-set loans tx-sender { amount: (- total-due amount), last-interaction-block: burn-block-height })
        ;; Update the pool reserve with the paid interest.
        (var-set pool-reserve (+ (var-get pool-reserve) accrued-interest))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to claim their yield based on the pool reserve and their deposits.
(define-public (claim-yield)
    (let (
        ;; Fetch user's deposit amount or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the yield amount based on user's share of the pool.
        (yield-amount (/ (* (var-get pool-reserve) user-deposit) (var-get total-deposits)))
    )
        ;; Transfer the yield amount from the contract to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? yield-amount tx-sender recipient)))
        )
        ;; Update the pool reserve by subtracting the claimed yield.
        (var-set pool-reserve (- (var-get pool-reserve) yield-amount))
        ;; Return success.
        (ok true)
    )
)

;; Private function to calculate the accrued interest on a loan.
(define-private (calculate-accrued-interest (principal uint) (start-block uint))
    (let (
        ;; Calculate the number of blocks elapsed since the last interaction.
        (elapsed-blocks (- burn-block-height start-block))
        ;; Calculate the interest based on the principal, rate, and elapsed time.
        (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
        ;; Ensure the loan started in the past (not at block 0).
        (asserts! (not (is-eq start-block u0)) (ok u0))
        ;; Return the calculated interest.
       (ok interest)
    )
)"
"Develop a Stacks blockchain Clarity smart contract. This contract should function as a basic NFT marketplace.  Users should be able to list NFTs for sale.  The listings need configurable features: token ID, expiration time, price, payment method (STX or SIP010 tokens) and an optional intended buyer. The contract must support whitelisting of contracts, listing, removing listings, and completing transactions with both STX and fungible tokens. Incorporate thorough error management, security measures, and utilize the predetermined NFT and fungible token interface standards for compatibility.","The task requires the creation of an NFT marketplace smart contract for Stacks, which defines an overview of the implementation. The primary objective is to enable users to list and trade NFTs with customizable parameters handled securely and efficiently. The contract should provide functionalities for key operations and integrates standard interfaces to guarantee coherence. The initial steps involve understanding the different components of the contract, like listings, unique listing IDs, handling of whitelists, and designing the overall structure. The contract's security considerations, like whitelists and error handling, become critical in this context. Central functions include listing, viewing, canceling, and fulfilling asset transactions, which involve validation of different parameters for ensuring each operation's integrity. The use of helper functions for token transfers (NFT and FT), leveraging the `as-contract` context and error handling strategies, is essential for a maintainable and secure implementation. The contract integrates support for two payment options, and also the design of transaction workflows. The main design principles are based on security, efficiency, clarity and a modular design.",";; A tiny NFT marketplace that allows users to list NFT for sale. They can specify the following:
;; - The NFT token to sell.
;; - Listing expiry in block height.
;; - The payment asset, either STX or a SIP010 fungible token.
;; - The NFT price in said payment asset.
;; - An optional intended taker. If set, only that principal will be able to fulfil the listing.
;;
;; Source: https://github.com/clarity-lang/book/tree/main/projects/tiny-market

(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

;; cancelling and fulfiling errors
(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

;; Define a map data structure for the asset listings
(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

;; Used for unique IDs for each listing
(define-data-var listing-nonce uint u0)

;; This marketplace requires any contracts used for assets or payments to be whitelisted
;; by the contract owner of this (marketplace) contract.
(define-map whitelisted-asset-contracts principal bool)

;; Function that checks if the given contract has been whitelisted.
(define-read-only (is-whitelisted (asset-contract principal))
  (default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

;; Only the contract owner of this (marketplace) contract can whitelist an asset contract.
(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

;; Internal function to transfer an NFT asset from a sender to a given recipient.
(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

;; Internal function to transfer fungible tokens from a sender to a given recipient.
(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

;; Public function to list an asset along with its contract
(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    ;; Verify that the contract of this asset is whitelisted
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    ;; Verify that the asset is not expired
    (asserts! (> (get expiry nft-asset) burn-block-height) ERR_EXPIRY_IN_PAST)
    ;; Verify that the asset price is greater than zero
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    ;; Verify that the contract of the payment is whitelisted
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    ;; Transfer the NFT ownership to this contract's principal
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    ;; List the NFT in the listings map
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    ;; Increment the nonce to use for the next unique listing ID
    (var-set listing-nonce (+ listing-id u1))
    ;; Return the created listing ID
    (ok listing-id)
  )
)

;; Public read-only function to retrieve a listing by its ID
(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

;; Public function to cancel a listing using an asset contract.
;; This function can only be called by the NFT's creator, and must use the same asset contract that
;; the NFT uses.
(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    ;; Verify that the caller of the function is the creator of the NFT to be cancelled
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    ;; Verify that the asset contract to use is the same one that the NFT uses
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    ;; Delete the listing
    (map-delete listings listing-id)
    ;; Transfer the NFT from this contract's principal back to the creator's principal
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

;; Private function to validate that a purchase can be fulfilled
(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    ;; Verify that the buyer is not the same as the NFT creator
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    ;; Verify the buyer has been set in the listing metadata as its `taker`
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    ;; Verify the listing for purchase is not expired
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    ;; Verify the asset contract used to purchase the NFT is the same as the one set on the NFT
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    ;; Verify the payment contract used to purchase the NFT is the same as the one set on the NFT
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

;; Public function to purchase a listing using STX as payment
(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the STX payment from the purchaser to the creator of the NFT
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)

;; Public function to purchase a listing using another fungible token as payment
(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the tokens as payment from the purchaser to the creator of the NFT
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)"
"Develop a Stacks Blockchain Clarity smart contract that complies with the SIP-009 NFT standard. The contract, named ""Your-NFT-Name"", must track the most recently minted token ID and limit the total tokens to 1000. Include constants for the contract's owner (set by the transaction sender), error codes for ownership and limit breaches, and a configurable base URI for token metadata. Implement the standard SIP-009 functions, including getting the last token ID, retrieving token URIs, getting the owner of a token, and a token transfer function that verifies the sender. Also, create a mint function, restricted to the contract owner, that enforces the collection limit, mints tokens to a designated recipient, updates the token ID, and returns the newly minted ID. Ensure thorough error handling and assertions across all functions to maintain security and predictable behavior.","I need to build a SIP-009 compliant Clarity smart contract for the Stacks blockchain. I'll make sure to import the necessary trait to confirm its standard NFT behavior. The contract will issue tokens as ""Your-NFT-Name"", using unsigned integers for token identification. I'll also need to track the total number of minted tokens which I will store as a counter, initialized to zero. To ensure secure access and prevent unauthorized actions, I need to define certain constants. The contract’s owner, determined by whoever deploys the contract, will be defined by tx-sender. The contract also has a limit of 1000 tokens. I also need to include error codes for potential failures such as unverified access or exceeding the stated collection limit. I'll need a base URI stored as a string, for referencing token-related metadata. This URI will act as a template, using the token ID to generate unique metadata addresses. Now, I will define and implement the required SIP-009 functions: get-last-token-id to retrieve the last minted token ID; get-token-uri to get the URI for a specific token, get-owner to find a token's owner, and a transfer function to send a token to another address. For the transfer function, it's important to implement security. I'll verify that the person initiating the transfer is the token's legitimate owner. This prevents unauthorized movement of tokens and ensures users maintain asset control. I'll use assert to verify that the transaction sender matches the sender parameter. The mint function will handle the creation of new tokens and involves several checks. First, I need to calculate the new token ID. Then, I will check against the maximum token limit. I need to ensure that only the contract owner can call this function. If all checks pass, the token can be minted, the counter updated, and the new token ID returned. Finally, all functions must return correctly formatted responses. Read-only functions will return an (ok ...) tuple, and function returns that change the state will use try! for the possibility of errors, and asserts! for permissions verification and validation. This ensures the contract is secure and user-friendly.",";; This contract implements the SIP-009 community-standard Non-Fungible Token trait
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

;; Define the NFT's name
(define-non-fungible-token Your-NFT-Name uint)

;; Keep track of the last minted token ID
(define-data-var last-token-id uint u0)

;; Define constants
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COLLECTION_LIMIT u1000) ;; Limit to series of 1000

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

;; SIP-009 function: Get the last minted token ID.
(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

;; SIP-009 function: Get link where token metadata is hosted
(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

;; SIP-009 function: Get the owner of a given token
(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? Your-NFT-Name token-id))
)

;; SIP-009 function: Transfer NFT token to another owner.
(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    ;; #[filter(sender)]
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? Your-NFT-Name token-id sender recipient)
  )
)

;; Mint a new NFT.
(define-public (mint (recipient principal))
  ;; Create the new token ID by incrementing the last minted ID.
  (let ((token-id (+ (var-get last-token-id) u1)))
    ;; Ensure the collection stays within the limit.
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    ;; Only the contract owner can mint.
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    ;; Mint the NFT and send it to the given recipient.
    (try! (nft-mint? Your-NFT-Name token-id recipient))

    ;; Update the last minted token ID.
    (var-set last-token-id token-id)
    ;; Return a success status and the newly minted NFT ID.
    (ok token-id)
  )
)"
"Create a Stacks Blockchain Clarity smart contract. This contract must produce a semi-fungible token (SIP-013) using the  'sip013-semi-fungible-token-trait' and 'sip013-transfer-many-trait' from the specified trait's address. Key requirements include the definition of both a fungible token and a non-fungible token identification system, as well as the implementation of balance and supply tracking through the use of maps. The contract needs to supply transfer functions, both single and batch, with optional memo support. It should also provide for balance queries, supply tracking, and minting restricted to the contract owner. Furthermore, the code should incorporate error handling, access controls, and event logging, all while utilizing the non-fungible token tagging method to keep track of token identity ownership.","The task is to implement a SIP-013 semi-fungible token contract. The contract should use traits for semi-fungible tokens and transfer capabilities and come with several features. These are: define both fungible and non-fungible token IDs; use maps to track balances and supplies; include single and batch transfer functions, with memo options; support balance queries, supply tracking; have owner-only minting; use appropriate error handling, access controls, and event logging; plus, also account for ownership based on the non-fungible token ID.","(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-semi-fungible-token-trait.sip013-semi-fungible-token-trait)
(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-transfer-many-trait.sip013-transfer-many-trait)

(define-fungible-token semi-fungible-token)
(define-non-fungible-token semi-fungible-token-id {token-id: uint, owner: principal})
(define-map token-balances {token-id: uint, owner: principal} uint)
(define-map token-supplies uint uint)

(define-constant contract-owner tx-sender)

(define-constant err-owner-only (err u100))
(define-constant err-insufficient-balance (err u1))
(define-constant err-invalid-sender (err u4))

(define-private (set-balance (token-id uint) (balance uint) (owner principal))
	(map-set token-balances {token-id: token-id, owner: owner} balance)
)

(define-private (get-balance-uint (token-id uint) (who principal))
	(default-to u0 (map-get? token-balances {token-id: token-id, owner: who}))
)

(define-read-only (get-balance (token-id uint) (who principal))
	(ok (get-balance-uint token-id who))
)

(define-read-only (get-overall-balance (who principal))
	(ok (ft-get-balance semi-fungible-token who))
)

(define-read-only (get-total-supply (token-id uint))
	(ok (default-to u0 (map-get? token-supplies token-id)))
)

(define-read-only (get-overall-supply)
	(ok (ft-get-supply semi-fungible-token))
)

(define-read-only (get-decimals (token-id uint))
	(ok u0)
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

;; #[allow(unchecked_params)]
(define-public (transfer (token-id uint) (amount uint) (sender principal) (recipient principal))
	(let
		(
			(sender-balance (get-balance-uint token-id sender))
		)
		(asserts! (or (is-eq sender tx-sender) (is-eq sender contract-caller)) err-invalid-sender)
		(asserts! (<= amount sender-balance) err-insufficient-balance)
		(try! (ft-transfer? semi-fungible-token amount sender recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: sender}))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (- sender-balance amount) sender)
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(print {type: ""sft_transfer"", token-id: token-id, amount: amount, sender: sender, recipient: recipient})
		(ok true)
	)
)

(define-public (transfer-memo (token-id uint) (amount uint) (sender principal) (recipient principal) (memo (buff 34)))
	(begin
		(try! (transfer token-id amount sender recipient))
		(print memo)
		(ok true)
	)
)

(define-private (transfer-many-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer (get token-id item) (get amount item) (get sender item) (get recipient item)) prev-err previous-response)
)

(define-public (transfer-many (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal})))
	(fold transfer-many-iter transfers (ok true))
)

(define-private (transfer-many-memo-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer-memo (get token-id item) (get amount item) (get sender item) (get recipient item) (get memo item)) prev-err previous-response)
)

(define-public (transfer-many-memo (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)})))
	(fold transfer-many-memo-iter transfers (ok true))
)

(define-public (mint (token-id uint) (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (ft-mint? semi-fungible-token amount recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(map-set token-supplies token-id (+ (unwrap-panic (get-total-supply token-id)) amount))
		(print {type: ""sft_mint"", token-id: token-id, amount: amount, recipient: recipient})
		(ok true)
	)
)

(define-private (tag-nft-token-id (nft-token-id {token-id: uint, owner: principal}))
	(begin
		(and
			(is-some (nft-get-owner? semi-fungible-token-id nft-token-id))
			(try! (nft-burn? semi-fungible-token-id nft-token-id (get owner nft-token-id)))
		)
		(nft-mint? semi-fungible-token-id nft-token-id (get owner nft-token-id))
	)
)"
"Develop a Stacks blockchain Clarity smart contract for a stablecoin token, incorporating SIP-10 compliance alongside bridging capabilities, administrative controls (ownership, minting, pausing, banning), configurable metadata, precise decimals, core token operations (transfer, mint, burn) with security checks, and an extension mechanism for authorized contract interaction. Ensure event emission, comprehensive error codes, initial paused state, and authorization checks for sensitive functions.","The contract design begins with implementing essential traits, including SIP-10 for token standardization and extensions for bridging and future functionality. Error handling is centralized using well-defined, numbered error codes for clarity. State management utilizes both variables and maps; string variables for metadata, fungible-token for balances, and maps for allowances and banned addresses. Security is prioritized: an ownership system governs sensitive actions, and the token starts paused, requiring owner activation. Minting uses a dual-map system for allowance management and auditing. SIP-10 functions fulfill the standard interface, with transfer delegating to a function with added checks. Administrative functions consistently verify caller authorization, perform the operation, emit an event, and return success. Address banning prevents sanctioned users from transacting. The extension system allows controlled interaction with authorized external contracts, using 'as-contract' for secure context execution. Error handling includes thorough validation and safe handling of potential failures. Memo support is also included for transactions.",";; title: circle-usdce-token
;; version:
;; summary:
;; description:

(impl-trait 'SP2J933XB2CP2JQ1A4FGN8JA968BBG3NK3EKZ7Q9F.hk-tokens-v1.sip10-token)
(impl-trait .token-traits.allbrige-bridged-token-trait)
(impl-trait .token-traits.extendable-token-actions-v1)
(impl-trait .token-traits.extendable-token)

(use-trait token-extension .token-traits.token-extension)
(use-trait extendable-token-actions-v1 .token-traits.extendable-token-actions-v1)

(define-constant ERR-NOT-AUTHORIZED (err u10000))
(define-constant ERR-MINT-ALLOWANCE-OVERFLOW (err u10001))
(define-constant ERR-PRINCIPAL-INVALID (err u10002))
(define-constant ERR-AMOUNT-INVALID (err u10003))
(define-constant ERR-TOKEN-PAUSED (err u10004))

(define-constant PRECISION u8)
(define-map authorized-extensions principal bool)

(define-data-var token-uri (string-utf8 256) u""http://url.to/token-metadata.json"")
(define-data-var name (string-ascii 32) ""USDC.e (Bridged by X)"")
(define-data-var symbol (string-ascii 32) ""USDC.e"")
(define-data-var contract-owner principal contract-caller)

(define-fungible-token token-data)

(define-map minters-allowances principal uint)

(define-map minters-allowances-tracking principal uint)

(define-data-var token-pause bool true)

(define-public (set-minter-allowance (minter principal) (allowance uint))
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Update minter's allowance
		(map-set minters-allowances minter allowance)
		;; Emit an event to increase observability
		(print { type: ""allowance"", action: ""update"", object: { minter: minter, allowance: allowance } })
		;; Ok response
		(ok { minter: minter, allowance: allowance })))

(define-read-only (is-token-paused)
  	(ok (var-get token-pause)))

(define-public (pause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Pause token
		(var-set token-pause true)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

(define-public (unpause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Unpause token
		(var-set token-pause false)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

;;;; SIP-10 trait implementation
;; The logic of these functions will not be upgradable.
;; Constraint: we'd need to have them right from the get go.

(define-read-only (get-total-supply)
  	(ok (ft-get-supply token-data)))

(define-read-only (get-name)
  	(ok (var-get name)))

(define-read-only (get-symbol)
  	(ok (var-get symbol)))

(define-read-only (get-decimals)
   	(ok PRECISION))

(define-read-only (get-balance (account principal))
  	(ok (ft-get-balance token-data account)))

(define-read-only (get-token-uri)
  	(ok (some (var-get token-uri))))

(define-public (transfer 
		(amount uint) 
		(sender principal) 
		(recipient principal) 
		(memo (optional (buff 34))))
	;; All-bridge requirement - To be explored
	(transfer! amount sender recipient memo))

;;;; Ownership management

(define-read-only (get-contract-owner)
  	(ok (var-get contract-owner)))

(define-public (set-contract-owner (owner principal))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(asserts! (is-standard owner) ERR-NOT-AUTHORIZED)
		(ok (var-set contract-owner owner))))

;;;; Token Extensions
;;;; Functions available for the token extensions

(define-public (set-token-uri (value (string-utf8 256)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set token-uri value))))

(define-public (set-token-name (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set name value))))

(define-public (set-token-symbol (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set symbol value))))

(define-map banned-addresses principal bool)

(define-public (ban-address (address principal))
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-set banned-addresses address true)
		(ok address)))

(define-public 
	(unban-address 
		(address principal)
	)
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-delete banned-addresses address)
		(ok address)))

;; Mint tokens
(define-public (mint! (recipient principal) (amount uint) (memo (optional (buff 34))))
	(let ((minting-allowance (unwrap! (map-get? minters-allowances contract-caller) ERR-NOT-AUTHORIZED))
		  (minted-pre-op (default-to u0 (map-get? minters-allowances-tracking contract-caller)))
		  (minted-post-op (+ minted-pre-op amount)))
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that minter can mint
		(asserts! (>= amount u0) ERR-AMOUNT-INVALID)
		;; Ensure that minter can mint
		(asserts! (>= minting-allowance minted-post-op) ERR-MINT-ALLOWANCE-OVERFLOW)
		;; Mint tokens
		(unwrap-panic (ft-mint? token-data amount recipient))
		;; Update allowance tracking
		(map-set minters-allowances-tracking contract-caller minted-post-op)
		;; Emit memo event
		(print memo)
		;; Return Ok
		(ok true)))

;; Burn tokens
(define-public (burn! (sender principal) (amount uint) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		(match 
			(ft-burn? token-data amount sender)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Transfer tokens
(define-public (transfer! 
		(amount uint)
		(sender principal)
		(recipient principal)
		(memo (optional (buff 34))))
	(begin 
		;; Ensure amount is positive
		(asserts! (> amount u0) ERR-AMOUNT-INVALID)
		;; Ensure the sender is not banned
		(asserts! (is-none (map-get? banned-addresses sender)) ERR-NOT-AUTHORIZED)
		;; Ensure the recipient is not banned
		(asserts! (is-none (map-get? banned-addresses recipient)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that send tokens are owned by the tx-sender
		(asserts! (is-eq sender tx-sender) ERR-NOT-AUTHORIZED)
		(match 
			(ft-transfer? token-data amount sender recipient)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Extension management

(define-public (authorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""authorized"", object: { extension: extension } })
        (map-insert authorized-extensions (contract-of extension) true)
        (ok true)))

(define-public (deauthorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""deprecated"", object: { extension: extension } })
        (map-delete authorized-extensions (contract-of extension))
        (ok true)))

(define-public (run-extension! 
		(self <extendable-token-actions-v1>)
		(extension <token-extension>)
		(payload (buff 8192)))
	(begin
        (asserts! (is-eq (as-contract tx-sender) (contract-of self)) ERR-NOT-AUTHORIZED)
        (asserts! (is-eq (map-get? authorized-extensions (contract-of extension)) (some true)) ERR-NOT-AUTHORIZED)
		(as-contract (contract-call? extension run! self payload))))"
"Develop a Stacks smart contract for a Stacks blockchain fundraising campaign. The contract should accept donations in STX and sBTC. It must initialize with a funding goal and campaign duration, defaulting to about 30 days (in Bitcoin blocks). The contract should track donations by donor address, enable the campaign owner to cancel the campaign, allow donors to request refunds if canceled, and let the beneficiary withdraw funds after the campaign completes. Include error handling, functions to check campaign and donation information, and ensure proper authorization checks. Maintain data on total donations, campaign status, and individual contributions.","I am creating a fundraising contract for the Stacks blockchain. This needs state management for donations, campaign status, and transaction security. I'll define state variables for initialization status, cancellation, withdrawal, beneficiary, timing, funding goals, and donation tracking. I'll use maps, one for STX and one for sBTC, to track donor addresses to contribution amounts. Error constants will be defined to provide clear error messages. The initialize-campaign function needs owner validation, prevents double initialization, and sets campaign parameters, including a default duration. The cancel-campaign function needs authorization checks and prevents cancellation if funds have been withdrawn. Donation functions, separate for STX and sBTC, must check initialization, activity, and the campaign end, transfer funds, update donation records, and increment totals. The withdraw function requires beneficiary authorization, checks for campaign completion, and handles STX and sBTC transfers. Refunds need to work only on cancellation and transfer assets back while cleaning up records. Read-only getter functions enable transparency and data access without modifying state. The code handles the campaign lifecycle, donations, withdrawals, and refunds with authorization and state management.",";; Fundraising Campaign Contract
;; A simple contract to accept crypto donations in STX or sBTC.

;; Constants 
(define-constant contract-owner tx-sender)
(define-constant err-not-authorized (err u100))
(define-constant err-campaign-ended (err u101))
(define-constant err-not-initialized (err u102))
(define-constant err-not-cancelled (err u103))
(define-constant err-campaign-not-ended (err u104))
(define-constant err-campaign-cancelled (err u105))
(define-constant err-already-initialized (err u106))
(define-constant err-already-withdrawn (err u107))

(define-constant default-duration u4320) ;; Duration in *Bitcoin* blocks. This default value means is if a block is 10 minutes, this is roughly 30 days.

;; Data vars
(define-data-var is-campaign-initialized bool false)
(define-data-var is-campaign-cancelled bool false)
(define-data-var beneficiary principal contract-owner)
(define-data-var campaign-duration uint u173000)
(define-data-var campaign-start uint u0)
(define-data-var campaign-goal uint u0)
(define-data-var total-stx uint u0) ;; in microstacks
(define-data-var total-sbtc uint u0) ;; in sats
(define-data-var donation-count uint u0)
(define-data-var is-campaign-withdrawn bool false)

;; Maps
(define-map stx-donations principal uint)  ;; donor -> amount
(define-map sbtc-donations principal uint) ;; donor -> amount

;; Initialize the campaign (goal in US dollars)
;; Pass duration as 0 to use the default duration (~30 days)
;; Can only be called once
(define-public (initialize-campaign (goal uint) (duration uint))
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (not (var-get is-campaign-initialized)) err-already-initialized)
    (var-set is-campaign-initialized true)
    (var-set campaign-start burn-block-height)
    (var-set campaign-goal goal)
    (var-set campaign-duration duration)
    (var-set campaign-duration (if (is-eq duration u0) 
      default-duration
      duration))
    (ok true)))

;; Cancel the campaign
;; Only the owner can call this, at any time during or after the campaign
;; Allows donors to get a refund
;; Can only be called once
(define-public (cancel-campaign)
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (var-set is-campaign-cancelled true)
    (ok true)))

;; Donate STX. Pass amount in microstacks.
(define-public (donate-stx (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set stx-donations tx-sender 
      (+ (default-to u0 (map-get? stx-donations tx-sender)) amount))
    (var-set total-stx (+ (var-get total-stx) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Donate sBTC. Pass amount in Satoshis.
(define-public (donate-sbtc (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
      amount 
      contract-caller
      (as-contract tx-sender) 
      none))
    (map-set sbtc-donations tx-sender
      (+ (default-to u0 (map-get? sbtc-donations tx-sender)) amount))
    (var-set total-sbtc (+ (var-get total-sbtc) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Withdraw funds (only beneficiary, only if campaign is ended)
(define-public (withdraw)
  (let (
    (total-stx-amount (var-get total-stx))
    (total-sbtc-amount (var-get total-sbtc))
  )
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (asserts! (is-eq tx-sender (var-get beneficiary)) err-not-authorized)
    (asserts! (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration)))
              err-campaign-not-ended)
    (as-contract
      (begin
        (if (> total-stx-amount u0)
          (try! (stx-transfer? total-stx-amount (as-contract tx-sender) (var-get beneficiary)))
          true)
        (if (> total-sbtc-amount u0)
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            total-sbtc-amount
            (as-contract tx-sender)
            (var-get beneficiary)
            none))
          true)
        (var-set is-campaign-withdrawn true)
        (ok true)))))

;; Refund to donor
;; Campaign owner can choose to allow this by cancelling the campaign
(define-public (refund)
  (let (
    (stx-amount (default-to u0 (map-get? stx-donations tx-sender)))
    (sbtc-amount (default-to u0 (map-get? sbtc-donations tx-sender)))
    (contributor tx-sender)
  )
    (asserts! (var-get is-campaign-cancelled) err-not-cancelled)
    (if (> stx-amount u0)
      (begin
        (as-contract
          (try! (stx-transfer? stx-amount tx-sender contributor))))
      true)
      (map-delete stx-donations tx-sender)
    (if (> sbtc-amount u0)
      (begin
        (as-contract
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            sbtc-amount
            tx-sender
            contributor
            none))))
      true)
      (map-delete sbtc-donations tx-sender)
    (ok true)))

;; Getter functions
(define-read-only (get-stx-donation (donor principal))
  (ok (default-to u0 (map-get? stx-donations donor))))

(define-read-only (get-sbtc-donation (donor principal))
  (ok (default-to u0 (map-get? sbtc-donations donor))))

(define-read-only (get-campaign-info)
  (ok {
    start: (var-get campaign-start),
    end: (+ (var-get campaign-start) (var-get campaign-duration)),
    goal: (var-get campaign-goal),
    totalStx: (var-get total-stx),
    totalSbtc: (var-get total-sbtc),
    donationCount: (var-get donation-count),
    isExpired: (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))),
    isWithdrawn: (var-get is-campaign-withdrawn),
    isCancelled: (var-get is-campaign-cancelled),
  }))

(define-read-only (get-contract-balance)
  (stx-get-balance (as-contract tx-sender)))"
"Develop a Clarity smart contract for Stacks that facilitates a payment streaming system. This system should enable users to create sBTC payment streams that automatically transfer funds from the sender to the recipient over a defined block period. The contract must enable stream creation, stream replenishment, recipient fund withdrawal, sender refund of remaining funds at stream completion, and alteration of stream parameters with mutual consent secured by cryptographic signatures. The contract should store stream data, including sender, recipient, balance, withdrawn amount, payment rate, and time constraints, using mappings. The contract should also incorporate error handling to manage unauthorized access, incorrect digital signatures, active stream statuses, and non-existent stream identifiers. Include helper functions to compute available balances and block differences.","The purpose is clear: create a Clarity contract on Stacks for a payment streaming protocol, allowing gradual sBTC transfers from a sender to a recipient over time (blocks). Let's break down the structure and functionality.  The core data representation is a mapping called ""streams"" keyed by a unique stream ID. Each stream stores: sender, recipient, total balance, withdrawn amount, payment rate, and start/end block numbers indicating the stream duration.  A key component will be a ""latest-stream-id"" to provide unique identifiers for streams, incrementing with each new stream creation to ensure unique identification and effective tracking.  Essential contract functions include ""stream-to"", which creates a new stream by receiving sBTC from the sender, setting parameters and returns the Stream ID. The contract uses “contract-caller” to ensure only the sender can create a stream with their funds. The “refuel” function allows the sender to add more funds to an existing stream. It ensures sender authorization then transfers funds and updates balance. Determining the streamed amount is the job of the “calculate-block-delta” and “balance-of” functions: ""calculate-block-delta"" will compute the blocks passed, comparing the current block to stream start and stop. ""balance-of"" will compute the funds available using the payment rate and time passed.  For fund access, the “withdraw” function lets the recipient claim accumulated funds. It verifies recipient identity, computes the available balance, updates the withdrawn amount, and securely transfers the sBTC. A “refund” function allows senders to reclaim unused funds after the stream's conclusion by verifying the current block is beyond the stream end.  To allow for parameter adjustments, the contract will feature an ""update-details"" function. This necessitates the consent of both parties, leveraging cryptographic signatures for secure modification. Functions such as ""hash-stream"" and ""validate-signature"" enable this, allowing a party to propose changes, and the other to confirm them with their unique signature. The contract must incorporate error handling, with individual error codes for scenarios such as unauthorized access, invalid signatures or attempts to refund active or non-existent streams, making the contract robust. Optimization is achieved by designating functions like “balance-of” and “calculate-block-delta” as read-only to minimize gas usage. The sBTC token transfers will be handled using standard interfaces through “contract-call?” to interact with the sBTC contract. The design will utilize the “as-contract” pattern in withdrawals and refunds allowing the contract to initiate these transfers securely.",";; payment-stream.clar

;; Error codes
(define-constant ERR_UNAUTHORIZED (err u0))
(define-constant ERR_INVALID_SIGNATURE (err u1))
(define-constant ERR_STREAM_STILL_ACTIVE (err u2))
(define-constant ERR_INVALID_STREAM_ID (err u3))

;; Data vars
(define-data-var latest-stream-id uint u0)
(define-data-var nonce uint u0)

;; Streams mapping
(define-map streams
    uint  ;; stream-id
    {
        sender: principal,
        recipient: principal,
        balance: uint,
        withdrawn-balance: uint,
        payment-per-block: uint,
        timeframe: (tuple (start-block uint) (stop-block uint))
    }
)

;; Create a new stream
(define-public (stream-to
    (recipient principal)
    (initial-balance uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (payment-per-block uint)
)
    (let (
        (stream {
            sender: contract-caller,
            recipient: recipient,
            balance: initial-balance,
            withdrawn-balance: u0,
            payment-per-block: payment-per-block,
            timeframe: timeframe
        })
        (current-stream-id (var-get latest-stream-id))
    )
        ;; Transfer sBTC from sender to contract
        (try! (contract-call?
            .sbtc-token
            transfer
            initial-balance
            contract-caller
            (as-contract tx-sender)
            none
        ))
        (map-set streams current-stream-id stream)
        (var-set latest-stream-id (+ current-stream-id u1))
        (ok current-stream-id)
    )
)

;; Increase the locked sBTC balance for a stream
(define-public (refuel
    (stream-id uint)
    (amount uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (try! (contract-call?
      .sbtc-token
      transfer
      amount
      contract-caller
      (as-contract tx-sender)
      none
    ))
    (map-set streams stream-id
      (merge stream {balance: (+ (get balance stream) amount)})
    )
    (ok amount)
  )
)

;; Check balance for a party involved in a stream
(define-read-only (balance-of
    (stream-id uint)
    (who principal)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) u0))
    (block-delta (calculate-block-delta (get timeframe stream)))
    (recipient-balance (* block-delta (get payment-per-block stream)))
  )
    (if (is-eq who (get recipient stream))
      (- recipient-balance (get withdrawn-balance stream))
      (if (is-eq who (get sender stream))
        (- (get balance stream) recipient-balance)
        u0
      )
    )
  )
)

;; Calculate the number of blocks a stream has been active
(define-read-only (calculate-block-delta
    (timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (start-block (get start-block timeframe))
    (stop-block (get stop-block timeframe))

    (delta
      (if (<= block-height start-block)
        ;; then
        u0
        ;; else
        (if (< block-height stop-block)
          ;; then
          (- block-height start-block)
          ;; else
          (- stop-block start-block)
        )
      )
    )
  )
    delta
  )
)

;; Withdraw received tokens
(define-public (withdraw
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id contract-caller))
  )
    (asserts! (is-eq contract-caller (get recipient stream)) ERR_UNAUTHORIZED)
    (map-set streams stream-id
      (merge stream {withdrawn-balance: (+ (get withdrawn-balance stream) balance)})
    )
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get recipient stream)
      none
    )))
    (ok balance)
  )
)

;; Withdraw excess locked tokens
(define-public (refund
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id (get sender stream)))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (asserts! (< (get stop-block (get timeframe stream)) block-height) ERR_STREAM_STILL_ACTIVE)
    (map-set streams stream-id (merge stream {
        balance: (- (get balance stream) balance),
      }
    ))
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get sender stream)
      none
    )))
    (ok balance)
  )
)

;; Get hash of stream
(define-read-only (hash-stream
    (stream-id uint)
    (new-payment-per-block uint)
    (new-timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) (sha256 0)))
    (msg (concat (concat (unwrap-panic (to-consensus-buff? stream)) (unwrap-panic (to-consensus-buff? new-payment-per-block))) (unwrap-panic (to-consensus-buff? new-timeframe))))
  )
    (sha256 msg)
  )
)

;; Signature verification
(define-read-only (validate-signature (hash (buff 32)) (signature (buff 65)) (signer principal))
  (is-eq
    (principal-of? (unwrap! (secp256k1-recover? hash signature) false))
    (ok signer)
  )
)

;; Update stream configuration
(define-public (update-details
    (stream-id uint)
    (payment-per-block uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (signer principal)
    (signature (buff 65))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (validate-signature (hash-stream stream-id payment-per-block timeframe) signature signer) ERR_INVALID_SIGNATURE)
    (asserts!
      (or
        (and (is-eq (get sender stream) contract-caller) (is-eq (get recipient stream) signer))
        (and (is-eq (get sender stream) signer) (is-eq (get recipient stream) contract-caller))
      )
      ERR_UNAUTHORIZED
    )
    (map-set streams stream-id (merge stream {
        payment-per-block: payment-per-block,
        timeframe: timeframe
    }))
    (ok true)
  )
)"
"Develop a Clarity smart contract named 'timelocked-wallet' for the Stacks blockchain. This contract should function as a time-locked wallet, permitting the owner to secure STX tokens for a specified recipient until a designated block height. Implement a 'lock' function for token deposits, beneficiary assignment, and unlock height configuration; a 'bestow' function to enable beneficiaries to transfer their rights; and a 'claim' function for beneficiaries to withdraw tokens post-unlock. Incorporate robust error handling to ensure owner-only access, single lock limitations, future unlock height requirements, valid token amounts, beneficiary-only actions, and prevention of premature withdrawals. Utilize data variables to store beneficiary (initially unset) and unlock height (initially zero). Include detailed comments to explain the contract's purpose and functionality.","The question requires creating a time-locked wallet smart contract using Clarity for the Stacks blockchain. This involves understanding Clarity syntax, the Stacks blockchain's characteristics (principals, token transfers, block heights). The contract must lock STX tokens until unlock height. Three functions: lock, bestow, and claim. The contract owner locks tokens for a beneficiary; the beneficiary can transfer rights, and finally claim locked tokens after unlock height. The contract begins with comments explaining its time-locked vault purpose and how it allows token claiming after a specific block height. The contract defines the owner as sender at deployment. Error constants with descriptive names and distinct codes for all error scenarios are established. Data variables include the beneficiary (optional principal, initially 'none') and unlock height (uint, initialized to 0). The lock function uses assertions to validate the operation: sender equals the contract owner, no existing beneficiary, unlock height is in the future, and amount is positive. It then transfers STX tokens from the sender to the contract using stx-transfer?, sets the beneficiary and unlock height, and returns ok true. The bestow function asserts the sender is the current beneficiary, then updates the beneficiary to allow new beneficiaries. It returns ok true. The claim function asserts the sender is the current beneficiary, and current block height is past or equal to unlock height. Then it transfers STX from the contract to the beneficiary. It uses stx-get-balance to get the total amount of tokens in the contract that are sent and unwrap-panic to get the principal of the beneficiary is guaranteed to exist. The code uses error constants for clear indications. The code addresses requirements with security, usability, and maintainability. It handles edge cases, uses Clarity's type system well, and uses best practices on the Stacks blockchain.",";; timelocked-wallet
;; A time-locked vault contract that becomes eligible to claim by the beneficiary after a certain block-height has been reached.

;; Owner
(define-constant contract-owner tx-sender)

;; Errors
(define-constant err-owner-only (err u100))
(define-constant err-already-locked (err u101))
(define-constant err-unlock-in-past (err u102))
(define-constant err-no-value (err u103))
(define-constant err-beneficiary-only (err u104))
(define-constant err-unlock-height-not-reached (err u105))

;; Data
(define-data-var beneficiary (optional principal) none)
(define-data-var unlock-height uint u0)

(define-public (lock (new-beneficiary principal) (unlock-at uint) (amount uint))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(asserts! (is-none (var-get beneficiary)) err-already-locked)
		(asserts! (> unlock-at block-height) err-unlock-in-past)
		(asserts! (> amount u0) err-no-value)
		(try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
		(var-set beneficiary (some new-beneficiary))
		(var-set unlock-height unlock-at)
		(ok true)
	)
)

(define-public (bestow (new-beneficiary principal))
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(var-set beneficiary (some new-beneficiary))
		(ok true)
	)
)

(define-public (claim)
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(asserts! (>= block-height (var-get unlock-height)) err-unlock-height-not-reached)
		(as-contract (stx-transfer? (stx-get-balance tx-sender) tx-sender (unwrap-panic (var-get beneficiary))))
	)
)"
"Develop a Clarity smart contract for a fungible token named ""Clarity Coin"" (symbol ""CC"") on the Stacks blockchain, compliant with the SIP-010 standard.  This token should have an unlimited supply, with only the contract owner authorized to mint new tokens. The contract must include a transfer function (with sender verification and a memo option) and all stipulated read-only functions (get-name, get-symbol, get-decimals, get-balance, get-total-supply, get-token-uri).  Additionally, the contract must define constant error codes to handle cases of unauthorized minting and invalid transfer attempts.","Begin by incorporating the SIP-010 standard trait, a crucial element for compatibility with Stacks fungible tokens, by implementing the trait from its standard path. Afterwards, establish ownership of the contract, setting the deployer as the contract-owner using a constant. Define error codes for rejecting unauthorized minting attempts and rejecting invalid transfer attempts. Create a fungible token 'clarity-coin'. Develop the transfer function, verifying the sender, proceeding with the transfer, and processing memos as optional. Then, implement required read-only functions: get-name, get-symbol, get-decimals, get-balance, get-total-supply, and get-token-uri. Develop a minting function that restricts usage to the contract-owner, minting the token to a recipient, checking the caller, and allowing the minting if authorized. Confirm that all requirements (SIP-010 compliance, sender verification, memo function, read-only properties implementation, exclusive owner minting, absence of supply limits, and inclusive error codes) have been resolved in the contract code.","(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

;; No maximum supply!
(define-fungible-token clarity-coin)

(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(try! (ft-transfer? clarity-coin amount sender recipient))
		(match memo to-print (print to-print) 0x)
		(ok true)
	)
)

(define-read-only (get-name)
	(ok ""Clarity Coin"")
)

(define-read-only (get-symbol)
	(ok ""CC"")
)

(define-read-only (get-decimals)
	(ok u0)
)

(define-read-only (get-balance (who principal))
	(ok (ft-get-balance clarity-coin who))
)

(define-read-only (get-total-supply)
	(ok (ft-get-supply clarity-coin))
)

(define-read-only (get-token-uri)
	(ok none)
)

(define-public (mint (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(ft-mint? clarity-coin amount recipient)
	)
)"
"Develop a Stacks Clarity smart contract for an NFT collection named ""stacksies"" conforming to the nft-trait standard.  The contract should allow the owner to mint NFTs, token holders to transfer NFTs, and provide read-only functions for token details (last token ID, URI, and owner). Implement error handling to restrict minting and transfers to authorized parties (owner and token owners, respectively).","The core task is building a compliant ""stacksies"" NFT contract on Stacks, implementing minting, transferring, and querying features. The contract must adhere to the nft-trait standard. Error handling must prevent unauthorized minting/transferring. I need to analyze how the contract code fulfills these requirements, starting by examining its components and functionalities. Specifically, I will analyze how the contract uses the nft-trait standard, defines constants and data variables, implements read-only functions for information retrieval and ensures correct error handling, particularly the security aspects of minting and transferring tokens.","(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

(define-non-fungible-token stacksies uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
	(ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

(define-read-only (get-owner (token-id uint))
	(ok (nft-get-owner? stacksies token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(nft-transfer? stacksies token-id sender recipient)
	)
)

(define-public (mint (recipient principal))
	(let
		(
			(token-id (+ (var-get last-token-id) u1))
		)
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (nft-mint? stacksies token-id recipient))
		(var-set last-token-id token-id)
		(ok token-id)
	)
)"
"Develop a Stacks Clarity smart contract for accessing live price data (e.g., BTC/USD) from the Pyth Network using the Stacks-Pyth Bridge, including deployment and testing instructions.","The user needs a Clarity contract on Stacks to fetch real-time BTC/USD price data from Pyth via the Stacks-Pyth Bridge. This involves understanding the bridge's integration, likely using pyth-storage-trait and pyth-decoder-trait. Firstly, I define constants for Pyth Oracle and storage contract addresses, plus the 32-byte hex feed ID for BTC/USD. Using `define-constant` is crucial for these. The core function will call the Pyth Oracle's `get-price` function, supplying the feed ID and storage contract address. The storage contract may require `as-contract` when calling. Error handling is essential, likely using `try!` and `unwrap!` to catch issues like invalid storage addresses. Deciding on read-only versus public: a read-only might suffice for data retrieval, but if the oracle interaction has state changes, then a public function is required. The choice impacts the potential need to handle errors internally (through try!) or to allow error propagation in the return type like `ok price` or `error`. Given the integration of `pyth-storage-trait`, constants for oracle/storage contracts are vital. The main function should use `define-public`, calling the Oracle's `get-price` function and managing potential errors. If `as-contract` is needed for correct storage context, include it. The code will be well-documented explaining, for instance, the use of pyth-governance-v2 for governance checks, explanations of how to use as-contract, and the function's response handling. The approach involves modularity, so code can be more easily tested with Clarinet, and it promotes easy maintainability through the creation of distinct roles for governance, price retrieval, and error processing. This strategy leads to the creation of a stable, well-defined blueprint.",";; Pyth Oracle integration for BTC/USD price feed
(use-trait pyth-storage-trait 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q.pyth-traits-v1.storage-trait)

(define-constant PYTH-ORACLE 'SP3Z6MY8HT7D7KJE0D1BZ4YF40S7RMM9Y8G1B9P5G)
(define-constant PYTH-STORAGE 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q)
(define-constant BTC-USD-FEED-ID 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43)

(define-read-only (get-btc-price)
  (match (contract-call? 
          PYTH-ORACLE 
          get-price 
          BTC-USD-FEED-ID 
          (as-contract PYTH-STORAGE)
         )
    price (ok price)
    err (err err)
  )
)

(define-public (update-btc-price (price-feed-bytes (buff 8192)))
  (begin
    (contract-call? 
      PYTH-ORACLE 
      verify-and-update-price-feeds 
      price-feed-bytes 
      {
        pyth-storage-contract: PYTH-STORAGE,
        pyth-decoder-contract: 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR,
        wormhole-core-contract: 'SP3HXJJMJQ06GNAZ8XWDN1QM48JEDC6PP6W3YZPZJ
      }
    )
  )
)"
"Develop a Clarity smart contract named 'MyToken' (MTK) with eight decimals, initializing 21,000,000,000 tokens, and distributing 200 to ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M and 100 to ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9. The contract should enable token transfers, allowance approvals, balance checks, and total supply viewing. Additionally, provide functionality to revoke spending permissions and include the metadata ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc.","The user requests a Clarity smart contract for a token (MyToken, MTK) featuring 8 decimals. The contract should start with a 21 billion token supply and pre-allocate tokens to two specified addresses. The contract should be able to transfer tokens, manage allowances, and provide balance and total supply information. A revoke function is also required. The contract needs to include a metadata IPFS link. I need to design the contract to meet these requirements, establishing initial token allocations, and implementing standard transfer methods while also setting up allowance management for users to grant and revoke spending permissions. Furthermore, the contract should handle the supply correctly, and ensure secure implementation by using private functions where necessary."," 
(define-fungible-token fungible-token)

;; Storage
(define-map allowances
  ((spender principal) (owner principal))
  ((allowance uint)))
(define-data-var total-supply uint u21000000000)

;; Internals

;; Total number of tokens in existence.
(define-private (get-total-supply)
  (var-get total-supply))

;; Gets the amount of tokens that an owner allowed to a spender.
(define-private (allowance (spender principal) (owner principal))
  (let ((allowance-val (default-to u0 (map-get? allowances (tuple (spender owner))))))
    allowance-val
  )
)


;; Transfers tokens to a specified principal.
(define-private (transfer (amount uint) (sender principal) (recipient principal) )
  (match (ft-transfer? fungible-token amount sender recipient)
    result (ok true)
    error (err false))
)

;; Decrease allowance of a specified spender.
(define-private (decrease-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (or (> amount allowance-val) (<= amount u0))
      true
      (begin
        (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (- allowance-val amount))))
        true)))
        )
        
;; Internal - Increase allowance of a specified spender.
(define-private (increase-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (<= amount u0)
      false
      (begin
         (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (+ allowance-val amount))))
        true))))

;; Public functions

;; Transfers tokens to a specified principal.
(define-public (transfer-token (amount uint) (recipient principal) )
  (transfer amount tx-sender recipient)
)

;; Transfers tokens to a specified principal, performed by a spender
(define-public (transfer-from (amount uint) (owner principal) (recipient principal) )
  (let ((allowance (allowance tx-sender owner)))
    (begin
      (if (or (> amount allowance-val) (<= amount u0))
        (err false)
        (if (and
            (unwrap! (transfer amount owner recipient) (err false))
            (decrease-allowance amount tx-sender owner))
        (ok true)
        (err false)))))
)

;; Update the allowance for a given spender
(define-public (approve (amount uint) (spender principal) )
  (if (and (> amount u0)
           (print (increase-allowance amount spender tx-sender )))
      (ok amount)
      (err false)))

;; Revoke a given spender
(define-public (revoke (spender principal))
  (let ((allowance-val (allowance spender tx-sender)))
    (if (and (> allowance-val u0)
             (decrease-allowance allowance-val spender tx-sender))
        (ok 0)
        (err false))))

;; Retrieve the human-readable name of the token
(define-public (get-name)
  ""MyToken""
)

;; Retrieve the ticker symbol of the token
(define-public (get-symbol)
  ""MTK""
)

;; Retrieve the number of decimals used
(define-public (get-decimals)
  8 ;; Assuming 8 decimals
)

;; Retrieve the balance of a specific principal
(define-public (get-balance (owner principal))
  (ft-get-balance fungible-token owner)
)

;; Retrieve the current total supply
(define-public (get-total-supply)
  (var-get total-supply)
)

;; Retrieve an example URI that represents metadata of this token
(define-public (get-token-uri)
  ""ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc""
)

;; Mint new tokens.
(define-private (mint (amount uint) (account principal))
  (if (<= amount u0)
      (err false)
      (begin
        (var-set total-supply (+ (var-get total-supply) amount))
        (ft-mint? fungible-token amount account)
        (ok amount))))

;; Initialize the contract
(begin
  (mint u200 'ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M)
  (mint u100 'ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9))"
"Develop a Clarity smart contract for a Stacks blockchain multisig wallet. This wallet should support owner management with threshold requirements, transaction lifecycle management (submission, confirmation, revocation), and cross-chain token swaps utilizing a magic bridge. The implementation must integrate SIP-009 (NFT) and SIP-010 (FT) traits for asset transfers, enforce access restrictions via allowed callers, validate transaction confirmations against required thresholds, and include error handling for ownership conflicts, invalid inputs, and unauthorized actions. The code should be well-structured with comments and data structures like maps for managing transactions and owners, with helper functions ensuring internal state modifications, and security measures such as sender authentication and input validation.","The code defines a Clarity smart contract (Multisafe) for a multi-signature wallet on the Stacks blockchain. This requires multiple approvals to authorize operations. The contract uses several traits for core functionality: executors, safes, NFTs, fungible tokens, and a cross-chain ""magic bridge"". It implements the safe-trait interface, making itself a safe. Error messages handle various failures, including authentication and transaction issues. The constant (SELF) references the contract's own principal for actions. Essential state variables include owner list, confirmation threshold, and transaction nonce, crucial for multi-signature functionality. Owner management includes adding and removing owners, with threshold validation (greater than zero and less than or equal to the number of owners). The transaction flow is submit → confirm → execute. Transactions are stored in a map with parameters and confirmation status. Owners can submit, confirm, or revoke confirmations to ensure transactions are authorized. Most functions enforce security by authenticating the caller as the contract or an owner. The contract integrates with a ""magic bridge"" for cross-chain functionality, letting owners initialize swappers and execute escrow swaps. An initialization function sets up initial owners and the threshold; this particular one has three owners with a threshold of 2. This builds a secure, flexible multi-signature wallet with cross-chain support.",";;title: safe-clar

(use-trait executor-trait .traits.executor-trait) 
(use-trait safe-trait .traits.safe-trait)
(use-trait nft-trait .traits.sip-009-trait)
(use-trait ft-trait .traits.sip-010-trait)
(use-trait magic-bridge-trait .traits.magic-bridge-trait)

(impl-trait .traits.safe-trait)

(define-constant ERR-CALLER-MUST-BE-SELF (err u100))
(define-constant ERR-OWNER-ALREADY-EXISTS (err u110))
(define-constant ERR-OWNER-NOT-EXISTS (err u120))
(define-constant ERR-UNAUTHORIZED-SENDER (err u130))
(define-constant ERR-ONLY-END-USER (err u135))
(define-constant ERR-TX-NOT-FOUND (err u140))
(define-constant ERR-TX-ALREADY-CONFIRMED-BY-OWNER (err u150))
(define-constant ERR-TX-INVALID-EXECUTOR (err u160))
(define-constant ERR-INVALID-SAFE (err u170))
(define-constant ERR-TX-CONFIRMED (err u180))
(define-constant ERR-TX-NOT-CONFIRMED-BY-SENDER (err u190))
(define-constant ERR-THRESHOLD-CANT-BE-ZERO (err u210))
(define-constant ERR-OWNER-OVERFLOW (err u220))
(define-constant ERR-THRESHOLD-OVERFLOW (err u230))
(define-constant ERR-TX-INVALID-FT (err u240))
(define-constant ERR-TX-INVALID-NFT (err u250))
(define-constant ERR-MB-ADDRESS-NOT-SET (err u260))
(define-constant ERR-INVALID-MB-ADDRESS (err u270))

(define-constant SELF (as-contract tx-sender))


(define-constant VERSION ""0.0.5.beta"")

(define-read-only (get-version) 
    VERSION
)


(define-data-var owners (list 20 principal) (list)) 

(define-read-only (get-owners)
    (var-get owners)
)

(define-private (add-owner-internal (owner principal))
    (let 
        (
           (new-owners (unwrap! (as-max-len? (append (var-get owners) owner) u20) ERR-OWNER-OVERFLOW))
        )
        (ok (var-set owners new-owners))
    )
)

(define-public (add-owner (owner principal))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (is-none (index-of (var-get owners) owner)) ERR-OWNER-ALREADY-EXISTS)
        (add-owner-internal owner)
    )
)

(define-data-var rem-owner principal tx-sender)

(define-private (remove-owner-filter (owner principal)) (not (is-eq owner (var-get rem-owner))))

(define-public (remove-owner (owner principal))
    (let
        (
            (owners-list (var-get owners))
        )
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (is-some (index-of owners-list owner)) ERR-OWNER-NOT-EXISTS)
        (asserts! (>= (- (len owners-list) u1) (var-get threshold)) ERR-THRESHOLD-OVERFLOW)
        (var-set rem-owner owner)
        (ok (var-set owners (unwrap-panic (as-max-len? (filter remove-owner-filter owners-list) u20))))
    )
)



(define-data-var threshold uint u1)

(define-read-only (get-threshold)
    (var-get threshold)
)

(define-private (set-threshold-internal (value uint))
    (var-set threshold value)
)

(define-public (set-threshold (value uint))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (> value u0) ERR-THRESHOLD-CANT-BE-ZERO)
        (asserts! (<= value (len (var-get owners))) ERR-THRESHOLD-OVERFLOW)
        (ok (set-threshold-internal value))
    )
)


(define-data-var nonce uint u0)

(define-read-only (get-nonce)
 (var-get nonce)
)

(define-private (increase-nonce)
    (var-set nonce (+ (var-get nonce) u1))
)



(define-map allowed-callers principal bool)

(define-public (allow-caller (caller principal))
  (begin
    (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
    (ok (map-set allowed-callers caller true))
  )
)

(define-public (revoke-caller (caller principal))
  (begin
    (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
    (ok (map-delete allowed-callers caller))
  )
)

(define-read-only (is-allowed-caller (caller principal))
  (or
    (match (map-get? allowed-callers caller)
      value true
      false
    )
    (is-eq tx-sender caller)
  )
)


(define-read-only (get-info)
    (ok {
        version: (get-version),
        owners: (get-owners),
        threshold: (get-threshold),
        nonce: (get-nonce),
        mb-address: (get-mb-address)
    })
)




(define-map transactions 
    uint 
    {
        executor: principal,
        threshold: uint,
        confirmations: (list 20 principal),
        confirmed: bool,
        param-ft: principal,
        param-nft: principal,
        param-p: (optional principal),
        param-u: (optional uint),
        param-b: (optional (buff 20))
    }
)

(define-private (add (executor <executor-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>) (param-p (optional principal)) (param-u (optional uint)) (param-b (optional (buff 20))))
    (let 
        (
            (tx-id (get-nonce))
        ) 
        (map-insert transactions tx-id {
            executor: (contract-of executor),
            threshold: (var-get threshold), 
            confirmations: (list), 
            confirmed: false,
            param-ft: (contract-of param-ft),
            param-nft: (contract-of param-nft),
            param-p: param-p,
            param-u: param-u,
            param-b: param-b
        })
        (increase-nonce)
        tx-id
    )
)

(define-read-only (get-transaction (tx-id uint))
    (merge {id: tx-id} (unwrap-panic (map-get? transactions tx-id)))
)

(define-read-only (get-transactions (tx-ids (list 20 uint)))
    (map get-transaction tx-ids)
)

(define-data-var rem-confirmation principal tx-sender)

(define-private (remove-confirmation-filter (owner principal)) (not (is-eq owner (var-get rem-confirmation))))


(define-public (revoke (tx-id uint))
    (let 
        (
            (tx (unwrap! (map-get? transactions tx-id) ERR-TX-NOT-FOUND))
            (confirmations (get confirmations tx))
        )
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-eq (get confirmed tx) false) ERR-TX-CONFIRMED)
        (asserts! (is-some (index-of confirmations tx-sender)) ERR-TX-NOT-CONFIRMED-BY-SENDER)
        (var-set rem-confirmation tx-sender)
        (let 
            (
                (new-confirmations  (unwrap-panic (as-max-len? (filter remove-confirmation-filter confirmations) u20)))
                (new-tx (merge tx {confirmations: new-confirmations}))
            )
            (map-set transactions tx-id new-tx)
            (print {action: ""multisafe-revoke"", sender: tx-sender, tx-id: tx-id})
            (ok true)
        )
    )
)


(define-public (confirm (tx-id uint) (executor <executor-trait>) (safe <safe-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>))
    (begin
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (asserts! (is-eq (contract-of safe) SELF) ERR-INVALID-SAFE) 
        (let
            (
                (tx (unwrap! (map-get? transactions tx-id) ERR-TX-NOT-FOUND))
                (confirmations (get confirmations tx))
            )

            (asserts! (is-eq (get confirmed tx) false) ERR-TX-CONFIRMED)
            (asserts! (is-none (index-of confirmations tx-sender)) ERR-TX-ALREADY-CONFIRMED-BY-OWNER)
            (asserts! (is-eq (get executor tx) (contract-of executor)) ERR-TX-INVALID-EXECUTOR)
            (asserts! (is-eq (get param-ft tx) (contract-of param-ft)) ERR-TX-INVALID-FT)
            (asserts! (is-eq (get param-nft tx) (contract-of param-nft)) ERR-TX-INVALID-NFT)
            
            (let 
                (
                    (new-confirmations (unwrap-panic (as-max-len? (append confirmations tx-sender) u20)))
                    (confirmed (>= (len new-confirmations) (get threshold tx)))
                    (new-tx (merge tx {confirmations: new-confirmations, confirmed: confirmed}))
                )
                (map-set transactions tx-id new-tx)
                (and confirmed (try! (as-contract (contract-call? executor execute safe param-ft param-nft (get param-p tx) (get param-u tx) (get param-b tx)))))
                (print {action: ""multisafe-confirmation"", sender: tx-sender, tx-id: tx-id, confirmed: confirmed})
                (ok confirmed)
            )
        )
    )
)

(define-public (submit (executor <executor-trait>) (safe <safe-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>) (param-p (optional principal)) (param-u (optional uint)) (param-b (optional (buff 20))))
    (begin
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (asserts! (is-eq (contract-of safe) SELF) ERR-INVALID-SAFE) 
        (let
            ((tx-id (add executor param-ft param-nft param-p param-u param-b)))
            (print {action: ""multisafe-submit"", sender: tx-sender, tx-id: tx-id, executor: executor, param-ft: param-ft, param-nft: param-nft, param-p: param-p, param-u: param-u, param-b: param-b})
            (unwrap-panic (confirm tx-id executor safe param-ft param-nft))
            (ok tx-id)
        )
    )
)


(define-data-var mb-address principal SELF)

(define-public (set-mb-address (address principal))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (ok (var-set mb-address address))
    )
)

(define-read-only (get-mb-address)
 (var-get mb-address)
)

(define-public (mb-initialize-swapper (bridge <magic-bridge-trait>))
    (begin
        (asserts! (not (is-eq (var-get mb-address) SELF)) ERR-MB-ADDRESS-NOT-SET)
        (asserts! (is-eq (contract-of bridge) (var-get mb-address)) ERR-INVALID-MB-ADDRESS)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (try! (as-contract (contract-call? bridge initialize-swapper)))
        (ok true)
    )
)

(define-public (mb-escrow-swap 
    (bridge <magic-bridge-trait>)
    (block { header: (buff 80), height: uint })
    (prev-blocks (list 10 (buff 80)))
    (tx (buff 1024))
    (proof { tx-index: uint, hashes: (list 12 (buff 32)), tree-depth: uint })
    (output-index uint)
    (sender (buff 33))
    (recipient (buff 33))
    (expiration-buff (buff 4))
    (hash (buff 32))
    (swapper-buff (buff 4))
    (supplier-id uint)
    (min-to-receive uint)
  )
    (begin
        (asserts! (not (is-eq (var-get mb-address) SELF)) ERR-MB-ADDRESS-NOT-SET)
        (asserts! (is-eq (contract-of bridge) (var-get mb-address)) ERR-INVALID-MB-ADDRESS)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (try! (as-contract (contract-call? bridge escrow-swap block prev-blocks tx proof output-index sender recipient expiration-buff hash swapper-buff supplier-id min-to-receive)))
        (ok true)
    )
)

(define-private (init (o (list 20 principal)) (m uint))
    (begin
        (map add-owner-internal o)
        (set-threshold-internal m)
        (print {action: ""multisafe-init""})
    )
)

(init (list 
    'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 
    'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG 
    'ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC
) u2) "
"Create a Stacks blockchain Clarity smart contract for a BTC/USD price oracle. This contract should get both real-time and historical price data from the Pyth Network (using the pyth-storage-v3 contract and a price feed ID), and incorporate granular error codes for management. Implement support for historical queries via at-block and Stacks block header hashes. Also, integrate with the sbtc-token contract to obtain the total supply, allowing the contract to normalize values, and calculate the total sBTC value in USD. The contract must include robust error handling for external call failures, incorrect data, and potential arithmetic overflows, with a design that emphasizes read-only functions, type-safe data validation, and explicitly defined dependencies on external contracts and traits.","This smart contract aims to fetch and process BTC/USD price information from the Pyth Network, with a key focus on error management and modular design. Namely, error handling is addressed by setting a base of error codes, with specific codes for unexpected failures, ensuring consistent handling of various failure points. 

The `get-btc-price` function is then the path to get real-time BTC prices by calling `pyth-storage-v3` using `contract-call?` and its price feed ID, also handling the responses. If the call is successful, price is returned wrapped in `some`; otherwise, the function returns `none`, making sure that failures don’t break execution. 

Historical prices retrieval works differently. The `get-btc-price-at` obtains the block hash using `get-stacks-block-info?`, checking its validity with `unwrap-panic`, which ensures the hash exists. The price retrieval uses `at-block` at that block, with parallel error management of the real-time fetching.

Integration of `sbtc-token` is done through the `get-sbtc-total-supply` function, which fetches the total supply of sBTC using `contract-call?` for safe interaction with the token contract. The `get-sbtc-total-usd-value` function gathers all components. First, it obtains the sBTC supply and normalizes by dividing by `10^8`, and then performs the same processing to the BTC price, before calculating the USD value from the multiplication. The `unwrap!` function guarantees failures are caught early on runtime.

The design includes read-only functions to protect state and reuse the code, clearly defined dependencies on the external contracts, and type safety to prevent arithmetic overflow or invalid data. The structure of modular calls makes the contract maintainable, achieving a robust functionality.","(define-constant ERR_UNEXPECTED (err u5000))

(define-read-only (get-btc-price)
  (match
    (contract-call?
      'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
      get-price
      0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
    )
    res (some (get price res))
    e none
  )
)

(define-read-only (get-btc-price-at (height uint))
  (let (
    (hash (unwrap-panic (get-stacks-block-info? id-header-hash height)))
  )
    (at-block hash (match
      (contract-call?
        'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
        get-price
        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
      )
      res (some (get price res))
      e none
    ))
  )
)

(define-read-only (get-sbtc-total-supply)
  (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-total-supply)
)

(define-read-only (get-sbtc-total-usd-value)
  (let (
    (sbtc-total-supply (/ (unwrap! (get-sbtc-total-supply) ERR_UNEXPECTED) u100000000))
    (btc-price (/ (to-uint (unwrap! (get-btc-price) ERR_UNEXPECTED)) u100000000))
  )
    (ok (* sbtc-total-supply btc-price))
  )
)"
"Develop a Clarity smart contract that validates Bitcoin transactions using Merkle proofs, block headers, and SegWit witness data, incorporating comprehensive error handling and ensuring strict data length validation for all operations.","The core requirement is a Clarity smart contract to verify Bitcoin transactions. This involves verifying tx details using merkle proofs and blockheaders, supporting SegWit transactions, and robust error handling. Let's break this down.  I need to define error codes for different failure scenarios. Dealing with cryptographic verification means potential failures during data buffer reading, size constraint violations, and invalid proofs. Defining constants improves maintainability and readability. These become important during raw transaction data parsing where malformed data might exist.
I’ll create helper functions to parse variable-length fields which are common in Bitcoin transactions: fixed-size integers (read-uint8, etc.) which take context (txbuff, current index) and return value/updated context. Bitcoin's varints require a specific parser where the prefix byte defines how to interpret subsequent bytes; this is critical for correct transaction parsing. Variable-length byte arrays (varslices) are another common data type needing a parser (varint indicating length followed by data bytes). Hash values in Bitcoin are little-endian unlike typical big-endian, thus requiring conversion functions like reverse-buff32.
The parse-tx function will parse version, inputs, outputs, and locktime extracting information from the transaction. SegWit transactions necessitate parse-wtx for witness data handling. Both will rely on basic readers following Bitcoin's serialization format and checking that we consume exactly the data provided. The block header parsing is critical. The parse-block-header function extracts version, parent hash, merkle root, timestamp, difficulty bits, and nonce. Merkle proof verification is also required; calculating the merkle root from the proof path and comparing it with the block header's merkle root. The fold operation will process each tree level. Mocking blockchain data, using a map to store mock header hashes, will aid in testing and debugging.
SegWit validation requires separate functions to identify and validate the commitment. The was-segwit-tx-mined-compact function verifies both the transaction inclusion and the witness commitment. The overall verification process will first verify that the block header matches the expected height. Then, we will verify the transaction's merkle proof with the block's merkle root, and for SegWit, verify the witness commitment. The final API needs user-friendly functions was-tx-mined-compact (regular transactions) and was-segwit-tx-mined-compact (for SegWit). The important thing is to handle buffer size limits, as Clarity has them; thus I need functions (unwrap-panic, as-max-len?) to handle the maximum lengths for all buffers (scriptSig, scriptPubKey, etc). Finally, execution flow and error handling are crucial. Since Clarity is non-Turing complete, operations must be deterministic with proper error handling, using operators like try! and unwrap! to propagate errors.
In summary, parsing Bitcoin transaction data, validating cryptographic proofs, and handling edge cases within the constraints of Clarity are all needed. The logic will be complex and provide a verification mechanism for Bitcoin transactions within a Clarity-based system.",";; title: stateless contract to verify bitcoin transaction

(define-constant ERR-OUT-OF-BOUNDS u1)
(define-constant ERR-TOO-MANY-TXINS u2)
(define-constant ERR-TOO-MANY-TXOUTS u3)
(define-constant ERR-VARSLICE-TOO-LONG u4)
(define-constant ERR-BAD-HEADER u5)
(define-constant ERR-HEADER-HEIGHT-MISMATCH u6)
(define-constant ERR-INVALID-MERKLE-PROOF u7)
(define-constant ERR-PROOF-TOO-SHORT u8)
(define-constant ERR-TOO-MANY-WITNESSES u9)
(define-constant ERR-INVALID-COMMITMENT u10)
(define-constant ERR-WITNESS-TX-NOT-IN-COMMITMENT u11)
(define-constant ERR-NOT-SEGWIT-TRANSACTION u12)
(define-constant ERR-LEFTOVER-DATA u13)


(define-private (bool-list-of-len (n uint))
	(unwrap-panic (slice? (list true true true true true true true true) u0 n)))

(define-read-only (read-uint8 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint8: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u1)) (err ERR-OUT-OF-BOUNDS)) u1))),
						 ctx: { txbuff: data, index: (+ u1 base)}})))

(define-read-only (read-uint16 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint16: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u2)) (err ERR-OUT-OF-BOUNDS)) u2))),
						 ctx: { txbuff: data, index: (+ u2 base)}})))

(define-read-only (read-uint32 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint32: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u4)) (err ERR-OUT-OF-BOUNDS)) u4))),
						 ctx: { txbuff: data, index: (+ u4 base)}})))

(define-read-only (read-uint64 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint64: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u8)) (err ERR-OUT-OF-BOUNDS)) u8))),
						 ctx: { txbuff: data, index: (+ u8 base)}})))

(define-read-only (read-varint (ctx { txbuff: (buff 4096), index: uint}))
		(let ((ptr (get index ctx))
					(tx (get txbuff ctx))
					(byte (buff-to-uint-le (unwrap! (element-at tx ptr)
																	(err ERR-OUT-OF-BOUNDS)))))
		 (if (<= byte u252)
				 (ok { varint: byte, ctx: { txbuff: tx, index: (+ u1 ptr)}})
				 (if (is-eq byte u253)
						 (let (
									 (parsed-u16 (try! (read-uint16 { txbuff: tx, index: (+ u1 ptr)}))))
								 (ok { varint: (get uint16 parsed-u16), ctx: (get ctx parsed-u16)}))
						 (if (is-eq byte u254)
								 (let (
											 (parsed-u32 (try! (read-uint32 { txbuff: tx, index: (+ u1 ptr)}))))
										 (ok { varint: (get uint32 parsed-u32), ctx: (get ctx parsed-u32)}))
								 (let (
											 (parsed-u64 (try! (read-uint64 { txbuff: tx, index: (+ u1 ptr)}))))
									(ok { varint: (get uint64 parsed-u64), ctx: (get ctx parsed-u64)})))))))

(define-read-only (read-varslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed (try! (read-varint old-ctx)))
					(ctx (get ctx parsed))
					(slice-start (get index ctx))
					(target-index (+ slice-start (get varint parsed)))
					(txbuff (get txbuff ctx)))
		 (ok {varslice: (unwrap! (slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-private (reverse-buff16 (input (buff 16)))
	(unwrap-panic (slice? (unwrap-panic (to-consensus-buff? (buff-to-uint-le input))) u1 u17)))

(define-read-only (reverse-buff32 (input (buff 32)))
	(unwrap-panic (as-max-len? (concat
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u16 u32)) u16)))
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u0 u16)) u16)))) u32)))

(define-read-only (read-hashslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((slice-start (get index old-ctx))
					(target-index (+ u32 slice-start))
					(txbuff (get txbuff old-ctx))
					(hash-le (unwrap-panic
											(as-max-len? (unwrap!
																			(slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)) u32))))
		 (ok {hashslice: (reverse-buff32 hash-le),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-read-only (read-next-txin (ignored bool)
																	(result (response {ctx: { txbuff: (buff 4096), index: uint },
																												remaining: uint,
																												txins: (list 8 {outpoint: {
																																									 hash: (buff 32),
																																									 index: uint},
																																				sequence: uint})}
																							uint)))
		(let ((state (unwrap! result result)))
							(let ((remaining (get remaining state))
										(ctx (get ctx state))
										(parsed-hash (try! (read-hashslice ctx)))
										(parsed-index (try! (read-uint32 (get ctx parsed-hash))))
										(parsed-scriptSig (try! (read-varslice (get ctx parsed-index))))
										(parsed-sequence (try! (read-uint32 (get ctx parsed-scriptSig))))
										(new-ctx (get ctx parsed-sequence)))
								(ok {ctx: new-ctx,
										remaining: (- remaining u1),
										txins: (unwrap!
														(as-max-len?
																(append (get txins state) {   outpoint: {
																										hash: (get hashslice parsed-hash),
																										index: (get uint32 parsed-index) },
																				scriptSig: (unwrap! (as-max-len? (get varslice parsed-scriptSig) u256) (err ERR-VARSLICE-TOO-LONG)),
																				sequence: (get uint32 parsed-sequence)}) u8)
														(err ERR-TOO-MANY-TXINS))}))
							))

(define-read-only (read-txins (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txins (try! (read-varint ctx)))
					(num-txins (get varint parsed-num-txins))
					(new-ctx (get ctx parsed-num-txins)))
		 (if (> num-txins u8)
				 (err ERR-TOO-MANY-TXINS)
				 (fold read-next-txin (bool-list-of-len num-txins) (ok { ctx: new-ctx, remaining: num-txins, txins: (list)})))))

(define-read-only (read-next-txout (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																											txouts: (list 8 {value: uint,
																																			 scriptPubKey: (buff 128)})}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-value (try! (read-uint64 (get ctx state))))
					(parsed-script (try! (read-varslice (get ctx parsed-value))))
					(new-ctx (get ctx parsed-script)))
				(ok {ctx: new-ctx,
						txouts: (unwrap!
											(as-max-len?
													(append (get txouts state)
															{   value: (get uint64 parsed-value),
																	scriptPubKey: (unwrap! (as-max-len? (get varslice parsed-script) u128) (err ERR-VARSLICE-TOO-LONG))}) u8)
											(err ERR-TOO-MANY-TXOUTS))})))

(define-read-only (read-txouts (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txouts (try! (read-varint ctx)))
					(num-txouts (get varint parsed-num-txouts))
					(new-ctx (get ctx parsed-num-txouts)))
		 (if (> num-txouts u8)
				 (err ERR-TOO-MANY-TXOUTS)
				 (fold read-next-txout (bool-list-of-len num-txouts) (ok { ctx: new-ctx, txouts: (list)})))))

(define-read-only (read-next-item (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																												 items: (list 8 (buff 128))}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-item (try! (read-varslice (get ctx state))))
					(new-ctx (get ctx parsed-item)))
				(ok {ctx: new-ctx,
						items: (unwrap!
											(as-max-len?
													(append (get items state) (unwrap! (as-max-len? (get varslice parsed-item) u128) (err ERR-VARSLICE-TOO-LONG))) u8)
											(err ERR-TOO-MANY-WITNESSES))})))

(define-read-only (read-next-witness (ignored bool)
	(result (response
		{ ctx: {txbuff: (buff 4096), index: uint}, witnesses: (list 8 (list 8 (buff 128))) } uint)))
	(let ((state (unwrap! result result))
				(parsed-num-items (try! (read-varint (get ctx state))))
				(ctx (get ctx parsed-num-items))
				(varint (get varint parsed-num-items)))
			(if (> varint u0)
				(let ((parsed-items (try! (fold read-next-item (bool-list-of-len varint) (ok { ctx: ctx, items: (list)})))))
						(ok {
							witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (get items parsed-items)) u8)),
							ctx: (get ctx parsed-items)
						}))
				(ok {
					witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (list)) u8)),
					ctx: ctx
				}))))

(define-read-only (read-witnesses (ctx { txbuff: (buff 4096), index: uint }) (num-txins uint))
	(fold read-next-witness (bool-list-of-len num-txins) (ok { ctx: ctx, witnesses: (list) })))

(define-read-only (parse-wtx (tx (buff 4096)) (calculate-txid bool))
		(let ((ctx { txbuff: tx, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-segwit-marker (try! (read-uint8 (get ctx parsed-version))))
					(parsed-segwit-version (try! (read-uint8 (get ctx parsed-segwit-marker))))
					(parsed-txins (try! (read-txins (get ctx parsed-segwit-version))))
					(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
					(parsed-witnesses (try! (read-witnesses (get ctx parsed-txouts) (len (get txins parsed-txins)))))
					(parsed-locktime (try! (read-uint32 (get ctx parsed-witnesses))))
					)
		(asserts! (and (is-eq (get uint8 parsed-segwit-marker) u0) (is-eq (get uint8 parsed-segwit-version) u1)) (err ERR-NOT-SEGWIT-TRANSACTION))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			segwit-marker: (get uint8 parsed-segwit-marker),
			segwit-version: (get uint8 parsed-segwit-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			txid: (if calculate-txid
				(some (reverse-buff32 (sha256 (sha256
					(concat
						(unwrap-panic (slice? tx u0 u4))
					(concat
						(unwrap-panic (slice? tx (get index (get ctx parsed-segwit-version)) (get index (get ctx parsed-txouts))))
						(unwrap-panic (slice? tx (get index (get ctx parsed-witnesses)) (len tx)))))))))
				none),
			witnesses: (get witnesses parsed-witnesses),
			locktime: (get uint32 parsed-locktime)
		})))

(define-read-only (parse-tx (tx (buff 4096)))
		(let ((ctx { txbuff: tx, index: u0})
			(parsed-version (try! (read-uint32 ctx)))
			(parsed-txins (try! (read-txins (get ctx parsed-version))))
			(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
			(parsed-locktime (try! (read-uint32 (get ctx parsed-txouts)))))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			locktime: (get uint32 parsed-locktime)})))

(define-read-only (parse-block-header (headerbuff (buff 80)))
		(let ((ctx { txbuff: headerbuff, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-parent-hash (try! (read-hashslice (get ctx parsed-version))))
					(parsed-merkle-root (try! (read-hashslice (get ctx parsed-parent-hash))))
					(parsed-timestamp (try! (read-uint32 (get ctx parsed-merkle-root))))
					(parsed-nbits (try! (read-uint32 (get ctx parsed-timestamp))))
					(parsed-nonce (try! (read-uint32 (get ctx parsed-nbits)))))
		 (ok {version: (get uint32 parsed-version),
					parent: (get hashslice parsed-parent-hash),
					merkle-root: (get hashslice parsed-merkle-root),
					timestamp: (get uint32 parsed-timestamp),
					nbits: (get uint32 parsed-nbits),
					nonce: (get uint32 parsed-nonce)})))

(define-constant DEBUG-MODE true)

(define-map mock-burnchain-header-hashes uint (buff 32))

(define-public (mock-add-burnchain-block-header-hash (burn-height uint) (hash (buff 32)))
 (ok (map-set mock-burnchain-header-hashes burn-height hash)))

(define-read-only (get-bc-h-hash (bh uint))
	 (if DEBUG-MODE (map-get? mock-burnchain-header-hashes bh) (get-burn-block-info? header-hash bh)))


(define-read-only (verify-block-header (headerbuff (buff 80)) (expected-block-height uint))
	(match (get-bc-h-hash expected-block-height)
			bhh (is-eq bhh (reverse-buff32 (sha256 (sha256 headerbuff))))
			false))

(define-read-only (get-reversed-txid (tx (buff 4096)))
		(sha256 (sha256 tx)))

(define-read-only (get-txid (tx (buff 4096)))
		(reverse-buff32 (sha256 (sha256 tx))))

(define-read-only (is-bit-set (val uint) (bit uint))
	(> (bit-and val (bit-shift-left u1 bit)) u0))

(define-private (inner-merkle-proof-verify (ctr uint) (state { path: uint, root-hash: (buff 32), proof-hashes: (list 14 (buff 32)), tree-depth: uint, cur-hash: (buff 32), verified: bool}))
  (let ((path (get path state))
        (is-left (is-bit-set path ctr))
        (proof-hashes (get proof-hashes state))
        (cur-hash (get cur-hash state))
        (root-hash (get root-hash state))

        (h1 (if is-left (unwrap-panic (element-at proof-hashes ctr)) cur-hash))
        (h2 (if is-left cur-hash (unwrap-panic (element-at proof-hashes ctr))))
        (next-hash (sha256 (sha256 (concat h1 h2))))
        (is-verified (and (is-eq (+ u1 ctr) (len proof-hashes)) (is-eq next-hash root-hash))))
    (merge state { cur-hash: next-hash, verified: is-verified})))

(define-read-only (verify-merkle-proof (reversed-txid (buff 32)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(if (> (get tree-depth proof) (len (get hashes proof)))
				(err ERR-PROOF-TOO-SHORT)
				(ok
					(get verified
							(fold inner-merkle-proof-verify
									(unwrap-panic (slice? (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13) u0 (get tree-depth proof)))
									{ path: (+ (pow u2 (get tree-depth proof)) (get tx-index proof)), root-hash: merkle-root, proof-hashes: (get hashes proof), cur-hash: reversed-txid, tree-depth: (get tree-depth proof), verified: false})))))


(define-read-only (get-commitment-scriptPubKey (outs (list 8 { value: uint, scriptPubKey: (buff 128) })))
	(fold inner-get-commitment-scriptPubKey outs 0x))

(define-read-only (inner-get-commitment-scriptPubKey (out { value: uint, scriptPubKey: (buff 128) }) (result (buff 128)))
	(let ((commitment (get scriptPubKey out)))
		(if (is-commitment-pattern commitment) commitment result)))

(define-read-only (is-commitment-pattern (scriptPubKey (buff 128)))
	(asserts! (is-eq (unwrap! (slice? scriptPubKey u0 u6) false) 0x6a24aa21a9ed) false))



(define-read-only (was-tx-mined-compact (height uint) (tx (buff 4096))
	(header (buff 80))
	(proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(let ((block (unwrap! (parse-block-header header) (err ERR-BAD-HEADER))))
			(was-tx-mined-internal height tx header (get merkle-root block) proof)))

(define-private (was-tx-mined-internal (height uint) (tx (buff 4096)) (header (buff 80)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
	(if (verify-block-header header height)
		(let ((reversed-txid (get-reversed-txid tx))
					(txid (reverse-buff32 reversed-txid)))
			(asserts!
				(or
					(try! (verify-merkle-proof reversed-txid (reverse-buff32 merkle-root) proof)))
				(err ERR-INVALID-MERKLE-PROOF))
			(ok txid))
		(err ERR-HEADER-HEIGHT-MISMATCH)))


(define-read-only (was-segwit-tx-mined-compact
	(height uint)
	(wtx (buff 4096))
	(header (buff 80))
	(tx-index uint)
	(tree-depth uint)
	(wproof (list 14 (buff 32)))
	(witness-merkle-root (buff 32))
	(witness-reserved-value (buff 32))
	(ctx (buff 1024))
	(cproof (list 14 (buff 32))))
	(begin
		(try! (was-tx-mined-compact height ctx header { tx-index: u0, hashes: cproof, tree-depth: tree-depth }))
		(let (
			(witness-out (get-commitment-scriptPubKey (get outs (try! (parse-tx ctx)))))
			(final-hash (sha256 (sha256 (concat witness-merkle-root witness-reserved-value))))
			(reversed-wtxid (get-reversed-txid wtx))
			(wtxid (reverse-buff32 reversed-wtxid))
		)
			(asserts! (is-eq witness-out (concat 0x6a24aa21a9ed final-hash)) (err ERR-INVALID-COMMITMENT))
			(asserts! (try! (verify-merkle-proof reversed-wtxid witness-merkle-root
													{ tx-index: tx-index, hashes: wproof, tree-depth: tree-depth })) (err ERR-WITNESS-TX-NOT-IN-COMMITMENT))
			(ok wtxid))))"
"Develop a Clarity smart contract for an NFT collection. This contract must define NFTs, manage their IDs, handle token ownership, and allow minting and transfers. The contract should include error codes for unauthorized actions and unsupported operations. It must also integrate a base URI for token metadata and validate Bitcoin transaction mining status using an external library call. The minting function should increment the token ID, verify the contract owner, confirm a mined Bitcoin transaction, and mint to a specified recipient. The transfer function should ensure only the token owner can initiate transfers.","I need to design a Clarity smart contract to manage an NFT collection. This will involve defining NFTs, managing their IDs, handling ownership, providing minting and transfer functionalities, and using an external library. 

First, I'll implement the NFT trait for standard interfaces. Next I'll define error constants for different failure scenarios, such as unauthorized access, token ownership problems during transfers, and potentially Bitcoin transaction verification failures.

Then, for state management, I'll define variables to store: the NFT definition itself, the last used token ID, and a base URI for token metadata. The base URI will be used to generate unique URIs for each token using the token ID.

For the core functionality, I'll design public functions. The mint function will increment the token ID, verify the contract owner, validate a Bitcoin transaction (using an external library), and mint the token. This suggests the minting might be somehow linked to Bitcoin transactions.

Then implement the transfer function so that only the token owner can initiate transfers. This involves verifying ownership.

I should include read-only functions to query information about the NFTs, such as getting the token URI or checking the owner of a specific token ID.

Since Bitcoin transaction verification is required, I need to integrate that external library, showing that minting is likely related to Bitcoin blockchain events.

The mint function will be complex, including incrementing the token ID, ownership check, Bitcoin transaction validation, and then executing the mint.

Robust error handling is essential. Each function must validate preconditions and return error constants for failures.

The transfer function must verify the sender is the owner.

Return values should indicate success or error, and each function needs to handle both. 

Following these steps, I can create a secure and comprehensive NFT contract that meets all the requirements for NFT definition, token ID management, ownership handling, Bitcoin-based minting, and secure transfers, with appropriate error handling.",";;title: btc-tx-enabled-nft
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))
(define-constant err-not-found (err u102))
(define-constant err-unsupported-tx (err u103))
(define-constant err-out-not-found (err u104))
(define-constant err-in-not-found (err u105))
(define-constant err-tx-not-mined (err u106))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-non-fungible-token Your-NFT-Name uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
    (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
    (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
    (ok (nft-get-owner? Your-NFT-Name token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
    (begin
        (asserts! (is-eq tx-sender sender) err-not-token-owner)
        (nft-transfer? Your-NFT-Name token-id sender recipient)
    )
)

(define-public (mint (recipient principal) (height uint) (tx (buff 1024)) (header (buff 80)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
    (let
        (
            (token-id (+ (var-get last-token-id) u1))
            (tx-was-mined (contract-call? 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.clarity-bitcoin-lib-v5 was-tx-mined-compact height tx header proof))
        )
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (asserts! (is-ok tx-was-mined) err-tx-not-mined)
        (try! (nft-mint? Your-NFT-Name token-id recipient))
        (var-set last-token-id token-id)
        (ok token-id)
    )
)"
"Create a Clarity smart contract representing a SIP-010 compliant fungible token, called 'count-token', with specific functions, constants, and error conditions that includes token management, metadata (e.g., URI, name, symbol, decimals), and functions for balance checking, total supply retrieval, and token transfers that comply with the existing SIP-010 standard.","I'll break down the creation of the 'count-token' Clarity contract step-by-step. My initial understanding is that I'm creating a SIP-010 compliant token, similar to an ERC-20 on Ethereum. 

First, I must adhere to the SIP-010 standard which specifies the interfaces needed. This is done using the impl-trait declaration and referencing the standard trait. I'll look to import the SIP-010 trait using the appropriate identifier, e.g., 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait'.

Now, I need to give structure to the token. The contract needs to define a fungible token named 'count-token' using `define-fungible-token`.

Error codes are explicitly requested so I'll create two error constants which should be used when permission failures are encountered: ERR_OWNER_ONLY and ERR_NOT_TOKEN_OWNER.

The contract owner should be automatically determined during deployment. The sender of the transaction deploying the smart contract will be set as the owner using the transaction sender (`tx-sender`). This owner value will then be used later for permission checks.

Metadata is vital. The contract needs to include a mutable token URI for the token. I'll use `define-data-var` to create an optional string variable named TOKEN-URI that can be updated. I'll also initialize it with placeholder data.

Token properties, like name, symbol and decimals are needed too. These should each be constants within the contract named: TOKEN_NAME, TOKEN_SYMBOL, and TOKEN_DECIMALS. These constants will store the token metadata.

Read-only functions are crucial for querying the token's state. I'll implement `get-balance` to return a token balance. There will be a `get-total-supply` function to see the token's total circulation. Each token can have its own distinct name, symbol, decimals and URI. I'll create the corresponding `get-name`, `get-symbol`, `get-decimals`, and `get-token-uri` read-only functions to facilitate this.

Public functions for token management are crucial. The contract must have a function to update Token URI, which can only be called by the owner. There is a function `set-token-uri` that checks if the caller is contract owner before updating the mutable TOKEN-URI variable. The contract will also have functions to mint tokens. The contract will need to have function `mint` that mints a fixed amount of tokens to the transaction sender. There will be a function for burning tokens. This `burn` function will have the ability to burn STX (Stacks token) if the user doesn't have tokens to burn. The contract must also have a function for transferring tokens. The `transfer` function must include an optional memo field and adhere to the security requirements of a SIP-010 contract. I'll implement a public transfer function that moves tokens while including ownership checks and also use the memo parameter.

In summary, I'll create the SIP-010 compliant 'count-token' Clarity smart contract with read, write, minting and burning features, including required metadata.",";;title:count-token
(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-fungible-token count-token)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))

(define-constant CONTRACT_OWNER tx-sender)
(define-data-var TOKEN-URI (optional (string-utf8 256)) (some u""https://ustnpmyvsbtbyjiqiwge.supabase.co/storage/v1/object/public/Count%20Token%20Metadata/count-token-metadata.json""))
(define-constant TOKEN_NAME ""Count Token"")
(define-constant TOKEN_SYMBOL ""COUNT"")


(define-read-only (get-balance (who principal))
  (ok (ft-get-balance count-token who))
)

(define-read-only (get-total-supply)
  (ok (ft-get-supply count-token))
)

(define-read-only (get-name)
  (ok TOKEN_NAME)
)

(define-read-only (get-symbol)
  (ok TOKEN_SYMBOL)
)

(define-read-only (get-decimals)
  (ok TOKEN_DECIMALS)
)

(define-read-only (get-token-uri)
  (ok (var-get TOKEN-URI))
)

(define-public (set-token-uri (value (string-utf8 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) (err ERR_OWNER_ONLY))
        (var-set TOKEN-URI (some value))
        (ok (print {
              notification: ""token-metadata-update"",
              payload: {
                contract-id: (as-contract tx-sender),
                token-class: ""ft""
              }
            })
        )
    )
)

(define-public (mint)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (ft-mint? count-token u1000000 tx-sender)
  )
)

(define-public (burn)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (if (> (unwrap-panic (get-balance tx-sender)) u0)
      (ft-burn? count-token u1000000 tx-sender)
      (stx-burn? u1000000 tx-sender)
    )
  )
)

(define-public (transfer
  (amount uint)
  (sender principal)
  (recipient principal)
  (memo (optional (buff 34)))
)
  (begin
    (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) ERR_NOT_TOKEN_OWNER)
    (try! (ft-transfer? count-token amount sender recipient))
    (match memo to-print (print to-print) 0x)
    (ok true)
  )
)"
"Develop a Clarity smart contract for the Stacks blockchain that facilitates a payment channel system, enabling off-chain STX and SIP-010 token transactions. This system must include features for opening, closing, contesting, and finalizing channels, alongside signature validation, nonce control, and payment processing, while adhering to security and efficiency principles for Stacks.","First, understand payment channel concept and its Stacks implementation. Channels permit off-chain transactions, improving efficiency and reducing costs. The process involves opening channels with initial deposits, conducting off-chain transactions using signed messages, and settling final balances on-chain upon channel closure. The contract needs to implement channel management functions, including opening, updating, disputing, and closing, with robust security via signature verification. For state management, track channel details (participants, balances, expiration, nonce) to prevent replay attacks. Start by defining constants, error codes, and data structures. Support both STX (native) and SIP-010 tokens via a trait for token-agnostic functions. Create a deterministic channel identification method between parties, sorting principals for a consistent key. Security: require valid signatures for channel operations, implementing structured data signing (SIP-018) for replay attack prevention. Implement channel lifecycle functions: initialize contract, open/fund channels, cooperative and unilateral channel closing, handle/resolve disputes with timelocks, manage in-channel deposits/withdrawals, and potentially include an agent system. For dispute resolution, implement a challenge period for counterparty submissions to prevent fraud. Signature verification is key; channel state updates require signatures covering balances, nonce, action, and parameters. Address edge cases: unresponsive participants (force-close), invalid state transitions (validation). Payment execution: escrow and distribute funds correctly upon channel closure, carefully handling token transfers. Implement hash time-locked contracts (HTLCs) for conditional payments enabling atomic swaps. Employ nonce management, ensuring each update has a higher nonce. Use maps to store channel data. Add utility functions for readability/maintainability, separating logic from operations like signature verification. Define specific error constants for improved debugging and user experience. Security focus: prevent fund theft by verifying agreed-upon valid state updates and ensure balance consistency during updates. Implement events (Clarity print statements) for off-chain monitoring. Consider withdrawals during channel lifetime. Balance security, efficiency, and usability while including all core payment channel functionalities. The code must provide a strong basis for off-chain transactions in the Stacks ecosystem.",";; title: stackflow 
;; summary: Stackflow is a payment channel network built on Stacks, enabling
;;   off-chain, non-custodial, and high-speed payments between users. Designed
;;   to be simple, secure, and efficient, it supports transactions in STX and
;;   SIP-010 fungible tokens.
(use-trait sip-010 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)(impl-trait .stackflow-token.stackflow-token)
(define-constant contract-deployer tx-sender)
(define-constant MAX_HEIGHT u340282366920938463463374607431768211455)(define-constant structured-data-prefix 0x534950303138)
(define-constant message-domain-hash (sha256 (unwrap-panic (to-consensus-buff?
        {
                name: ""StackFlow"",
                version: ""0.5.0"",
                chain-id: chain-id
        }
))))
(define-constant structured-data-header (concat structured-data-prefix message-domain-hash))
(define-constant ACTION_CLOSE u0)
(define-constant ACTION_TRANSFER u1)
(define-constant ACTION_DEPOSIT u2)
(define-constant ACTION_WITHDRAWAL u3)
(define-constant ERR_DEPOSIT_FAILED (err u100))
(define-constant ERR_NO_SUCH_CHANNEL (err u101))
(define-constant ERR_INVALID_PRINCIPAL (err u102))
(define-constant ERR_INVALID_SENDER_SIGNATURE (err u103))
(define-constant ERR_INVALID_OTHER_SIGNATURE (err u104))
(define-constant ERR_CONSENSUS_BUFF (err u105))
(define-constant ERR_UNAUTHORIZED (err u106))
(define-constant ERR_MAX_ALLOWED (err u107))
(define-constant ERR_INVALID_TOTAL_BALANCE (err u108))
(define-constant ERR_WITHDRAWAL_FAILED (err u109))
(define-constant ERR_CHANNEL_EXPIRED (err u110))
(define-constant ERR_NONCE_TOO_LOW (err u111))
(define-constant ERR_CLOSE_IN_PROGRESS (err u112))
(define-constant ERR_NO_CLOSE_IN_PROGRESS (err u113))
(define-constant ERR_SELF_DISPUTE (err u114))
(define-constant ERR_ALREADY_FUNDED (err u115))
(define-constant ERR_INVALID_WITHDRAWAL (err u116))
(define-constant ERR_UNAPPROVED_TOKEN (err u117))
(define-constant ERR_NOT_EXPIRED (err u118))
(define-constant ERR_NOT_INITIALIZED (err u119))
(define-constant ERR_ALREADY_INITIALIZED (err u120))
(define-constant ERR_NOT_VALID_YET (err u121))
(define-data-var initialized bool false)
(define-data-var supported-token (optional principal) none)
(define-map
  channels
  { token: (optional principal), principal-1: principal, principal-2: principal }
  { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) }
)
(define-map agents principal principal)
;;
(define-public (init (token (optional <sip-010>)))
  (begin
    (asserts! (not (var-get initialized)) ERR_ALREADY_INITIALIZED)
    (asserts! (is-eq tx-sender contract-deployer) ERR_UNAUTHORIZED)
    (var-set supported-token (contract-of-optional token))
    (ok (var-set initialized true))
  )
)
(define-public (register-agent (agent principal))
  (ok (map-set agents tx-sender agent))
)
(define-public (deregister-agent)
  (ok (map-delete agents tx-sender))
)
(define-public (fund-channel (token (optional <sip-010>)) (amount uint) (with principal) (nonce uint))
  (begin
    (try! (check-token token))

    (let
      (
        (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
        (existing-channel (map-get? channels channel-key))
        (channel
          (match
            existing-channel
            ch
            ch
            { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
          )
        )
        (updated-channel (try! (increase-sender-balance channel-key channel token amount)))
        (closer (get closer channel))
      )
      (asserts! (>= (get nonce channel) nonce) ERR_NONCE_TOO_LOW)
      (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
      (asserts! (not (is-funded tx-sender channel-key channel)) ERR_ALREADY_FUNDED)

      (map-set channels channel-key updated-channel)
      (print {
        event: ""fund-channel"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: tx-sender,
        amount: amount,
      })
      (ok channel-key)
    )
  )
)
(define-public (close-channel
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel {
        balance-1: balance-1,
        balance-2: balance-2,
        expires-at: MAX_HEIGHT,
        nonce: nonce,
        closer: none
      })
    )
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_CLOSE
        tx-sender
        none
        none
      )
    )
    (reset-channel channel-key nonce)
    (print {
      event: ""close-channel"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
    })
    (payout token tx-sender with my-balance their-balance)
  )
)
(define-public (force-cancel (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (+ burn-block-height WAITING_PERIOD))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (map-set
      channels
      channel-key
      (merge channel { expires-at: expires-at, closer: (some tx-sender) })
    )
    (print {
      event: ""force-cancel"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (ok expires-at)
  )
)
(define-public (force-close
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (expires-at (+ burn-block-height WAITING_PERIOD))
        (principal-1 (get principal-1 channel-key))
        (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
        (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
        (new-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: expires-at,
          closer: (some tx-sender),
          nonce: nonce
        })
      )
      (try!
        (verify-signatures
          my-signature
          tx-sender
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (map-set
        channels
        channel-key
        new-channel
      )
      (print {
        event: ""force-close"",
        channel-key: channel-key,
        channel: new-channel,
        sender: tx-sender,
      })

      (ok expires-at)
    )
  )
)
(define-public (dispute-closure
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (dispute-closure-inner
    tx-sender
    token
    with
    my-balance
    their-balance
    my-signature
    their-signature
    nonce
    action
    actor
    secret
    valid-after
  )
)
(define-public (agent-dispute-closure
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (agent (unwrap! (map-get? agents for) ERR_UNAUTHORIZED))
    )
    (asserts! (is-eq tx-sender agent) ERR_UNAUTHORIZED)
    (dispute-closure-inner
      for
      token
      with
      my-balance
      their-balance
      my-signature
      their-signature
      nonce
      action
      actor
      secret
      valid-after
    )
  )
)
(define-public (finalize  (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (get expires-at channel))
    )    (asserts! (is-some closer) ERR_NO_CLOSE_IN_PROGRESS)
    (asserts! (> burn-block-height expires-at) ERR_NOT_EXPIRED)
    (reset-channel channel-key (get nonce channel))
    (print {
      event: ""finalize"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (payout
      token
      (get principal-1 channel-key)
      (get principal-2 channel-key)
      (get balance-1 channel)
      (get balance-2 channel)
    )
  )
)
(define-public (deposit
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_DEPOSIT
        tx-sender
        none
        none
      )
    )
    (try! (increase-sender-balance channel-key channel token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""deposit"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
(define-public (withdraw
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )
    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (> (+ (get balance-1 channel) (get balance-2 channel)) amount)
      ERR_INVALID_WITHDRAWAL
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (- (+ (get balance-1 channel) (get balance-2 channel)) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_WITHDRAWAL
        tx-sender
        none
        none
      )
    )
    (try! (execute-withdraw token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""withdraw"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
;;
(define-read-only (get-channel (token (optional principal)) (with principal))
  (match (get-channel-key token tx-sender with)
    channel-key (map-get? channels channel-key)
    e none
  )
)
(define-read-only (make-structured-data-hash
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (structured-data (merge
        channel-key
        {
          balance-1: balance-1,
          balance-2: balance-2,
          nonce: nonce,
          action: action,
          actor: actor,
          hashed-secret: hashed-secret,
          valid-after: valid-after,
        }
      ))
      (data-hash (sha256 (unwrap! (to-consensus-buff? structured-data) ERR_CONSENSUS_BUFF)))
    )
    (ok (sha256 (concat structured-data-header data-hash)))
  )
)
(define-read-only (verify-signature
    (signature (buff 65))
    (signer principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let ((hash (unwrap! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ) false)))
    (verify-hash-signature hash signature signer actor)
  )
)
(define-read-only (verify-signatures
    (signature-1 (buff 65))
    (signer-1 principal)
    (signature-2 (buff 65))
    (signer-2 principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let (
    (hashed-secret (match secret s (some (sha256 s)) none))
    (hash (try! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ))))
    (asserts! (verify-hash-signature hash signature-1 signer-1 actor) ERR_INVALID_SENDER_SIGNATURE)
    (asserts! (verify-hash-signature hash signature-2 signer-2 actor) ERR_INVALID_OTHER_SIGNATURE)
    (ok true)
  )
)
;;
(define-private (contract-of-optional (trait (optional <sip-010>)))
  (match trait
    t
    (some (contract-of t))
    none
  )
)
(define-private (get-channel-key (token (optional principal)) (principal-1 principal) (principal-2 principal))
  (let
    (
      (p1 (unwrap! (to-consensus-buff? principal-1) ERR_INVALID_PRINCIPAL))
      (p2 (unwrap! (to-consensus-buff? principal-2) ERR_INVALID_PRINCIPAL))
    )
    (ok (if (< p1 p2)
      { token: token, principal-1: principal-1, principal-2: principal-2 }
      { token: token, principal-1: principal-2, principal-2: principal-1 }
    ))
  )
)
(define-private (increase-sender-balance
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
    (token (optional <sip-010>))
    (amount uint)
  )
  (begin
    (match token
      t
      (unwrap! (contract-call? t transfer amount tx-sender (as-contract tx-sender) none) ERR_DEPOSIT_FAILED)
      (unwrap! (stx-transfer? amount tx-sender (as-contract tx-sender)) ERR_DEPOSIT_FAILED)
    )
    (ok
      (if (is-eq tx-sender (get principal-1 channel-key))
        (merge channel { balance-1: (+ (get balance-1 channel) amount) })
        (merge channel { balance-2: (+ (get balance-2 channel) amount) })
      )
    )
  )
)
(define-private (execute-withdraw
    (token (optional <sip-010>))
    (amount uint)
  )
  (let ((sender tx-sender))
    (unwrap!
      (match token
        t
        (as-contract (contract-call? t transfer amount tx-sender sender none))
        (as-contract (stx-transfer? amount tx-sender sender))
      )
      ERR_WITHDRAWAL_FAILED
    )
    (ok true)
  )
)
(define-private (dispute-closure-inner
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) for with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (expires-at (get expires-at channel))
      (channel-nonce (get nonce channel))
      (closer (unwrap! (get closer channel) ERR_NO_CLOSE_IN_PROGRESS))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq for principal-1) my-balance their-balance))
      (balance-2 (if (is-eq for principal-1) their-balance my-balance))
    )
    (asserts! (not (is-eq for closer)) ERR_SELF_DISPUTE)
    (asserts! (< burn-block-height expires-at) ERR_CHANNEL_EXPIRED)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (updated-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: MAX_HEIGHT,
          nonce: nonce,
          closer: none
        })
      )
      (try!
        (verify-signatures
          my-signature
          for
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (reset-channel channel-key nonce)
      (print {
        event: ""dispute-closure"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: for,
      })
      (payout token for with my-balance their-balance)
    )
  )
)
(define-private (is-funded
    (account principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
  )
  (or
    (and (is-eq account (get principal-1 channel-key)) (> (get balance-1 channel) u0))
    (and (is-eq account (get principal-2 channel-key)) (> (get balance-2 channel) u0))
  )
)
(define-private (payout
    (token (optional <sip-010>))
    (principal-1 principal)
    (principal-2 principal)
    (balance-1 uint)
    (balance-2 uint)
  )
  (begin
    (try! (transfer token principal-1 balance-1))
    (transfer token principal-2 balance-2)
  )
)
(define-private (transfer (token (optional <sip-010>)) (addr principal) (amount uint))
  (if (is-eq amount u0)    (ok (is-some token))
    (begin
      (match token
        t (unwrap! (as-contract (contract-call? t transfer amount tx-sender addr none)) ERR_WITHDRAWAL_FAILED)
        (unwrap! (as-contract (stx-transfer? amount tx-sender addr)) ERR_WITHDRAWAL_FAILED)
      )
      (ok (is-some token))
    )
  )
)
(define-private (reset-channel
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (nonce uint)
  )
  (map-set
    channels
    channel-key
    { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
  )
)
(define-private (verify-hash-signature
    (hash (buff 32))
    (signature (buff 65))
    (signer principal)
    (actor principal)
  )
  (or
    (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok signer))    (and
      (not (is-eq signer actor))
      (match (map-get? agents signer)
        agent (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok agent))
        false
      )
    )
  )
)
(define-private (check-token (token (optional <sip-010>)))
  (begin    (asserts! (var-get initialized) ERR_NOT_INITIALIZED)
    (asserts! (is-eq (contract-of-optional token) (var-get supported-token)) ERR_UNAPPROVED_TOKEN)

    (ok true)
  )
)"
"Develop a Clarity smart contract defining a subnet system, outlining functionalities to govern miners, register both fungible and non-fungible tokens, commit blocks accompanied by withdrawal roots, and manage STX, fungible, and non-fungible token deposits and withdrawals. This must incorporate Merkle proof validation, and facilitate either secure transfers or minting of assets, all based on the model and method within the given code snippet.","First, I will clarify the concept of a subnet system in the context of blockchain, a secondary blockchain network working alongside a main chain for optimized transaction processing and scalability. The contract must manage asset transfers between the main chain (L1) and the subnet (L2).
I will define error constants for providing meaningful feedback in the event of operation failures, including block commits, invalid miners, transfer failures, and validation problems, to facilitate debugging and enhance user experience.
Essential data structures need to be established. I will set up maps to track committed blocks, withdrawal roots, and processed withdrawals, which are critical to maintain the subnet's state and prevent double-spending. A variable will track an authorized miner to commit blocks and register contracts.
I require traits to interact with different token standards, including NFTs, fungible tokens, and a custom trait for minting tokens from the subnet. This will allow the contract to interact with various token contracts in a standardized way to ensure contract interoperability.
The miner management function is critical for security, therefore, I will implement a function to update the miner, but only the existing miner can set a new one.
I will implement functions to register both fungible and non-fungible token contracts, specifically to map L1 contracts with their L2 counterparts. The registration function execution will only be permitted by the authorized miner.
I need to implement block commitment functionality, which is how the subnet's state is linked to the main chain. Each block commitment should include a withdrawal root, which is a Merkle root of all withdrawals in that block. This needs to validate that the block hasn't been committed before and the miner is authorized.
Moving on to asset management: I will first handle NFT deposits and withdrawals. For deposits, users transfer their NFTs to the contract, which records the event. For withdrawals, the contract validates a Merkle proof, and then transfers the NFT. I will also implement minting for when an NFT was created on the subnet.
The fungible token logic is similar but with amount considerations, handling deposits and withdrawals. The contract might need to mint tokens if it doesn't have enough balance when doing so. 
The STX token (native token) requires distinct functions, implementing dedicated functions for STX deposits and withdrawals with similar validation logic, but using the built-in stx-transfer? function instead of contract calls.
Implementing the Merkle proof validation, which is critical to prove a withdrawal was included in a committed block. I'll need functions that can hash withdrawal data consistently, verify the Merkle path, and track processed withdrawals to prevent double-spending.
Next, create distinct formats for STX, NFT, and FT withdrawals for the leaf hashing function, to create unique identifiers.
Implement the hash verification logic that walks up the Merkle tree using sibling hashes, reconstructing the root hash to compare against the committed root.
I require a function to mark withdrawals as processed, preventing the same withdrawal from being processed multiple times.
Error handling is important. Input and state validation before any operation should be implemented, and provide specific error codes. Events for important operations will be emitted for off-chain observation.
This should satisfy all requirements for a subnet system with correct asset management with security controls.",";;title: subnet
(define-constant CONTRACT_ADDRESS (as-contract tx-sender))
(define-constant ERR_BLOCK_ALREADY_COMMITTED 1)
(define-constant ERR_INVALID_MINER 2)
(define-constant ERR_CONTRACT_CALL_FAILED 3)
(define-constant ERR_TRANSFER_FAILED 4)
(define-constant ERR_DISALLOWED_ASSET 5)
(define-constant ERR_ASSET_ALREADY_ALLOWED 6)
(define-constant ERR_MERKLE_ROOT_DOES_NOT_MATCH 7)
(define-constant ERR_INVALID_MERKLE_ROOT 8)
(define-constant ERR_WITHDRAWAL_ALREADY_PROCESSED 9)
(define-constant ERR_VALIDATION_FAILED 10)(define-constant ERR_INVALID_CHAIN_TIP 11)(define-constant ERR_CALLED_TOO_EARLY 12)
(define-constant ERR_MINT_FAILED 13)
(define-constant ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT 14)
(define-constant ERR_IN_COMPUTATION 15)(define-constant ERR_NFT_NOT_OWNED_BY_CONTRACT 16)
(define-constant ERR_VALIDATION_LEAF_FAILED 30)
(define-map block-commits uint (buff 32))(define-map withdrawal-roots-map (buff 32) bool)(define-map processed-withdrawal-leaves-map { withdrawal-leaf-hash: (buff 32), withdrawal-root-hash: (buff 32) } bool)
(define-data-var miner principal 'ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP)
(define-map allowed-contracts principal principal)
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)
(use-trait mint-from-subnet-trait .subnet-traits.mint-from-subnet-trait)
(define-public (update-miner (new-miner principal))
    (begin
        (asserts! (is-eq tx-sender (var-get miner)) (err ERR_INVALID_MINER))
        (ok (var-set miner new-miner))
    )
)
(define-public (register-new-ft-contract (ft-contract <ft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of ft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-public (register-new-nft-contract (nft-contract <nft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of nft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-private (is-miner (miner-to-check principal))
    (is-eq miner-to-check (var-get miner))
)
(define-private (can-commit-block? (commit-block-height uint)  (target-chain-tip (buff 32)))
    (begin        (asserts! (is-none (map-get? block-commits commit-block-height)) (err ERR_BLOCK_ALREADY_COMMITTED))
        (asserts! (is-eq
            target-chain-tip
            (unwrap! (get-block-info? id-header-hash (- block-height u1)) (err ERR_CALLED_TOO_EARLY)) )
            (err ERR_INVALID_CHAIN_TIP))
        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (is-miner contract-caller) (err ERR_INVALID_MINER))

        (ok true)
    )
)
(define-private (inner-commit-block (block (buff 32)) (commit-block-height uint) (withdrawal-root (buff 32)))
    (begin
        (map-set block-commits commit-block-height block)
        (map-set withdrawal-roots-map withdrawal-root true)
        (print {
            event: ""block-commit"",
            block-commit: block,
            withdrawal-root: withdrawal-root,
            block-height: commit-block-height
        })
        (ok block)
    )
)
;;(define-public (commit-block (block (buff 32)) (target-chain-tip (buff 32)) (withdrawal-root (buff 32)))
    (let ((commit-block-height block-height))
        (try! (can-commit-block? commit-block-height target-chain-tip))
        (inner-commit-block block commit-block-height withdrawal-root)
    )
)

(define-private (inner-transfer-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract transfer id sender recipient))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-nft-asset
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? nft-mint-contract mint-from-subnet id sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-nft-asset
        (nft-contract <nft-trait>)
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
            (no-owner (is-eq nft-owner none))
        )

        (if contract-owns-nft
            (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
            (if no-owner                (inner-mint-nft-asset nft-mint-contract id CONTRACT_ADDRESS recipient)                (err ERR_MINT_FAILED)
            )
        )
    )
)
(define-public (deposit-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts! (try! (inner-transfer-nft-asset nft-contract id sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print {
            event: ""deposit-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            sender: sender,
            subnet-contract-id: subnet-contract-id,
        })

        (ok true)
    )
)

(define-public (inner-withdraw-nft-asset
        (nft-contract <nft-trait>)
        (l2-contract principal)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-nft l2-contract id recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match nft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-nft-asset nft-contract mint-contract id recipient))
                    (as-contract (inner-transfer-without-mint-nft-asset nft-contract id recipient))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
            (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED)
        )

        (ok true)
    )
)
(define-public (withdraw-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let (            (l2-contract (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts!
            (try! (inner-withdraw-nft-asset
                nft-contract
                l2-contract
                id
                recipient
                withdrawal-id
                height
                nft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes
            ))
            (err ERR_TRANSFER_FAILED)
        )
        (print {
            event: ""withdraw-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            recipient: recipient
        })

        (ok true)
    )
)

(define-private (inner-transfer-without-mint-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
        )

        (asserts! contract-owns-nft (err ERR_NFT_NOT_OWNED_BY_CONTRACT))
        (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
    )
)

(define-private (inner-transfer-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract transfer amount sender recipient memo))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-ft-asset
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? ft-mint-contract mint-from-subnet amount sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-ft-asset
        (ft-contract <ft-trait>)
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract get-balance CONTRACT_ADDRESS))
            (contract-ft-balance (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-enough (>= contract-ft-balance amount))
            (amount-to-transfer (if contract-owns-enough amount contract-ft-balance))
            (amount-to-mint (- amount amount-to-transfer))
        )
        (asserts! (is-eq amount (+ amount-to-transfer amount-to-mint)) (err ERR_IN_COMPUTATION))

        (and
            (> amount-to-transfer u0)
            (try! (inner-transfer-ft-asset ft-contract amount-to-transfer CONTRACT_ADDRESS recipient memo))
        )
        (and
            (> amount-to-mint u0)
            (try! (inner-mint-ft-asset ft-mint-contract amount-to-mint CONTRACT_ADDRESS recipient))
        )

        (ok true)
    )
)
(define-public (deposit-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (memo (optional (buff 34)))
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET)))
        )        (asserts! (try! (inner-transfer-ft-asset ft-contract amount sender CONTRACT_ADDRESS memo)) (err ERR_TRANSFER_FAILED))

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""deposit-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                sender: sender,
                subnet-contract-id: subnet-contract-id,
            })
        )

        (ok true)
    )
)
(define-private (inner-withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))
        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-ft (contract-of ft-contract) amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match ft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-ft-asset ft-contract mint-contract amount recipient memo))
                    (as-contract (inner-transfer-ft-asset ft-contract amount CONTRACT_ADDRESS recipient memo))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (ok true)
    )
)
(define-public (withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (> amount u0) (err ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT))
        (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET))

        (asserts!
            (try! (inner-withdraw-ft-asset
                ft-contract
                amount
                recipient
                withdrawal-id
                height
                memo
                ft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes))
            (err ERR_TRANSFER_FAILED)
        )

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""withdraw-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                recipient: recipient,
            })
        )

        (ok true)
    )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-private (inner-transfer-stx (amount uint) (sender principal) (recipient principal))
    (let (
            (call-result (stx-transfer? amount sender recipient))
            (transfer-result (unwrap! call-result (err ERR_TRANSFER_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)
(define-public (deposit-stx (amount uint) (sender principal))
    (begin        (asserts! (try! (inner-transfer-stx amount sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print { event: ""deposit-stx"", sender: sender, amount: amount })

        (ok true)
    )
)

(define-read-only (leaf-hash-withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""stx"",
            amount: amount,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-nft
        (asset-contract principal)
        (nft-id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""nft"",
            nft-id: nft-id,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-ft
        (asset-contract principal)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""ft"",
            amount: amount,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)
(define-public (withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-stx amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts! (try! (as-contract (inner-transfer-stx amount tx-sender recipient))) (err ERR_TRANSFER_FAILED))

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))
        (print { event: ""withdraw-stx"", recipient: recipient, amount: amount })

        (ok true)
    )
)


(define-private (create-node-hash
        (curr-hash (buff 32))
        (sibling-hash (buff 32))
        (is-sibling-left-side bool)
    )
    (let (
            (concatted-hash (if is-sibling-left-side
                    (concat sibling-hash curr-hash)
                    (concat curr-hash sibling-hash)
                ))
          )

          (concat 0x01 concatted-hash)
    )
)
(define-private (hash-help
        (sibling {
            hash: (buff 32),
            is-left-side: bool,
        })
        (curr-node-hash (buff 32))
    )
    (let (
            (sibling-hash (get hash sibling))
            (is-sibling-left-side (get is-left-side sibling))
            (new-buff (create-node-hash curr-node-hash sibling-hash is-sibling-left-side))
        )
       (sha512/256 new-buff)
    )
)
(define-private (check-withdrawal-hashes
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (is-some (map-get? withdrawal-roots-map withdrawal-root)) (err ERR_INVALID_MERKLE_ROOT))
        (asserts!
            (is-none
             (map-get? processed-withdrawal-leaves-map
                       { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root }))
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (let ((calculated-withdrawal-root (fold hash-help sibling-hashes withdrawal-leaf-hash))
              (roots-match (is-eq calculated-withdrawal-root withdrawal-root)))
             (if roots-match
                (ok true)
                (err ERR_MERKLE_ROOT_DOES_NOT_MATCH))
        )
    )
)
(define-private (finish-withdraw
        (withdraw-info {
            withdrawal-leaf-hash: (buff 32),
            withdrawal-root-hash: (buff 32)
        })
    )
    (map-insert processed-withdrawal-leaves-map withdraw-info true)
)"
"Create a Clarity smart contract for a ""funny-dog"" NFT.  This contract should adhere to the nft-trait, use a uint for token IDs, and enable minting, transferring, and metadata retrieval (URI and owner). The contract *must* enforce ownership, limit the number of minted NFTs, and utilize a base URI template. Implement error handling for unauthorized actions, failed transfers, and exceeding the mint limit.","To implement the ""funny-dog"" NFT contract, I'll break down the requirements and outline the necessary code structure. First, implement the `nft-trait` interface to ensure Stacks ecosystem compatibility. Then, I need to define the NFT token, assigning unique uint IDs. I'll also need a data variable to track the latest minted token ID to ensure uniqueness. To manage permissions, I'll store the contract owner's address (e.g., the deployer's address). Error handling is crucial, so I'll define constants for various error conditions (unauthorized actions, invalid transfers, exceeding the collection limit). I need to store a base URI template for metadata retrieval. Functions will be needed to read information, like the last token ID, token URI, and owner. For token transfers, I will build a function that validates sender ownership before allowing the transfer. For minting, a function will be made that: first, verifies the minter; second, verifies the mint limit; third, mints the token; and finally, updates the counter, and then returns the new token's ID.  A collection limit will be set using a constant. The metadata function will use the base URI template.  Security considerations must be addressed, such as restricting token transfers to the owner.  The mint function must restrict privileges to the contract owner.",";;title: funny dog
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-non-fungible-token funny-dog uint)

(define-data-var last-token-id uint u0)

(define-constant CONTRACT_OWNER tx-sender)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? funny-dog token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? funny-dog token-id sender recipient)
  )
)

(define-public (mint (recipient principal))
  (let ((token-id (+ (var-get last-token-id) u1)))
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    (try! (nft-mint? funny-dog token-id recipient))

    (var-set last-token-id token-id)
    (ok token-id)
  )
)"
"Develop a Clarity smart contract for an NFT trading platform. This contract must enable users to put NFTs up for sale, revoke sale listings, and complete purchases using either STX or fungible tokens. Incorporate error management for issues like expired listings, illegal operations, and asset verification failures. Implement whitelisting for supported asset contracts, confirm the accuracy of listing specifics, and define methods for securely transferring NFTs and fungible tokens. Emphasize a solid and effective implementation without incorporating deployment or testing components.","To begin, I must identify the essential components of an NFT marketplace: listing assets, canceling listings, and facilitating purchases are key functions. Because payments must be possible with both native STX and fungible tokens, separate purchase functions are required. 

I will use the NFT and FT traits to interact with NFTs and fungible tokens, respectively. This design allows the contract to handle any compatible asset seamlessly without requiring knowledge of its inherent implementation.

Next, I'll establish a state management system for the marketplace using a map to store listings, where all necessary details will be saved. Moreover, I'll implement a unique nonce counter to identify each listing. 

To prevent fraud and increase security, I'll also implement a method for whitelisting only verified asset contracts, providing an extra layer of security for users.

Error handling will deal with situations such as expired listings, unauthorized actions, and asset mismatches by providing constants for all error codes. 

For the listing function, the contract has to confirm that the NFT asset and payment asset are whitelisted. After validation, the NFT should be moved to the contract until it is purchased or canceled. 

I should implement helper functions for transferring NFTs and FTs to make the main functions simpler and more reliable. Implementation of a cancellation feature will ensure that only the maker can cancel and that the NFT and contract match. If everything checks out, the listing is removed, and the NFT is returned to the maker.

Fulfillment requires distinct STX and FT payment methods, and both should verify that the listing exists, the caller isn't the seller, the listing hasn't expired, and asset contracts match. If a specific taker is defined, only they can purchase. Upon validation, the NFT will transfer to the buyer, and payment to the seller.

Additionally, the contract must ensure actions are performed by approved parties by only allowing the contract owner to change the whitelist or allow the maker of a listing to cancel. The contract should verify all conditions before any transfers to prevent asset loss.

I should use the as-contract function when the contract needs to transfer assets it holds so that the contract acts as sender. Finally, state-reading functions should be defined as read-only to improve gas efficiency.

Overall, the implementation has pertinent traits defining the required functionalities, data structures for listings and whitelisting, secure transfer functions, and robust error handling. The contract will list assets with optional specified takers, expiration dates, and different payment options. The operations would be secure and performed by authorized parties.",";;title: nft-marketplace
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
  (default-to true (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    (var-set listing-nonce (+ listing-id u1))
    (ok listing-id)
  )
)

(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    (map-delete listings listing-id)
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)

(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)"
"Create a Clarity smart contract for a 'tiny-market' decentralized marketplace. It should allow users to trade NFT assets by listing, canceling, and fulfilling trades, including features like whitelisting, listing management, expiration checks, price validation, and payment asset restrictions. The contract must handle STX or FT payments, enforce permissions, and validate assets and payments. Utilize traits for NFT/FT standards, include error handling, and provide helper functions for asset transfers.","The core is building a smart contract enabling decentralized NFT trade through listing, canceling, and trade fulfillment while supporting STX/FT payments and ensuring security via validation and error handling. This means incorporating expiration checks, price validation, and contract whitelisting for both NFTs and payment assets. 

Traits for NFTs and FTs are required to ensure compatibility with Clarity's standards. Using the `use-trait` function will let our contract interact with external implementations while enforcing required transfer functions. Then, we'll establish a contract owner for administrative functions like asset contract whitelisting.

Listings are central to the marketplace, stored in a `listings` map where each is keyed by an integer. Each listing must store maker, taker, token ID, NFT contract address, expiry timestamp, price, and, an optional payment asset contract. We should keep a `listing-nonce` variable to uniquely identify each listing. We'll also have a `whitelisted-asset-contracts` map to prevent trading of unauthorized assets.

We then need `is-whitelisted`, a read-only function to determine the asset's approval status, and `set-whitelisted` for the contract owner to modify the whitelist. We need helper functions - `transfer-nft` and `transfer-ft` - to delegate transfer logic, ensuring security and compatibility. 

`list-asset` will allow NFT listing. Checks include: NFT contract whitelisting; expiry in the future; price greater than zero; and that any specified payment asset is whitelisted. The NFT is transferred to the contract's custody before storing the listing details and incrementing `listing-nonce`.

`get-listing` is read-only, retrieving listing details. The `cancel-listing` function lets the maker remove a listing. Verification includes listing existence, maker verification, and matching NFT contract. Then, the listing is deleted and the NFT returned. 

We must validate to prevent unauthorized transactions. The `assert-can-fulfil` function verifies that the buyer isn't the maker, the taker (if specified) matches the caller, the listing hasn't expired, and the correct contracts are used. This centralizes the validation logic in the fulfillment functions.

Finally, `fulfil-listing-stx` and `fulfil-listing-ft` implement the fulfillment logic. The functions retrieve the listing, validate conditions, transfer the NFT, transfer payment, and remove the listing. The use of `try!` ensures that if a step fails, everything is reverted, preventing issues.

This contract facilitates safe and flexible NFT trading via state management, proper whitelisting, and secure asset transfer, preventing fraud and errors via robust validation.",";; title:tiny-market
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant err-expiry-in-past (err u1000))
(define-constant err-price-zero (err u1001))

;; cancelling and fulfiling errors
(define-constant err-unknown-listing (err u2000))
(define-constant err-unauthorised (err u2001))
(define-constant err-listing-expired (err u2002))
(define-constant err-nft-asset-mismatch (err u2003))
(define-constant err-payment-asset-mismatch (err u2004))
(define-constant err-maker-taker-equal (err u2005))
(define-constant err-unintended-taker (err u2006))
(define-constant err-asset-contract-not-whitelisted (err u2007))
(define-constant err-payment-contract-not-whitelisted (err u2008))

(define-map listings
	uint
	{
		maker: principal,
		taker: (optional principal),
		token-id: uint,
		nft-asset-contract: principal,
		expiry: uint,
		price: uint,
		payment-asset-contract: (optional principal)
	}
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
	(default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
	(begin
		(asserts! (is-eq contract-owner tx-sender) err-unauthorised)
		(ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
	)
)

(define-private (transfer-nft (token-contract <nft-trait>) (token-id uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft (token-contract <ft-trait>) (amount uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset (nft-asset-contract <nft-trait>) (nft-asset {taker: (optional principal), token-id: uint, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(let ((listing-id (var-get listing-nonce)))
		(asserts! (is-whitelisted (contract-of nft-asset-contract)) err-asset-contract-not-whitelisted)
		(asserts! (> (get expiry nft-asset) block-height) err-expiry-in-past)
		(asserts! (> (get price nft-asset) u0) err-price-zero)
		(asserts! (match (get payment-asset-contract nft-asset) payment-asset (is-whitelisted payment-asset) true) err-payment-contract-not-whitelisted)
		(try! (transfer-nft nft-asset-contract (get token-id nft-asset) tx-sender (as-contract tx-sender)))
		(map-set listings listing-id (merge {maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract)} nft-asset))
		(var-set listing-nonce (+ listing-id u1))
		(ok listing-id)
	)
)

(define-read-only (get-listing (listing-id uint))
	(map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(maker (get maker listing))
		)
		(asserts! (is-eq maker tx-sender) err-unauthorised)
		(asserts! (is-eq (get nft-asset-contract listing) (contract-of nft-asset-contract)) err-nft-asset-mismatch)
		(map-delete listings listing-id)
		(as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
	)
)

(define-private (assert-can-fulfil (nft-asset-contract principal) (payment-asset-contract (optional principal)) (listing {maker: principal, taker: (optional principal), token-id: uint, nft-asset-contract: principal, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(begin
		(asserts! (not (is-eq (get maker listing) tx-sender)) err-maker-taker-equal)
		(asserts! (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true) err-unintended-taker)
		(asserts! (< block-height (get expiry listing)) err-listing-expired)
		(asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) err-nft-asset-mismatch)
		(asserts! (is-eq (get payment-asset-contract listing) payment-asset-contract) err-payment-asset-mismatch)
		(ok true)
	)
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (stx-transfer? (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)

(define-public (fulfil-listing-ft (listing-id uint) (nft-asset-contract <nft-trait>) (payment-asset-contract <ft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) (some (contract-of payment-asset-contract)) listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)"
