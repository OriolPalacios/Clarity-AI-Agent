Question,CoT,Response
"Create a Clarity smart contract on Stacks that retrieves real-time price data for a specific asset (e.g., BTC/USD) from the Pyth Network using the Stacks-Pyth Bridge. Include deployment and testing instructions.","Okay, the user wants me to create a Clarity smart contract that retrieves real-time BTC/USD price data from the Pyth Network using the Stacks-Pyth Bridge. To begin, let’s recall the necessary integration steps between the Pyth Network and Stacks. The Stacks-Pyth Bridge likely involves certain traits and contracts, such as the pyth-storage-trait and pyth-decoder-trait, to ensure proper interaction with the Pyth Oracle and the retrieval of price data.

First, I’ll need to define key constants for the contract addresses—specifically, the Pyth Oracle contract and the storage contract. These constants will also include the 32-byte BTC/USD feed ID in hex, which is crucial for querying the price data. From earlier examples, it’s clear that using define-constant for these addresses and the feed ID is essential.

The main function will call the Pyth Oracle contract's get-price method, passing in the feed ID and the storage contract address as parameters. It’s important to ensure that the storage contract is passed correctly—perhaps by using as-contract to change the caller context if needed, as seen in previous examples where the storage contract address was passed with as-contract PYTH-STORAGE. This step is crucial because the storage contract may require the correct context to properly retrieve the price data.

Error handling is also key. Previous examples used try! and unwrap! to manage errors such as invalid storage addresses or stale data, and it’s important to decide whether a read-only function will suffice for this task. Since the user’s task is to ""retrieve real-time price data,"" a read-only function might be appropriate, but it depends on the implementation of the Oracle’s get-price function. If the get-price function requires state changes, a public function may be necessary. The user’s earlier code example used define-public for a public function, so it’s likely the best approach here.

Additionally, given the complexity of the task and the need for clear error handling, it’s important to decide whether the function should handle errors internally (using try!) or simply return the result of the contract call directly. A read-only function might just return the price, but if it’s a public function, it might return a response type (such as ok price or an error), requiring error propagation.

Given that the code must integrate the pyth-storage-trait to interact with the storage contract, the final code will use this trait along with the necessary constants for the oracle and storage contracts. The main function should be define-public, call the Oracle’s get-price, and handle any potential errors gracefully. If the storage contract requires specific handling via as-contract, this should be included to ensure proper context when interacting with the storage contract.

Lastly, thorough inline documentation will be included to explain each step and ensure that new developers can follow the logic. This includes details on the usage of the pyth-governance-v2 for governance checks, the rationale behind as-contract usage, and how the function handles different response types from the Oracle.

By modularizing the code with distinct responsibilities, such as governance verification, price retrieval, and error handling, I can facilitate easier testing with tools like Clarinet and ensure long-term maintainability. This structured approach will create a robust, clear blueprint for retrieving real-time BTC/USD price data from the Pyth Network.

",";; Pyth Oracle integration for BTC/USD price feed
(use-trait pyth-storage-trait 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q.pyth-traits-v1.storage-trait)

(define-constant PYTH-ORACLE 'SP3Z6MY8HT7D7KJE0D1BZ4YF40S7RMM9Y8G1B9P5G)
(define-constant PYTH-STORAGE 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q)
(define-constant BTC-USD-FEED-ID 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43)

(define-read-only (get-btc-price)
  (match (contract-call? 
          PYTH-ORACLE 
          get-price 
          BTC-USD-FEED-ID 
          (as-contract PYTH-STORAGE)
         )
    price (ok price)
    err (err err)
  )
)

(define-public (update-btc-price (price-feed-bytes (buff 8192)))
  (begin
    (contract-call? 
      PYTH-ORACLE 
      verify-and-update-price-feeds 
      price-feed-bytes 
      {
        pyth-storage-contract: PYTH-STORAGE,
        pyth-decoder-contract: 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR,
        wormhole-core-contract: 'SP3HXJJMJQ06GNAZ8XWDN1QM48JEDC6PP6W3YZPZJ
      }
    )
  )
)"
"Create a simple Clarity smart contract for a token called 'MyToken' (symbol: MTK) with 8 decimal places. Start with 21,000,000,000 tokens: give 200 to address ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M and 100 to ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9. Let users send tokens, approve others to spend their tokens, check balances, and view total supply. Include a way to revoke spending permissions and add this metadata link: ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc.","Okay, the user wants a Clarity contract for a token named MyToken (symbol MTK) with 8 decimals, starting at 21 billion tokens, and initial allocations to two addresses. I begin by noting that the contract must implement standard fungible token functionality. To do this, I should define the fungible token using Clarity’s define-fungible-token, and set the total supply via a data variable to track the aggregate tokens in existence.

Wait, I need a map to track allowances between owners and spenders, ensuring that the transfer function checks allowances before executing a token transfer. I plan to implement private helper functions like allowance, increase-allowance, and decrease-allowance to manage these permissions. The approve function will call increase-allowance, and revoke will zero out the allowance, ensuring that users can control who is allowed to spend their tokens on their behalf.

Hmm, the transfer-from function must decrement the allowance after the transfer is executed, ensuring proper validation of the allowance before proceeding. Then, I’ll expose public functions like get-balance and get-total-supply using standard Clarity functions to interact with users. I might also include metadata functions that return the token's name, symbol, decimal places, and a URI stored on IPFS, which should be simple string returns.

I should also create a mint function that adjusts the total supply and initializes the token balances for the specified addresses, such as giving 200 tokens to one address and 100 to another during initialization. Error handling is key—so I need to ensure checks for non-negative amounts, valid allowances, and proper map updates for all transactions.

Maybe I’ll structure the contract with private internals for security, and public endpoints for user interactions, such as transferring tokens, approving and revoking spenders, and checking balances. This modular approach not only fulfills the functional requirements but also supports maintainability and ease of testing.

So, with clear inline documentation to explain each step—like why certain operations require wrapping storage logic or handling state changes in a particular order—this contract will be a robust, secure, and effective Clarity smart contract for MyToken.

"," 
(define-fungible-token fungible-token)

;; Storage
(define-map allowances
  ((spender principal) (owner principal))
  ((allowance uint)))
(define-data-var total-supply uint u21000000000)

;; Internals

;; Total number of tokens in existence.
(define-private (get-total-supply)
  (var-get total-supply))

;; Gets the amount of tokens that an owner allowed to a spender.
(define-private (allowance (spender principal) (owner principal))
  (let ((allowance-val (default-to u0 (map-get? allowances (tuple (spender owner))))))
    allowance-val
  )
)


;; Transfers tokens to a specified principal.
(define-private (transfer (amount uint) (sender principal) (recipient principal) )
  (match (ft-transfer? fungible-token amount sender recipient)
    result (ok true)
    error (err false))
)

;; Decrease allowance of a specified spender.
(define-private (decrease-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (or (> amount allowance-val) (<= amount u0))
      true
      (begin
        (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (- allowance-val amount))))
        true)))
        )
        
;; Internal - Increase allowance of a specified spender.
(define-private (increase-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (<= amount u0)
      false
      (begin
         (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (+ allowance-val amount))))
        true))))

;; Public functions

;; Transfers tokens to a specified principal.
(define-public (transfer-token (amount uint) (recipient principal) )
  (transfer amount tx-sender recipient)
)

;; Transfers tokens to a specified principal, performed by a spender
(define-public (transfer-from (amount uint) (owner principal) (recipient principal) )
  (let ((allowance (allowance tx-sender owner)))
    (begin
      (if (or (> amount allowance-val) (<= amount u0))
        (err false)
        (if (and
            (unwrap! (transfer amount owner recipient) (err false))
            (decrease-allowance amount tx-sender owner))
        (ok true)
        (err false)))))
)

;; Update the allowance for a given spender
(define-public (approve (amount uint) (spender principal) )
  (if (and (> amount u0)
           (print (increase-allowance amount spender tx-sender )))
      (ok amount)
      (err false)))

;; Revoke a given spender
(define-public (revoke (spender principal))
  (let ((allowance-val (allowance spender tx-sender)))
    (if (and (> allowance-val u0)
             (decrease-allowance allowance-val spender tx-sender))
        (ok 0)
        (err false))))

;; Retrieve the human-readable name of the token
(define-public (get-name)
  ""MyToken""
)

;; Retrieve the ticker symbol of the token
(define-public (get-symbol)
  ""MTK""
)

;; Retrieve the number of decimals used
(define-public (get-decimals)
  8 ;; Assuming 8 decimals
)

;; Retrieve the balance of a specific principal
(define-public (get-balance (owner principal))
  (ft-get-balance fungible-token owner)
)

;; Retrieve the current total supply
(define-public (get-total-supply)
  (var-get total-supply)
)

;; Retrieve an example URI that represents metadata of this token
(define-public (get-token-uri)
  ""ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc""
)

;; Mint new tokens.
(define-private (mint (amount uint) (account principal))
  (if (<= amount u0)
      (err false)
      (begin
        (var-set total-supply (+ (var-get total-supply) amount))
        (ft-mint? fungible-token amount account)
        (ok amount))))

;; Initialize the contract
(begin
  (mint u200 'ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M)
  (mint u100 'ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9))"
"Create a Clarity smart contract for the PoX (Proof of Transfer X) protocol on Stacks that enables users to lock STX tokens for reward cycles, delegate stacking authority to others, and vote to reject PoX. Include functions to lock tokens for specified periods, track locked amounts via maps, validate PoX address formats (Bitcoin versions), enforce stacking thresholds (25% and 100% of liquid supply), manage delegation permissions with expiration heights, and handle reward cycle calculations. Use storage maps for stacking state, reward cycles, and delegation records, and include constants for reward cycle lengths (prepare: 100 blocks, reward: 2100 blocks), minimum/maximum lock periods (1-12 cycles), and address version validations. Ensure functions like stack-stx, delegate-stx, reject-pox, and getters for balance/lock details, while adhering to PoX’s unlock mechanics and node-synchronized reward set tracking","Okay, the user wants a Clarity contract for PoX on Stacks. Let me start by recalling the requirements. They need functions to lock STX, delegate stacking, and vote to reject PoX. The contract should have storage maps for tracking stacking state, reward cycles, and delegation. Constants like reward cycle lengths (100 prepare, 2100 reward blocks) and lock periods (1-12 cycles) are necessary. Also, address validation for Bitcoin formats and stacking thresholds (25% and 100% of liquid supply).

First, I'll define the constants. MIN and MAX reward cycles, prepare and reward cycle lengths. Then Bitcoin address versions like P2PKH and P2SH. Next, the stacking thresholds as fractions of the liquid supply.

For storage, I need maps like stacking-state to track each user's locked STX, reward cycles, and delegation. The stacking-state map will have the principal as the key and details like PoX address, first reward cycle, lock period, etc. Reward-cycle-pox-address-list might track addresses and their stakes per cycle. Delegation-state could store delegation permissions and expiration heights.

Public functions: stack-stx to lock STX, delegate-stx to allow others to act on behalf, reject-pox to vote against PoX. Getters like get-stacker-info and get-total-ustx-stacked for querying.

Need to handle PoX address validation. Functions like check-pox-addr-version and check-pox-addr-hashbytes to ensure valid Bitcoin addresses. Also, check-pox-lock-period to enforce 1-12 cycles.

Error handling is crucial. Define constants for error codes like insufficient funds or invalid lock periods. Use asserts! and try! to validate inputs and state transitions.

The unlock mechanics require calculating unlock heights based on reward cycles. Functions like reward-cycle-to-burn-height and burn-height-to-reward-cycle will convert between burnchain heights and reward cycles.

Delegation functions must check permissions and expiration. revoke-delegate-stx to remove delegation.

For stacking thresholds, get-stacking-minimum calculates 25% of liquid supply. The can-stack-stx function ensures the amount meets the threshold.

Testing the functions to ensure they update maps correctly and handle edge cases like insufficient funds or invalid addresses.

Wait, the user mentioned partial stacking and aggregation. Functions like stack-aggregation-commit and stack-aggregation-increase might be needed for partial commitments. Also, delegate-stack-extend and delegate-stack-increase for extending or increasing locks via delegation.

Need to include the replacement for stx-account since it's broken in the test environment. stx-account-from-pox-data to fetch balances using PoX data.

Finally, ensure all functions adhere to PoX's unlock rules and that the node can track reward sets correctly. The contract should maintain invariants between stacking-state and reward-cycle entries as mentioned in the provided code examples.",too large code
"Create a Clarity smart contract for a Stacks blockchain multisig wallet that allows owner management (adding/removing with threshold checks), transaction submission/confirmation/revocation, and cross-chain token swaps via a magic bridge interface. Implement SIP-009/NFT and SIP-010/FT trait integrations for asset transfers, enforce access control through allowed callers, validate transaction confirmations against owner thresholds, and include error handling for ownership conflicts, invalid parameters, and unauthorized actions. Structure the code with clear comments, data maps for transactions/owners, and helper functions for internal state updates, ensuring all critical operations are guarded by sender authentication and parameter validity checks","The code implements a multi-signature wallet (Multisafe) in Clarity for the Stacks blockchain. Wait, I need to understand the core functionality first - this is a secure wallet requiring multiple confirmations before executing transactions. Okay, the contract starts by importing several traits (interfaces) that define the behavior of executors, safes, NFTs, fungible tokens, and a ""magic bridge"" for cross-chain functionality. The contract then implements the safe-trait interface, establishing itself as a safe.
The error constants are comprehensively defined to cover various failure scenarios, from authorization issues to transaction state problems. Maybe the most important design decision is using the contract itself as a constant (SELF) to reference its own principal, which enables the contract to perform actions as itself. The contract maintains crucial state variables: a list of wallet owners (limited to 20), a confirmation threshold, and a transaction nonce. Check these variables - they're fundamental to the multi-signature functionality.
The contract offers complete owner management with functions to add and remove owners, with careful validation to maintain security. The user wants the threshold to always be valid - it must be greater than zero and less than or equal to the number of owners. The transaction management implements a robust workflow: submit → confirm → execute. Wait, there's an interesting design here - transactions are stored in a map with detailed parameters and confirmation status, and owners can submit, confirm, and revoke their confirmations.
Might be worth noting the security design - most functions verify the caller is either the contract itself or an authorized owner. The contract also has special integration with a ""magic bridge"" for cross-chain functionality, allowing owners to initialize swappers and execute escrow swaps. Maybe the most elegant aspect is the initialization function that sets up the initial owners and threshold - in this case, three specific principals with a threshold of 2 (meaning any 2 of the 3 owners must confirm a transaction). Overall, the contract creates a secure, flexible multi-signature wallet with cross-chain capabilities.",https://github.com/Trust-Machines/multisafe/blob/main/contracts/safe.clar
"Develop a Clarity smart contract for a Stacks blockchain price oracle that retrieves real-time and historical BTC/USD prices from the Pyth Network’s pyth-storage-v3 contract, using a price feed ID while handling errors with granular codes. It should support historical price queries via at-block and Stacks block header hashes, integrate with the sbtc-token contract to fetch total supply, normalize values (dividing by 10^8 for precision), and compute the total sBTC value in USD. The contract must ensure robust error handling for failed external calls, invalid data, and arithmetic overflow while maintaining a structured design with read-only functions, type-safe validation, and clear dependencies on external traits/contracts.","Okay, this contract is designed to retrieve and process BTC/USD price data from the Pyth Network while ensuring error resilience and modularity. Wait, so the first thing to notice is the error-handling strategy. By defining `ERR_UNEXPECTED` as `u5000`, the contract ensures that unexpected failures are managed predictably, preventing issues from propagating unpredictably.  

Then, for fetching the real-time BTC price, the `get-btc-price` function interacts with `pyth-storage-v3` using `contract-call?`, passing the predefined price feed ID. Maybe the most important part here is how it handles responses: if the call succeeds, the function extracts and returns the price wrapped in `some`; otherwise, it returns `none`, making sure failure cases don’t cause execution failures.  

Wait, historical price retrieval works a bit differently. The function `get-btc-price-at` first fetches the block hash using `get-stacks-block-info?`, ensuring validity with `unwrap-panic`, which guarantees the hash exists. Then, it executes the price retrieval at that block using `at-block`, following the same safe pattern of error handling as the real-time price fetcher.  

Maybe integrating with the `sbtc-token` contract is where things get interesting. The `get-sbtc-total-supply` function retrieves the total supply of sBTC tokens safely using `contract-call?`, allowing seamless interaction with the token contract. Then, the final function, `get-sbtc-total-usd-value`, ties everything together. It fetches the total sBTC supply, normalizes it by dividing by `10^8`, does the same for the BTC price, and multiplies them to compute the total USD value. Might sound simple, but the use of `unwrap!` ensures that failed calls are caught early, avoiding unexpected runtime errors.  

So, what makes this contract well-structured? Every function is read-only, ensuring state safety and reusability. Dependencies on external contracts are cleanly managed, and type safety is enforced to prevent arithmetic overflow or invalid data handling. Then, by structuring the logic around modular, composable calls, the contract remains easy to maintain while achieving robust functionality.","(define-constant ERR_UNEXPECTED (err u5000))

(define-read-only (get-btc-price)
  (match
    (contract-call?
      'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
      get-price
      0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
    )
    res (some (get price res))
    e none
  )
)

(define-read-only (get-btc-price-at (height uint))
  (let (
    (hash (unwrap-panic (get-stacks-block-info? id-header-hash height)))
  )
    (at-block hash (match
      (contract-call?
        'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
        get-price
        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
      )
      res (some (get price res))
      e none
    ))
  )
)

(define-read-only (get-sbtc-total-supply)
  (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-total-supply)
)

(define-read-only (get-sbtc-total-usd-value)
  (let (
    (sbtc-total-supply (/ (unwrap! (get-sbtc-total-supply) ERR_UNEXPECTED) u100000000))
    (btc-price (/ (to-uint (unwrap! (get-btc-price) ERR_UNEXPECTED)) u100000000))
  )
    (ok (* sbtc-total-supply btc-price))
  )
)"
"Write a Clarity smart contract that manages a counter with the following functionality: define constants for specific error codes, store a count variable, a contract owner, and a cost variable, implement read-only functions to get the current count and the count at a specific block, and create public functions to increment, decrement, and add to the counter while enforcing constraints like positive counts, limiting additions to more than one, and ensuring proper STX transfers for each operation based on the cost variable.","To begin addressing the requirements, the first step is to define constants for specific error codes. These constants serve as standardized identifiers for errors that might occur during the execution of the smart contract. For instance, ERR_COUNT_MUST_BE_POSITIVE ensures that the counter cannot drop below zero, while ERROR_ADD_MORE_THAN_ONE enforces a constraint on adding more than one to the counter at a time. Wait, there’s also ERR_BLOCK_NOT_FOUND, which handles cases where a block lookup fails. Defining these constants upfront makes the code more readable and maintainable.

Let's see, the next step involves managing state variables. The contract needs to store three key pieces of information: the current count (count), the contract owner (contract-owner), and the cost per operation (cost). Using define-data-var ensures these variables are mutable and can be updated during contract execution. The initial value for count is set to zero, contract-owner is initialized to the transaction sender (tx-sender), and cost is set to a fixed value of 10 STX. This setup allows the contract to track its state and enforce ownership and payment rules effectively.

Okay, then the focus shifts to implementing read-only functions. The get-count function retrieves the current value of the counter using var-get, providing a simple way for users to query the state without modifying it. Additionally, the get-count-at-block function uses at-block to retrieve the counter's value at a specific block height. This requires fetching the block's header hash using get-stacks-block-info?, and if the block is not found, the function returns the predefined ERR_BLOCK_NOT_FOUND. These read-only functions ensure transparency and provide historical data access.

Now, let’s consider the public functions that modify the state. The increment function increases the counter by one but requires the caller to pay the cost in STX to the contract owner. This is achieved using stx-transfer?, which ensures the payment is processed before updating the state. Similarly, the decrement function reduces the counter by one but includes a constraint to ensure the count remains positive. If the current count is zero, the function throws ERR_COUNT_MUST_BE_POSITIVE. This design prevents invalid states and aligns with the requirement for proper error handling.

Then, the add function introduces a more flexible operation, allowing the counter to increase by any value greater than one. However, this function also enforces constraints: it checks that the input n is greater than one using asserts!, throwing ERROR_ADD_MORE_THAN_ONE if the condition is violated. Additionally, the function calculates the total cost as n * cost and ensures the caller transfers the required STX amount. This approach maintains consistency with the payment model while expanding functionality.

Might be worth noting that all public functions use ok to return successful results after state modifications. This ensures that external callers receive clear feedback on the outcome of their transactions. Finally, the combination of error handling, state management, and payment enforcement creates a robust and secure smart contract that adheres to the specified requirements.",";;title: counter
(define-constant ERR_COUNT_MUST_BE_POSITIVE (err u1001))
(define-constant ERROR_ADD_MORE_THAN_ONE (err u1002))
(define-constant ERR_BLOCK_NOT_FOUND (err u1003))

(define-data-var count uint u0)
(define-data-var contract-owner principal tx-sender)
(define-data-var cost uint u10)


(define-read-only (get-count)
  (var-get count)
)

(define-read-only (get-count-at-block (block uint))
  (ok (at-block
    (unwrap! (get-stacks-block-info? id-header-hash block) ERR_BLOCK_NOT_FOUND)
    (var-get count)
  ))
)

(define-public (increment)
  (begin
    (try! (stx-transfer? (var-get cost) tx-sender (var-get contract-owner)))
    (ok (var-set count (+ (var-get count) u1)))
  )
)

(define-public (decrement)
  (let ((current-count (var-get count)))
    (asserts! (> current-count u0) ERR_COUNT_MUST_BE_POSITIVE)
    (ok (var-set count (- current-count u1)))
  )
)

(define-public (add (n uint))
  (begin
    (asserts! (> n u1) ERROR_ADD_MORE_THAN_ONE)
    (try! (stx-transfer? (* n (var-get cost)) tx-sender (var-get contract-owner)))
    (ok (var-set count (+ (var-get count) n)))
  )
)"
"I need a smart contract written in Clarity that verifies Bitcoin transactions by checking the transaction details against a merkle proof and ensuring it matches the provided block header, while also validating witness data for SegWit transactions, incorporating error handling for various edge cases and maintaining strict data length checks throughout the contract logic.","First, I need to understand what this contract needs to accomplish. We need a smart contract in Clarity that can verify Bitcoin transactions by checking transaction details against merkle proofs and block headers. It also needs to handle SegWit transactions and include comprehensive error handling. This is a complex task that requires understanding both Bitcoin's transaction format and Clarity's capabilities.
Let's start by thinking about the error codes we'll need. When dealing with cryptographic verification, there are many failure points: out-of-bounds errors when reading data buffers, size constraint violations, invalid proofs, etc. I should define constants for each error case to make the code more readable and maintainable. These will be important throughout the contract since we'll be dealing with raw transaction data that could be malformed.
Now for reading Bitcoin data. Bitcoin transactions use variable-length fields, so I'll need helper functions to parse these different data types. First, I'll need basic readers for fixed-size integers: read-uint8, read-uint16, read-uint32, and read-uint64. Each of these will take a context (txbuff and current index) and return both the parsed value and an updated context with the index advanced.
For variable-length integers (varints), I'll need a special parser. Bitcoin encodes these with a prefix byte that determines how to interpret the following bytes. If the first byte is less than 253, it's the value itself. Otherwise, the next 2, 4, or 8 bytes contain the actual value, depending on the prefix. This is crucial for correctly parsing transaction structure.
I also need to handle variable-length byte arrays (varslices) which are common in Bitcoin transactions. These start with a varint indicating the length, followed by that many bytes of data. Similarly, hash values in Bitcoin are stored in little-endian but typically used in big-endian, so I'll need conversion functions like reverse-buff32.
Now for the core transaction parsing. The parse-tx function needs to read a version, inputs, outputs, and locktime. For SegWit transactions, parse-wtx will additionally need to handle witness data. Both functions will build upon our basic readers, following Bitcoin's serialization format. I should make sure to check that we consume exactly the right amount of data to prevent malicious truncated transactions.
For block header parsing, I'll need the parse-block-header function to extract the version, parent hash, merkle root, timestamp, difficulty bits, and nonce. This will be essential for verifying that a transaction is included in a specific block.
Wait, I also need to think about merkle proof verification. A merkle proof includes a path and a set of intermediate hashes. To verify it, I need to hash pairs of nodes walking up the tree until I reach the merkle root. If the calculated root matches the expected one from the block header, the transaction is in the block. I'll implement this with a fold operation that processes each level of the tree.
For debugging and testing purposes, I might want to include a mechanism to mock blockchain data that would normally come from the underlying blockchain. This can be done with a map to store mock header hashes.
Next, I need to consider SegWit-specific verification. SegWit transactions include a commitment to witness data in a special output. I'll need functions to identify and validate this commitment. The was-segwit-tx-mined-compact function will need to verify both the transaction's inclusion in the block and the witness commitment.
Okay, let's think about the overall flow of verification. First, we verify that the provided block header matches the expected height. Then we check that the transaction's merkle proof is valid against the block's merkle root. For SegWit transactions, we additionally verify the witness commitment.
For the final API, I want functions that encapsulate all this logic in a user-friendly way. was-tx-mined-compact will handle regular transactions, while was-segwit-tx-mined-compact will handle SegWit transactions.
I should be careful about buffer size limits throughout. Clarity has strict limitations on data sizes, so I need to ensure all buffers (like scriptSig and scriptPubKey) have appropriate maximum lengths. This is reflected in the unwrap-panic and as-max-len? calls that appear frequently.
Finally, I need to think about the execution flow and error handling. Since Clarity is a non-Turing complete language, I need to ensure all operations are deterministic and all failure cases are handled properly. The try! and unwrap! operators will be used extensively to propagate errors up the call stack.
In summary, this contract needs to carefully parse Bitcoin transaction data, verify cryptographic proofs, and handle edge cases while working within Clarity's constraints. The resulting code is complex but provides a comprehensive verification mechanism for Bitcoin transactions that can be used within a Clarity-based blockchain.",";; title: stateless contract to verify bitcoin transaction

(define-constant ERR-OUT-OF-BOUNDS u1)
(define-constant ERR-TOO-MANY-TXINS u2)
(define-constant ERR-TOO-MANY-TXOUTS u3)
(define-constant ERR-VARSLICE-TOO-LONG u4)
(define-constant ERR-BAD-HEADER u5)
(define-constant ERR-HEADER-HEIGHT-MISMATCH u6)
(define-constant ERR-INVALID-MERKLE-PROOF u7)
(define-constant ERR-PROOF-TOO-SHORT u8)
(define-constant ERR-TOO-MANY-WITNESSES u9)
(define-constant ERR-INVALID-COMMITMENT u10)
(define-constant ERR-WITNESS-TX-NOT-IN-COMMITMENT u11)
(define-constant ERR-NOT-SEGWIT-TRANSACTION u12)
(define-constant ERR-LEFTOVER-DATA u13)


(define-private (bool-list-of-len (n uint))
	(unwrap-panic (slice? (list true true true true true true true true) u0 n)))

(define-read-only (read-uint8 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint8: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u1)) (err ERR-OUT-OF-BOUNDS)) u1))),
						 ctx: { txbuff: data, index: (+ u1 base)}})))

(define-read-only (read-uint16 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint16: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u2)) (err ERR-OUT-OF-BOUNDS)) u2))),
						 ctx: { txbuff: data, index: (+ u2 base)}})))

(define-read-only (read-uint32 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint32: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u4)) (err ERR-OUT-OF-BOUNDS)) u4))),
						 ctx: { txbuff: data, index: (+ u4 base)}})))

(define-read-only (read-uint64 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint64: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u8)) (err ERR-OUT-OF-BOUNDS)) u8))),
						 ctx: { txbuff: data, index: (+ u8 base)}})))

(define-read-only (read-varint (ctx { txbuff: (buff 4096), index: uint}))
		(let ((ptr (get index ctx))
					(tx (get txbuff ctx))
					(byte (buff-to-uint-le (unwrap! (element-at tx ptr)
																	(err ERR-OUT-OF-BOUNDS)))))
		 (if (<= byte u252)
				 (ok { varint: byte, ctx: { txbuff: tx, index: (+ u1 ptr)}})
				 (if (is-eq byte u253)
						 (let (
									 (parsed-u16 (try! (read-uint16 { txbuff: tx, index: (+ u1 ptr)}))))
								 (ok { varint: (get uint16 parsed-u16), ctx: (get ctx parsed-u16)}))
						 (if (is-eq byte u254)
								 (let (
											 (parsed-u32 (try! (read-uint32 { txbuff: tx, index: (+ u1 ptr)}))))
										 (ok { varint: (get uint32 parsed-u32), ctx: (get ctx parsed-u32)}))
								 (let (
											 (parsed-u64 (try! (read-uint64 { txbuff: tx, index: (+ u1 ptr)}))))
									(ok { varint: (get uint64 parsed-u64), ctx: (get ctx parsed-u64)})))))))

(define-read-only (read-varslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed (try! (read-varint old-ctx)))
					(ctx (get ctx parsed))
					(slice-start (get index ctx))
					(target-index (+ slice-start (get varint parsed)))
					(txbuff (get txbuff ctx)))
		 (ok {varslice: (unwrap! (slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-private (reverse-buff16 (input (buff 16)))
	(unwrap-panic (slice? (unwrap-panic (to-consensus-buff? (buff-to-uint-le input))) u1 u17)))

(define-read-only (reverse-buff32 (input (buff 32)))
	(unwrap-panic (as-max-len? (concat
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u16 u32)) u16)))
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u0 u16)) u16)))) u32)))

(define-read-only (read-hashslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((slice-start (get index old-ctx))
					(target-index (+ u32 slice-start))
					(txbuff (get txbuff old-ctx))
					(hash-le (unwrap-panic
											(as-max-len? (unwrap!
																			(slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)) u32))))
		 (ok {hashslice: (reverse-buff32 hash-le),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-read-only (read-next-txin (ignored bool)
																	(result (response {ctx: { txbuff: (buff 4096), index: uint },
																												remaining: uint,
																												txins: (list 8 {outpoint: {
																																									 hash: (buff 32),
																																									 index: uint},
																																				sequence: uint})}
																							uint)))
		(let ((state (unwrap! result result)))
							(let ((remaining (get remaining state))
										(ctx (get ctx state))
										(parsed-hash (try! (read-hashslice ctx)))
										(parsed-index (try! (read-uint32 (get ctx parsed-hash))))
										(parsed-scriptSig (try! (read-varslice (get ctx parsed-index))))
										(parsed-sequence (try! (read-uint32 (get ctx parsed-scriptSig))))
										(new-ctx (get ctx parsed-sequence)))
								(ok {ctx: new-ctx,
										remaining: (- remaining u1),
										txins: (unwrap!
														(as-max-len?
																(append (get txins state) {   outpoint: {
																										hash: (get hashslice parsed-hash),
																										index: (get uint32 parsed-index) },
																				scriptSig: (unwrap! (as-max-len? (get varslice parsed-scriptSig) u256) (err ERR-VARSLICE-TOO-LONG)),
																				sequence: (get uint32 parsed-sequence)}) u8)
														(err ERR-TOO-MANY-TXINS))}))
							))

(define-read-only (read-txins (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txins (try! (read-varint ctx)))
					(num-txins (get varint parsed-num-txins))
					(new-ctx (get ctx parsed-num-txins)))
		 (if (> num-txins u8)
				 (err ERR-TOO-MANY-TXINS)
				 (fold read-next-txin (bool-list-of-len num-txins) (ok { ctx: new-ctx, remaining: num-txins, txins: (list)})))))

(define-read-only (read-next-txout (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																											txouts: (list 8 {value: uint,
																																			 scriptPubKey: (buff 128)})}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-value (try! (read-uint64 (get ctx state))))
					(parsed-script (try! (read-varslice (get ctx parsed-value))))
					(new-ctx (get ctx parsed-script)))
				(ok {ctx: new-ctx,
						txouts: (unwrap!
											(as-max-len?
													(append (get txouts state)
															{   value: (get uint64 parsed-value),
																	scriptPubKey: (unwrap! (as-max-len? (get varslice parsed-script) u128) (err ERR-VARSLICE-TOO-LONG))}) u8)
											(err ERR-TOO-MANY-TXOUTS))})))

(define-read-only (read-txouts (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txouts (try! (read-varint ctx)))
					(num-txouts (get varint parsed-num-txouts))
					(new-ctx (get ctx parsed-num-txouts)))
		 (if (> num-txouts u8)
				 (err ERR-TOO-MANY-TXOUTS)
				 (fold read-next-txout (bool-list-of-len num-txouts) (ok { ctx: new-ctx, txouts: (list)})))))

(define-read-only (read-next-item (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																												 items: (list 8 (buff 128))}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-item (try! (read-varslice (get ctx state))))
					(new-ctx (get ctx parsed-item)))
				(ok {ctx: new-ctx,
						items: (unwrap!
											(as-max-len?
													(append (get items state) (unwrap! (as-max-len? (get varslice parsed-item) u128) (err ERR-VARSLICE-TOO-LONG))) u8)
											(err ERR-TOO-MANY-WITNESSES))})))

(define-read-only (read-next-witness (ignored bool)
	(result (response
		{ ctx: {txbuff: (buff 4096), index: uint}, witnesses: (list 8 (list 8 (buff 128))) } uint)))
	(let ((state (unwrap! result result))
				(parsed-num-items (try! (read-varint (get ctx state))))
				(ctx (get ctx parsed-num-items))
				(varint (get varint parsed-num-items)))
			(if (> varint u0)
				(let ((parsed-items (try! (fold read-next-item (bool-list-of-len varint) (ok { ctx: ctx, items: (list)})))))
						(ok {
							witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (get items parsed-items)) u8)),
							ctx: (get ctx parsed-items)
						}))
				(ok {
					witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (list)) u8)),
					ctx: ctx
				}))))

(define-read-only (read-witnesses (ctx { txbuff: (buff 4096), index: uint }) (num-txins uint))
	(fold read-next-witness (bool-list-of-len num-txins) (ok { ctx: ctx, witnesses: (list) })))

(define-read-only (parse-wtx (tx (buff 4096)) (calculate-txid bool))
		(let ((ctx { txbuff: tx, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-segwit-marker (try! (read-uint8 (get ctx parsed-version))))
					(parsed-segwit-version (try! (read-uint8 (get ctx parsed-segwit-marker))))
					(parsed-txins (try! (read-txins (get ctx parsed-segwit-version))))
					(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
					(parsed-witnesses (try! (read-witnesses (get ctx parsed-txouts) (len (get txins parsed-txins)))))
					(parsed-locktime (try! (read-uint32 (get ctx parsed-witnesses))))
					)
		(asserts! (and (is-eq (get uint8 parsed-segwit-marker) u0) (is-eq (get uint8 parsed-segwit-version) u1)) (err ERR-NOT-SEGWIT-TRANSACTION))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			segwit-marker: (get uint8 parsed-segwit-marker),
			segwit-version: (get uint8 parsed-segwit-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			txid: (if calculate-txid
				(some (reverse-buff32 (sha256 (sha256
					(concat
						(unwrap-panic (slice? tx u0 u4))
					(concat
						(unwrap-panic (slice? tx (get index (get ctx parsed-segwit-version)) (get index (get ctx parsed-txouts))))
						(unwrap-panic (slice? tx (get index (get ctx parsed-witnesses)) (len tx)))))))))
				none),
			witnesses: (get witnesses parsed-witnesses),
			locktime: (get uint32 parsed-locktime)
		})))

(define-read-only (parse-tx (tx (buff 4096)))
		(let ((ctx { txbuff: tx, index: u0})
			(parsed-version (try! (read-uint32 ctx)))
			(parsed-txins (try! (read-txins (get ctx parsed-version))))
			(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
			(parsed-locktime (try! (read-uint32 (get ctx parsed-txouts)))))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			locktime: (get uint32 parsed-locktime)})))

(define-read-only (parse-block-header (headerbuff (buff 80)))
		(let ((ctx { txbuff: headerbuff, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-parent-hash (try! (read-hashslice (get ctx parsed-version))))
					(parsed-merkle-root (try! (read-hashslice (get ctx parsed-parent-hash))))
					(parsed-timestamp (try! (read-uint32 (get ctx parsed-merkle-root))))
					(parsed-nbits (try! (read-uint32 (get ctx parsed-timestamp))))
					(parsed-nonce (try! (read-uint32 (get ctx parsed-nbits)))))
		 (ok {version: (get uint32 parsed-version),
					parent: (get hashslice parsed-parent-hash),
					merkle-root: (get hashslice parsed-merkle-root),
					timestamp: (get uint32 parsed-timestamp),
					nbits: (get uint32 parsed-nbits),
					nonce: (get uint32 parsed-nonce)})))

(define-constant DEBUG-MODE true)

(define-map mock-burnchain-header-hashes uint (buff 32))

(define-public (mock-add-burnchain-block-header-hash (burn-height uint) (hash (buff 32)))
 (ok (map-set mock-burnchain-header-hashes burn-height hash)))

(define-read-only (get-bc-h-hash (bh uint))
	 (if DEBUG-MODE (map-get? mock-burnchain-header-hashes bh) (get-burn-block-info? header-hash bh)))


(define-read-only (verify-block-header (headerbuff (buff 80)) (expected-block-height uint))
	(match (get-bc-h-hash expected-block-height)
			bhh (is-eq bhh (reverse-buff32 (sha256 (sha256 headerbuff))))
			false))

(define-read-only (get-reversed-txid (tx (buff 4096)))
		(sha256 (sha256 tx)))

(define-read-only (get-txid (tx (buff 4096)))
		(reverse-buff32 (sha256 (sha256 tx))))

(define-read-only (is-bit-set (val uint) (bit uint))
	(> (bit-and val (bit-shift-left u1 bit)) u0))

(define-private (inner-merkle-proof-verify (ctr uint) (state { path: uint, root-hash: (buff 32), proof-hashes: (list 14 (buff 32)), tree-depth: uint, cur-hash: (buff 32), verified: bool}))
  (let ((path (get path state))
        (is-left (is-bit-set path ctr))
        (proof-hashes (get proof-hashes state))
        (cur-hash (get cur-hash state))
        (root-hash (get root-hash state))

        (h1 (if is-left (unwrap-panic (element-at proof-hashes ctr)) cur-hash))
        (h2 (if is-left cur-hash (unwrap-panic (element-at proof-hashes ctr))))
        (next-hash (sha256 (sha256 (concat h1 h2))))
        (is-verified (and (is-eq (+ u1 ctr) (len proof-hashes)) (is-eq next-hash root-hash))))
    (merge state { cur-hash: next-hash, verified: is-verified})))

(define-read-only (verify-merkle-proof (reversed-txid (buff 32)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(if (> (get tree-depth proof) (len (get hashes proof)))
				(err ERR-PROOF-TOO-SHORT)
				(ok
					(get verified
							(fold inner-merkle-proof-verify
									(unwrap-panic (slice? (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13) u0 (get tree-depth proof)))
									{ path: (+ (pow u2 (get tree-depth proof)) (get tx-index proof)), root-hash: merkle-root, proof-hashes: (get hashes proof), cur-hash: reversed-txid, tree-depth: (get tree-depth proof), verified: false})))))


(define-read-only (get-commitment-scriptPubKey (outs (list 8 { value: uint, scriptPubKey: (buff 128) })))
	(fold inner-get-commitment-scriptPubKey outs 0x))

(define-read-only (inner-get-commitment-scriptPubKey (out { value: uint, scriptPubKey: (buff 128) }) (result (buff 128)))
	(let ((commitment (get scriptPubKey out)))
		(if (is-commitment-pattern commitment) commitment result)))

(define-read-only (is-commitment-pattern (scriptPubKey (buff 128)))
	(asserts! (is-eq (unwrap! (slice? scriptPubKey u0 u6) false) 0x6a24aa21a9ed) false))



(define-read-only (was-tx-mined-compact (height uint) (tx (buff 4096))
	(header (buff 80))
	(proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(let ((block (unwrap! (parse-block-header header) (err ERR-BAD-HEADER))))
			(was-tx-mined-internal height tx header (get merkle-root block) proof)))

(define-private (was-tx-mined-internal (height uint) (tx (buff 4096)) (header (buff 80)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
	(if (verify-block-header header height)
		(let ((reversed-txid (get-reversed-txid tx))
					(txid (reverse-buff32 reversed-txid)))
			(asserts!
				(or
					(try! (verify-merkle-proof reversed-txid (reverse-buff32 merkle-root) proof)))
				(err ERR-INVALID-MERKLE-PROOF))
			(ok txid))
		(err ERR-HEADER-HEIGHT-MISMATCH)))


(define-read-only (was-segwit-tx-mined-compact
	(height uint)
	(wtx (buff 4096))
	(header (buff 80))
	(tx-index uint)
	(tree-depth uint)
	(wproof (list 14 (buff 32)))
	(witness-merkle-root (buff 32))
	(witness-reserved-value (buff 32))
	(ctx (buff 1024))
	(cproof (list 14 (buff 32))))
	(begin
		(try! (was-tx-mined-compact height ctx header { tx-index: u0, hashes: cproof, tree-depth: tree-depth }))
		(let (
			(witness-out (get-commitment-scriptPubKey (get outs (try! (parse-tx ctx)))))
			(final-hash (sha256 (sha256 (concat witness-merkle-root witness-reserved-value))))
			(reversed-wtxid (get-reversed-txid wtx))
			(wtxid (reverse-buff32 reversed-wtxid))
		)
			(asserts! (is-eq witness-out (concat 0x6a24aa21a9ed final-hash)) (err ERR-INVALID-COMMITMENT))
			(asserts! (try! (verify-merkle-proof reversed-wtxid witness-merkle-root
													{ tx-index: tx-index, hashes: wproof, tree-depth: tree-depth })) (err ERR-WITNESS-TX-NOT-IN-COMMITMENT))
			(ok wtxid))))"
"Generate a Clarity smart contract for an NFT collection that implements the specified functionality, including defining a non-fungible token, managing token IDs, handling ownership, and enabling minting and transferring of tokens. Ensure the contract includes error constants for various scenarios such as unauthorized access or unsupported transactions, integrates a base URI for token metadata, and validates Bitcoin transaction mining status through an external clarity-bitcoin-lib-v5 library call. The mint function should increment the token ID, verify the sender is the contract owner, confirm the Bitcoin transaction was mined, and mint the token to the specified recipient. The transfer function must ensure only the token owner can initiate transfers and update ownership accordingly","First, I need to understand what I'm being asked to create. The prompt is asking for a Clarity smart contract that implements an NFT collection with specific functionality including token management, ownership handling, and minting/transfer capabilities. I'll need to think about how to structure this contract logically.
Let's start by implementing the NFT trait. In Clarity, traits allow contracts to implement standard interfaces, and for NFTs there's likely a standard trait to follow. I'll need to implement the nft-trait from a well-known library to ensure my contract follows standard NFT practices.
I'll need to define some key constants, particularly for error handling. Wait, I should think about what error scenarios might occur in an NFT contract: unauthorized access when someone other than the owner tries to mint, token ownership issues during transfers, and possibly Bitcoin transaction validation failures since the requirement mentions clarity-bitcoin-lib-v5.
Okay, for state management, I need variables to track important information. I'll need a non-fungible token definition, a way to track the last token ID used, and a base URI for metadata. The base URI will likely follow a pattern where the token ID can be inserted to create unique URIs for each token.
For the core functionality, I need to implement several public functions. The mint function seems complex - it needs to increment the token ID, verify the sender is the contract owner, validate a Bitcoin transaction was mined (using an external library), and then mint the token to a recipient. This suggests the NFT minting is tied to Bitcoin transactions in some way.
Then I need a transfer function that only allows the current token owner to transfer their NFTs to others. This is a standard NFT capability but requires careful ownership verification.
I should also include read-only functions for querying information about the NFTs, such as getting the token URI or checking who owns a particular token ID.
Let's see, for the Bitcoin transaction verification, I'll need to use that external library mentioned in the prompt. This suggests the contract might be designed for a system where NFT minting is triggered by or validated against Bitcoin blockchain events, which is an interesting cross-chain application.
The mint function will be the most complex part, as it needs to handle the token ID incrementing, verify the sender is the contract owner, validate Bitcoin transactions, and perform the actual minting. I might use a ""let"" expression to organize this logic clearly.
Wait, I need to make sure error handling is robust. Each function should validate preconditions before executing its core logic, and return appropriate error constants when those validations fail.
For the transfer function, I need to verify that the sender attempting the transfer is actually the current owner of the token being transferred. This prevents unauthorized transfers.
Then I need to think about how to organize the return values. Clarity functions typically return responses with either success values or error codes, so I'll need to structure my functions to handle both cases appropriately.
Okay, I think with all these considerations, I can create a comprehensive NFT contract that meets the requirements while providing appropriate error handling and security measures. The contract will define a non-fungible token, manage token IDs sequentially, handle ownership through the built-in NFT capabilities, enable minting with Bitcoin transaction validation, and allow secure transfers between users.",";;title: btc-tx-enabled-nft
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))
(define-constant err-not-found (err u102))
(define-constant err-unsupported-tx (err u103))
(define-constant err-out-not-found (err u104))
(define-constant err-in-not-found (err u105))
(define-constant err-tx-not-mined (err u106))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-non-fungible-token Your-NFT-Name uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
    (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
    (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
    (ok (nft-get-owner? Your-NFT-Name token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
    (begin
        (asserts! (is-eq tx-sender sender) err-not-token-owner)
        (nft-transfer? Your-NFT-Name token-id sender recipient)
    )
)

(define-public (mint (recipient principal) (height uint) (tx (buff 1024)) (header (buff 80)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
    (let
        (
            (token-id (+ (var-get last-token-id) u1))
            (tx-was-mined (contract-call? 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.clarity-bitcoin-lib-v5 was-tx-mined-compact height tx header proof))
        )
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (asserts! (is-ok tx-was-mined) err-tx-not-mined)
        (try! (nft-mint? Your-NFT-Name token-id recipient))
        (var-set last-token-id token-id)
        (ok token-id)
    )
)"
"Generate a Clarity smart contract for a fungible token that adheres to the SIP-010 standard, ensuring it includes all necessary functions and constants as described: implement the SIP-010 trait, define a fungible token named 'count-token', include error constants for owner-only actions and non-token owners, set the contract owner as the transaction sender, define a mutable TOKEN-URI variable with an initial value, and specify constants for the token's name, symbol, and decimals. Include read-only functions to retrieve the balance of a given principal, the total supply of the token, the token's name, symbol, decimals, and URI. Add public functions to update the token URI if the caller is the contract owner, mint tokens with a fixed amount to the sender, burn tokens from the sender's balance or STX if no tokens exist, and transfer tokens between principals with an optional memo field while enforcing ownership checks.","I'll generate a detailed Chain-of-Thought explaining the reasoning process for creating this Clarity smart contract based on the requirements.
First, let me understand what I'm being asked to create: a fungible token that follows the SIP-010 standard. This is essentially the Stacks blockchain equivalent of Ethereum's ERC-20 token standard. I need to make sure this contract fully implements the required interface and includes all the specified functionality.
I'll start by implementing the SIP-010 trait, which is the interface our token needs to adhere to. This is done with the impl-trait declaration that references the standard trait definition. The trait path 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait' points to the official SIP-010 trait definition on the Stacks blockchain.
Next, I need to define the actual fungible token. Since the requirement specifies naming it 'count-token', I'll use the define-fungible-token command with that name. This creates the basic token type that will be managed by our contract.
Let's see, I need error constants for owner-only actions and non-token owners. I'll define these as ERR_OWNER_ONLY with code u100 and ERR_NOT_TOKEN_OWNER with code u101. These will be used throughout the contract when validating permissions.
The contract owner should be set as the transaction sender. I'll define CONTRACT_OWNER as a constant with the value tx-sender, which captures whoever deploys the contract.
For the token metadata, I need to include a mutable TOKEN-URI variable. This should be modifiable later, so I'll use define-data-var to create a mutable variable. Since URIs might be empty, I'll make it an optional string type with a maximum length of 256 characters and initialize it with a sample URI.
Then I'll define the token's basic properties as constants: TOKEN_NAME as ""Count Token"", TOKEN_SYMBOL as ""COUNT"", and apparently TOKEN_DECIMALS (which seems to be referenced later but not defined in the snippet shown).
Okay, now for the read-only functions. The SIP-010 trait requires several standard getters. I'll implement: get-balance to check a principal's token balance, get-total-supply to return the total token supply, get-name to return the token name, get-symbol to return the token symbol, get-decimals to return the decimal places, get-token-uri to return the token's URI
For public functions, the requirements mention: A function to update the token URI (owner-only), A minting function, A burning function, A transfer function with memo field
For the URI update function, I'll create set-token-uri that validates the caller is the contract owner before updating the TOKEN-URI variable and emitting a notification of the change.
The mint function seems to be restricted to the .counter contract, not just the contract owner. This might be a specific design requirement where tokens are only minted through interaction with another contract.
Similarly, the burn function also checks if the caller is the .counter contract. Interestingly, it has a fallback to burn STX (the native token) if the user doesn't have enough COUNT tokens to burn, which is an unusual but potentially useful feature.
Finally, the transfer function needs to implement the SIP-010 transfer requirements plus handle an optional memo. The function verifies the sender is authorized, performs the token transfer, and prints the memo if provided.
Wait, I should double-check the permission checks in the transfer function. It seems to allow either the tx-sender or the contract-caller to be the sender, which provides flexibility but must be handled carefully to maintain security.
In summary, this contract fully implements the SIP-010 trait for a fungible token named ""Count Token"" with the specialized functionality to integrate with a counter contract for minting and burning. The contract includes all required read functions for token information and the necessary public functions for managing the token, with appropriate permission checks throughout.",";;title:count-token
(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-fungible-token count-token)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))

(define-constant CONTRACT_OWNER tx-sender)
(define-data-var TOKEN-URI (optional (string-utf8 256)) (some u""https://ustnpmyvsbtbyjiqiwge.supabase.co/storage/v1/object/public/Count%20Token%20Metadata/count-token-metadata.json""))
(define-constant TOKEN_NAME ""Count Token"")
(define-constant TOKEN_SYMBOL ""COUNT"")


(define-read-only (get-balance (who principal))
  (ok (ft-get-balance count-token who))
)

(define-read-only (get-total-supply)
  (ok (ft-get-supply count-token))
)

(define-read-only (get-name)
  (ok TOKEN_NAME)
)

(define-read-only (get-symbol)
  (ok TOKEN_SYMBOL)
)

(define-read-only (get-decimals)
  (ok TOKEN_DECIMALS)
)

(define-read-only (get-token-uri)
  (ok (var-get TOKEN-URI))
)

(define-public (set-token-uri (value (string-utf8 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) (err ERR_OWNER_ONLY))
        (var-set TOKEN-URI (some value))
        (ok (print {
              notification: ""token-metadata-update"",
              payload: {
                contract-id: (as-contract tx-sender),
                token-class: ""ft""
              }
            })
        )
    )
)

(define-public (mint)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (ft-mint? count-token u1000000 tx-sender)
  )
)

(define-public (burn)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (if (> (unwrap-panic (get-balance tx-sender)) u0)
      (ft-burn? count-token u1000000 tx-sender)
      (stx-burn? u1000000 tx-sender)
    )
  )
)

(define-public (transfer
  (amount uint)
  (sender principal)
  (recipient principal)
  (memo (optional (buff 34)))
)
  (begin
    (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) ERR_NOT_TOKEN_OWNER)
    (try! (ft-transfer? count-token amount sender recipient))
    (match memo to-print (print to-print) 0x)
    (ok true)
  )
)"
"I need a Clarity smart contract that implements a payment channel system for off-chain transactions in STX and SIP-010 tokens, including functionalities like opening, closing, disputing, and finalizing channels, signature verification, nonce management, and payout mechanisms, ensuring it adheres to best practices for security and efficiency within the Stacks ecosystem.","First, I need to understand what a payment channel system is and how it would work within the Stacks ecosystem. Payment channels allow for off-chain transactions between parties, reducing blockchain congestion and fees while maintaining security. The basic workflow involves: Opening a channel between two parties with initial deposits, Conducting multiple off-chain transactions by exchanging signed messages, Eventually closing the channel and settling the final balances on-chain, Let's see, the contract needs to implement several key functionalities including opening channels, updating channel states, disputing transactions, and closing channels. I'll need to ensure proper security with signature verification.

For state management, I'll need to track channel information like participants, balances, expiration times, and a nonce to prevent replay attacks. I'll start by defining constants, error codes, and data structures.

The contract will need to support both STX (native token) and SIP-010 fungible tokens, so I'll use a trait to handle this flexibility. This means I need to implement token-agnostic functions.

Okay, for channel identification, I should create a deterministic way to reference channels between two parties. Since the order of participants shouldn't matter, I'll sort the principals to create a consistent key.

Wait, I need to think about security. Channel operations must be authorized by valid signatures from the parties involved. I'll implement structured data signing following SIP-018 standard to prevent signature replay attacks across different contracts.

For the channel lifecycle, I'll need functions to: Initialize the contract and set supported tokens, Fund/open channels, Close channels cooperatively, with both parties' signatures), Handle disputes with timelock mechanisms, Allow unilateral closures when needed, Manage deposits/withdrawals, during channel lifetime, I might need an agent system too, allowing users to delegate transaction execution to third parties without compromising security.

For dispute resolution, I should implement a challenge period where the counterparty can submit a more recent channel state. This prevents fraud by giving both parties time to respond.

The signature verification is particularly important. Each update to channel state must be signed by both parties. The signatures will need to cover all relevant data including balances, nonce, action type, and any conditional execution parameters.

Let me think about edge cases. What if a participant becomes unresponsive? I need a force-close mechanism with a timeout period. What about invalid state transitions? I'll need proper validation checks.

For payment execution, the contract must hold funds in escrow and distribute them correctly when channels close. This requires careful handling of token transfers.

Wait, I should also consider hash time-locked contracts (HTLCs) for conditional payments, which would enable more complex use cases like atomic swaps.

The nonce management is critical - each update must have a higher nonce than previous ones to ensure outdated states can't be used.

For data structures, I'll use maps to store channel information with composite keys containing participant addresses and token information.

Maybe I should add some utility functions to make the code more readable and maintainable, separating business logic from technical operations like signature verification.

Thinking about error handling, I'll define specific error constants to improve debugging and user experience.

Okay, then for security, I need to ensure funds can't be stolen - only transferred according to agreed-upon state updates with valid signatures. The contract must validate that the sum of balances remains consistent during updates.

I should also implement events (via print statements in Clarity) to allow monitoring of channel operations off-chain.

Might be good to allow withdrawals during channel lifetime to improve capital efficiency.

Overall, the contract needs to balance security, efficiency, and usability while implementing all the core payment channel functionalities. The resulting code should provide a robust foundation for off-chain transactions in the Stacks ecosystem.",";; title: stackflow 
;; summary: Stackflow is a payment channel network built on Stacks, enabling
;;   off-chain, non-custodial, and high-speed payments between users. Designed
;;   to be simple, secure, and efficient, it supports transactions in STX and
;;   SIP-010 fungible tokens.
(use-trait sip-010 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)(impl-trait .stackflow-token.stackflow-token)
(define-constant contract-deployer tx-sender)
(define-constant MAX_HEIGHT u340282366920938463463374607431768211455)(define-constant structured-data-prefix 0x534950303138)
(define-constant message-domain-hash (sha256 (unwrap-panic (to-consensus-buff?
        {
                name: ""StackFlow"",
                version: ""0.5.0"",
                chain-id: chain-id
        }
))))
(define-constant structured-data-header (concat structured-data-prefix message-domain-hash))
(define-constant ACTION_CLOSE u0)
(define-constant ACTION_TRANSFER u1)
(define-constant ACTION_DEPOSIT u2)
(define-constant ACTION_WITHDRAWAL u3)
(define-constant ERR_DEPOSIT_FAILED (err u100))
(define-constant ERR_NO_SUCH_CHANNEL (err u101))
(define-constant ERR_INVALID_PRINCIPAL (err u102))
(define-constant ERR_INVALID_SENDER_SIGNATURE (err u103))
(define-constant ERR_INVALID_OTHER_SIGNATURE (err u104))
(define-constant ERR_CONSENSUS_BUFF (err u105))
(define-constant ERR_UNAUTHORIZED (err u106))
(define-constant ERR_MAX_ALLOWED (err u107))
(define-constant ERR_INVALID_TOTAL_BALANCE (err u108))
(define-constant ERR_WITHDRAWAL_FAILED (err u109))
(define-constant ERR_CHANNEL_EXPIRED (err u110))
(define-constant ERR_NONCE_TOO_LOW (err u111))
(define-constant ERR_CLOSE_IN_PROGRESS (err u112))
(define-constant ERR_NO_CLOSE_IN_PROGRESS (err u113))
(define-constant ERR_SELF_DISPUTE (err u114))
(define-constant ERR_ALREADY_FUNDED (err u115))
(define-constant ERR_INVALID_WITHDRAWAL (err u116))
(define-constant ERR_UNAPPROVED_TOKEN (err u117))
(define-constant ERR_NOT_EXPIRED (err u118))
(define-constant ERR_NOT_INITIALIZED (err u119))
(define-constant ERR_ALREADY_INITIALIZED (err u120))
(define-constant ERR_NOT_VALID_YET (err u121))
(define-data-var initialized bool false)
(define-data-var supported-token (optional principal) none)
(define-map
  channels
  { token: (optional principal), principal-1: principal, principal-2: principal }
  { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) }
)
(define-map agents principal principal)
;;
(define-public (init (token (optional <sip-010>)))
  (begin
    (asserts! (not (var-get initialized)) ERR_ALREADY_INITIALIZED)
    (asserts! (is-eq tx-sender contract-deployer) ERR_UNAUTHORIZED)
    (var-set supported-token (contract-of-optional token))
    (ok (var-set initialized true))
  )
)
(define-public (register-agent (agent principal))
  (ok (map-set agents tx-sender agent))
)
(define-public (deregister-agent)
  (ok (map-delete agents tx-sender))
)
(define-public (fund-channel (token (optional <sip-010>)) (amount uint) (with principal) (nonce uint))
  (begin
    (try! (check-token token))

    (let
      (
        (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
        (existing-channel (map-get? channels channel-key))
        (channel
          (match
            existing-channel
            ch
            ch
            { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
          )
        )
        (updated-channel (try! (increase-sender-balance channel-key channel token amount)))
        (closer (get closer channel))
      )
      (asserts! (>= (get nonce channel) nonce) ERR_NONCE_TOO_LOW)
      (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
      (asserts! (not (is-funded tx-sender channel-key channel)) ERR_ALREADY_FUNDED)

      (map-set channels channel-key updated-channel)
      (print {
        event: ""fund-channel"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: tx-sender,
        amount: amount,
      })
      (ok channel-key)
    )
  )
)
(define-public (close-channel
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel {
        balance-1: balance-1,
        balance-2: balance-2,
        expires-at: MAX_HEIGHT,
        nonce: nonce,
        closer: none
      })
    )
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_CLOSE
        tx-sender
        none
        none
      )
    )
    (reset-channel channel-key nonce)
    (print {
      event: ""close-channel"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
    })
    (payout token tx-sender with my-balance their-balance)
  )
)
(define-public (force-cancel (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (+ burn-block-height WAITING_PERIOD))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (map-set
      channels
      channel-key
      (merge channel { expires-at: expires-at, closer: (some tx-sender) })
    )
    (print {
      event: ""force-cancel"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (ok expires-at)
  )
)
(define-public (force-close
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (expires-at (+ burn-block-height WAITING_PERIOD))
        (principal-1 (get principal-1 channel-key))
        (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
        (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
        (new-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: expires-at,
          closer: (some tx-sender),
          nonce: nonce
        })
      )
      (try!
        (verify-signatures
          my-signature
          tx-sender
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (map-set
        channels
        channel-key
        new-channel
      )
      (print {
        event: ""force-close"",
        channel-key: channel-key,
        channel: new-channel,
        sender: tx-sender,
      })

      (ok expires-at)
    )
  )
)
(define-public (dispute-closure
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (dispute-closure-inner
    tx-sender
    token
    with
    my-balance
    their-balance
    my-signature
    their-signature
    nonce
    action
    actor
    secret
    valid-after
  )
)
(define-public (agent-dispute-closure
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (agent (unwrap! (map-get? agents for) ERR_UNAUTHORIZED))
    )
    (asserts! (is-eq tx-sender agent) ERR_UNAUTHORIZED)
    (dispute-closure-inner
      for
      token
      with
      my-balance
      their-balance
      my-signature
      their-signature
      nonce
      action
      actor
      secret
      valid-after
    )
  )
)
(define-public (finalize  (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (get expires-at channel))
    )    (asserts! (is-some closer) ERR_NO_CLOSE_IN_PROGRESS)
    (asserts! (> burn-block-height expires-at) ERR_NOT_EXPIRED)
    (reset-channel channel-key (get nonce channel))
    (print {
      event: ""finalize"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (payout
      token
      (get principal-1 channel-key)
      (get principal-2 channel-key)
      (get balance-1 channel)
      (get balance-2 channel)
    )
  )
)
(define-public (deposit
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_DEPOSIT
        tx-sender
        none
        none
      )
    )
    (try! (increase-sender-balance channel-key channel token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""deposit"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
(define-public (withdraw
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )
    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (> (+ (get balance-1 channel) (get balance-2 channel)) amount)
      ERR_INVALID_WITHDRAWAL
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (- (+ (get balance-1 channel) (get balance-2 channel)) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_WITHDRAWAL
        tx-sender
        none
        none
      )
    )
    (try! (execute-withdraw token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""withdraw"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
;;
(define-read-only (get-channel (token (optional principal)) (with principal))
  (match (get-channel-key token tx-sender with)
    channel-key (map-get? channels channel-key)
    e none
  )
)
(define-read-only (make-structured-data-hash
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (structured-data (merge
        channel-key
        {
          balance-1: balance-1,
          balance-2: balance-2,
          nonce: nonce,
          action: action,
          actor: actor,
          hashed-secret: hashed-secret,
          valid-after: valid-after,
        }
      ))
      (data-hash (sha256 (unwrap! (to-consensus-buff? structured-data) ERR_CONSENSUS_BUFF)))
    )
    (ok (sha256 (concat structured-data-header data-hash)))
  )
)
(define-read-only (verify-signature
    (signature (buff 65))
    (signer principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let ((hash (unwrap! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ) false)))
    (verify-hash-signature hash signature signer actor)
  )
)
(define-read-only (verify-signatures
    (signature-1 (buff 65))
    (signer-1 principal)
    (signature-2 (buff 65))
    (signer-2 principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let (
    (hashed-secret (match secret s (some (sha256 s)) none))
    (hash (try! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ))))
    (asserts! (verify-hash-signature hash signature-1 signer-1 actor) ERR_INVALID_SENDER_SIGNATURE)
    (asserts! (verify-hash-signature hash signature-2 signer-2 actor) ERR_INVALID_OTHER_SIGNATURE)
    (ok true)
  )
)
;;
(define-private (contract-of-optional (trait (optional <sip-010>)))
  (match trait
    t
    (some (contract-of t))
    none
  )
)
(define-private (get-channel-key (token (optional principal)) (principal-1 principal) (principal-2 principal))
  (let
    (
      (p1 (unwrap! (to-consensus-buff? principal-1) ERR_INVALID_PRINCIPAL))
      (p2 (unwrap! (to-consensus-buff? principal-2) ERR_INVALID_PRINCIPAL))
    )
    (ok (if (< p1 p2)
      { token: token, principal-1: principal-1, principal-2: principal-2 }
      { token: token, principal-1: principal-2, principal-2: principal-1 }
    ))
  )
)
(define-private (increase-sender-balance
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
    (token (optional <sip-010>))
    (amount uint)
  )
  (begin
    (match token
      t
      (unwrap! (contract-call? t transfer amount tx-sender (as-contract tx-sender) none) ERR_DEPOSIT_FAILED)
      (unwrap! (stx-transfer? amount tx-sender (as-contract tx-sender)) ERR_DEPOSIT_FAILED)
    )
    (ok
      (if (is-eq tx-sender (get principal-1 channel-key))
        (merge channel { balance-1: (+ (get balance-1 channel) amount) })
        (merge channel { balance-2: (+ (get balance-2 channel) amount) })
      )
    )
  )
)
(define-private (execute-withdraw
    (token (optional <sip-010>))
    (amount uint)
  )
  (let ((sender tx-sender))
    (unwrap!
      (match token
        t
        (as-contract (contract-call? t transfer amount tx-sender sender none))
        (as-contract (stx-transfer? amount tx-sender sender))
      )
      ERR_WITHDRAWAL_FAILED
    )
    (ok true)
  )
)
(define-private (dispute-closure-inner
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) for with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (expires-at (get expires-at channel))
      (channel-nonce (get nonce channel))
      (closer (unwrap! (get closer channel) ERR_NO_CLOSE_IN_PROGRESS))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq for principal-1) my-balance their-balance))
      (balance-2 (if (is-eq for principal-1) their-balance my-balance))
    )
    (asserts! (not (is-eq for closer)) ERR_SELF_DISPUTE)
    (asserts! (< burn-block-height expires-at) ERR_CHANNEL_EXPIRED)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (updated-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: MAX_HEIGHT,
          nonce: nonce,
          closer: none
        })
      )
      (try!
        (verify-signatures
          my-signature
          for
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (reset-channel channel-key nonce)
      (print {
        event: ""dispute-closure"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: for,
      })
      (payout token for with my-balance their-balance)
    )
  )
)
(define-private (is-funded
    (account principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
  )
  (or
    (and (is-eq account (get principal-1 channel-key)) (> (get balance-1 channel) u0))
    (and (is-eq account (get principal-2 channel-key)) (> (get balance-2 channel) u0))
  )
)
(define-private (payout
    (token (optional <sip-010>))
    (principal-1 principal)
    (principal-2 principal)
    (balance-1 uint)
    (balance-2 uint)
  )
  (begin
    (try! (transfer token principal-1 balance-1))
    (transfer token principal-2 balance-2)
  )
)
(define-private (transfer (token (optional <sip-010>)) (addr principal) (amount uint))
  (if (is-eq amount u0)    (ok (is-some token))
    (begin
      (match token
        t (unwrap! (as-contract (contract-call? t transfer amount tx-sender addr none)) ERR_WITHDRAWAL_FAILED)
        (unwrap! (as-contract (stx-transfer? amount tx-sender addr)) ERR_WITHDRAWAL_FAILED)
      )
      (ok (is-some token))
    )
  )
)
(define-private (reset-channel
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (nonce uint)
  )
  (map-set
    channels
    channel-key
    { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
  )
)
(define-private (verify-hash-signature
    (hash (buff 32))
    (signature (buff 65))
    (signer principal)
    (actor principal)
  )
  (or
    (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok signer))    (and
      (not (is-eq signer actor))
      (match (map-get? agents signer)
        agent (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok agent))
        false
      )
    )
  )
)
(define-private (check-token (token (optional <sip-010>)))
  (begin    (asserts! (var-get initialized) ERR_NOT_INITIALIZED)
    (asserts! (is-eq (contract-of-optional token) (var-get supported-token)) ERR_UNAPPROVED_TOKEN)

    (ok true)
  )
)"
"please generate a Clarity smart contract that implements a subnet system with functionalities for managing miners, registering new fungible and non-fungible token contracts, committing blocks with withdrawal roots, handling deposits and withdrawals of STX, fungible tokens, and non-fungible tokens while ensuring proper validation through Merkle proofs, and performing safe transfers or minting of assets as needed, based on the structure and logic demonstrated in the provided code snippet.","First, I need to understand what a subnet system is in the context of blockchain. A subnet is essentially a secondary blockchain network that operates alongside a main chain. It allows for specialized transaction processing and scaling. For this implementation, I'll need to create a contract that manages asset transfers between the main chain (L1) and the subnet (L2).
Let me start by defining the error constants. These are important for providing meaningful feedback when operations fail. I'll need constants for common error cases like block commits, invalid miners, failed transfers, and validation issues. These will make debugging easier and improve the user experience by providing specific error messages.
Next, I need to set up the data structures. I'll need maps to track committed blocks, withdrawal roots, and processed withdrawals. These are essential for maintaining the state of the subnet and preventing double-spending. I'll also need a variable to track the authorized miner who can commit blocks and register contracts.
For contract interoperability, I'll need to use traits to interact with different token standards. I'll need traits for NFTs, fungible tokens, and a custom trait for minting tokens from the subnet. This allows the contract to interact with various token contracts in a standardized way.
The miner management is crucial for security. I'll implement a function to update the miner, but only the current miner should be allowed to set a new one. This maintains the security of the subnet by ensuring only authorized parties can commit blocks.
For asset registration, I'll need functions to register both fungible and non-fungible token contracts. This creates a mapping between L1 contracts and their L2 counterparts. The registration should only be allowed by the authorized miner.
Wait, I need to implement block commitment functionality. This is how the subnet's state is anchored to the main chain. Each block commitment should include a withdrawal root which is a Merkle root of all withdrawals included in that block. I'll need to validate that the block hasn't been committed before and that the miner is authorized.
Now for the core asset management functions. I'll start with NFT deposits and withdrawals. For deposits, users transfer their NFTs to the contract, which records the deposit event. For withdrawals, the contract needs to validate a Merkle proof against the committed withdrawal root, then transfer the NFT to the recipient.
Let's see, I need to handle cases where the contract might need to mint new NFTs rather than just transfer existing ones. This could happen if an NFT was created on the subnet but needs to be withdrawn to the main chain. I'll implement logic to check if the contract owns the NFT and mint it if necessary.
For fungible tokens, the logic is similar but with an additional consideration for amounts. I need to handle deposits where users transfer tokens to the contract, and withdrawals where the contract validates a Merkle proof and then transfers tokens back to users. Like with NFTs, I might need to mint tokens if the contract doesn't have enough balance.
The STX token (native token) needs special handling since it's not a contract. I'll implement dedicated functions for STX deposits and withdrawals, with similar validation logic but using the built-in stx-transfer? function instead of contract calls.
Okay, now I need to implement the Merkle proof validation. This is critical for security as it proves that a withdrawal was included in a committed block. I'll need functions to hash withdrawal data consistently, verify the Merkle path, and track processed withdrawals to prevent double-spending.
For the leaf hashing functions, I need to create distinct formats for STX, NFT, and FT withdrawals. These create unique identifiers for each withdrawal that can be included in the Merkle tree.
Then, I'll implement the hash verification logic that walks up the Merkle tree using the provided sibling hashes. This should reconstruct the root hash which can be compared against the committed withdrawal root.
Finally, I need a function to mark withdrawals as processed once they're successfully executed. This prevents the same withdrawal from being processed multiple times.
The implementation needs to be careful about error handling throughout. Each operation should validate the inputs and state before proceeding, and provide specific error codes when things go wrong. I also need to ensure the contract properly emits events for important operations like deposits and withdrawals to make them observable off-chain.
This comprehensive contract design should satisfy all the requirements for a subnet system with proper asset management and security controls.",";;title: subnet
(define-constant CONTRACT_ADDRESS (as-contract tx-sender))
(define-constant ERR_BLOCK_ALREADY_COMMITTED 1)
(define-constant ERR_INVALID_MINER 2)
(define-constant ERR_CONTRACT_CALL_FAILED 3)
(define-constant ERR_TRANSFER_FAILED 4)
(define-constant ERR_DISALLOWED_ASSET 5)
(define-constant ERR_ASSET_ALREADY_ALLOWED 6)
(define-constant ERR_MERKLE_ROOT_DOES_NOT_MATCH 7)
(define-constant ERR_INVALID_MERKLE_ROOT 8)
(define-constant ERR_WITHDRAWAL_ALREADY_PROCESSED 9)
(define-constant ERR_VALIDATION_FAILED 10)(define-constant ERR_INVALID_CHAIN_TIP 11)(define-constant ERR_CALLED_TOO_EARLY 12)
(define-constant ERR_MINT_FAILED 13)
(define-constant ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT 14)
(define-constant ERR_IN_COMPUTATION 15)(define-constant ERR_NFT_NOT_OWNED_BY_CONTRACT 16)
(define-constant ERR_VALIDATION_LEAF_FAILED 30)
(define-map block-commits uint (buff 32))(define-map withdrawal-roots-map (buff 32) bool)(define-map processed-withdrawal-leaves-map { withdrawal-leaf-hash: (buff 32), withdrawal-root-hash: (buff 32) } bool)
(define-data-var miner principal 'ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP)
(define-map allowed-contracts principal principal)
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)
(use-trait mint-from-subnet-trait .subnet-traits.mint-from-subnet-trait)
(define-public (update-miner (new-miner principal))
    (begin
        (asserts! (is-eq tx-sender (var-get miner)) (err ERR_INVALID_MINER))
        (ok (var-set miner new-miner))
    )
)
(define-public (register-new-ft-contract (ft-contract <ft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of ft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-public (register-new-nft-contract (nft-contract <nft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of nft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-private (is-miner (miner-to-check principal))
    (is-eq miner-to-check (var-get miner))
)
(define-private (can-commit-block? (commit-block-height uint)  (target-chain-tip (buff 32)))
    (begin        (asserts! (is-none (map-get? block-commits commit-block-height)) (err ERR_BLOCK_ALREADY_COMMITTED))
        (asserts! (is-eq
            target-chain-tip
            (unwrap! (get-block-info? id-header-hash (- block-height u1)) (err ERR_CALLED_TOO_EARLY)) )
            (err ERR_INVALID_CHAIN_TIP))
        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (is-miner contract-caller) (err ERR_INVALID_MINER))

        (ok true)
    )
)
(define-private (inner-commit-block (block (buff 32)) (commit-block-height uint) (withdrawal-root (buff 32)))
    (begin
        (map-set block-commits commit-block-height block)
        (map-set withdrawal-roots-map withdrawal-root true)
        (print {
            event: ""block-commit"",
            block-commit: block,
            withdrawal-root: withdrawal-root,
            block-height: commit-block-height
        })
        (ok block)
    )
)
;;(define-public (commit-block (block (buff 32)) (target-chain-tip (buff 32)) (withdrawal-root (buff 32)))
    (let ((commit-block-height block-height))
        (try! (can-commit-block? commit-block-height target-chain-tip))
        (inner-commit-block block commit-block-height withdrawal-root)
    )
)

(define-private (inner-transfer-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract transfer id sender recipient))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-nft-asset
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? nft-mint-contract mint-from-subnet id sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-nft-asset
        (nft-contract <nft-trait>)
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
            (no-owner (is-eq nft-owner none))
        )

        (if contract-owns-nft
            (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
            (if no-owner                (inner-mint-nft-asset nft-mint-contract id CONTRACT_ADDRESS recipient)                (err ERR_MINT_FAILED)
            )
        )
    )
)
(define-public (deposit-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts! (try! (inner-transfer-nft-asset nft-contract id sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print {
            event: ""deposit-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            sender: sender,
            subnet-contract-id: subnet-contract-id,
        })

        (ok true)
    )
)

(define-public (inner-withdraw-nft-asset
        (nft-contract <nft-trait>)
        (l2-contract principal)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-nft l2-contract id recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match nft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-nft-asset nft-contract mint-contract id recipient))
                    (as-contract (inner-transfer-without-mint-nft-asset nft-contract id recipient))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
            (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED)
        )

        (ok true)
    )
)
(define-public (withdraw-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let (            (l2-contract (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts!
            (try! (inner-withdraw-nft-asset
                nft-contract
                l2-contract
                id
                recipient
                withdrawal-id
                height
                nft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes
            ))
            (err ERR_TRANSFER_FAILED)
        )
        (print {
            event: ""withdraw-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            recipient: recipient
        })

        (ok true)
    )
)

(define-private (inner-transfer-without-mint-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
        )

        (asserts! contract-owns-nft (err ERR_NFT_NOT_OWNED_BY_CONTRACT))
        (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
    )
)

(define-private (inner-transfer-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract transfer amount sender recipient memo))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-ft-asset
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? ft-mint-contract mint-from-subnet amount sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-ft-asset
        (ft-contract <ft-trait>)
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract get-balance CONTRACT_ADDRESS))
            (contract-ft-balance (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-enough (>= contract-ft-balance amount))
            (amount-to-transfer (if contract-owns-enough amount contract-ft-balance))
            (amount-to-mint (- amount amount-to-transfer))
        )
        (asserts! (is-eq amount (+ amount-to-transfer amount-to-mint)) (err ERR_IN_COMPUTATION))

        (and
            (> amount-to-transfer u0)
            (try! (inner-transfer-ft-asset ft-contract amount-to-transfer CONTRACT_ADDRESS recipient memo))
        )
        (and
            (> amount-to-mint u0)
            (try! (inner-mint-ft-asset ft-mint-contract amount-to-mint CONTRACT_ADDRESS recipient))
        )

        (ok true)
    )
)
(define-public (deposit-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (memo (optional (buff 34)))
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET)))
        )        (asserts! (try! (inner-transfer-ft-asset ft-contract amount sender CONTRACT_ADDRESS memo)) (err ERR_TRANSFER_FAILED))

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""deposit-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                sender: sender,
                subnet-contract-id: subnet-contract-id,
            })
        )

        (ok true)
    )
)
(define-private (inner-withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))
        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-ft (contract-of ft-contract) amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match ft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-ft-asset ft-contract mint-contract amount recipient memo))
                    (as-contract (inner-transfer-ft-asset ft-contract amount CONTRACT_ADDRESS recipient memo))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (ok true)
    )
)
(define-public (withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (> amount u0) (err ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT))
        (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET))

        (asserts!
            (try! (inner-withdraw-ft-asset
                ft-contract
                amount
                recipient
                withdrawal-id
                height
                memo
                ft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes))
            (err ERR_TRANSFER_FAILED)
        )

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""withdraw-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                recipient: recipient,
            })
        )

        (ok true)
    )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-private (inner-transfer-stx (amount uint) (sender principal) (recipient principal))
    (let (
            (call-result (stx-transfer? amount sender recipient))
            (transfer-result (unwrap! call-result (err ERR_TRANSFER_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)
(define-public (deposit-stx (amount uint) (sender principal))
    (begin        (asserts! (try! (inner-transfer-stx amount sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print { event: ""deposit-stx"", sender: sender, amount: amount })

        (ok true)
    )
)

(define-read-only (leaf-hash-withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""stx"",
            amount: amount,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-nft
        (asset-contract principal)
        (nft-id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""nft"",
            nft-id: nft-id,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-ft
        (asset-contract principal)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""ft"",
            amount: amount,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)
(define-public (withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-stx amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts! (try! (as-contract (inner-transfer-stx amount tx-sender recipient))) (err ERR_TRANSFER_FAILED))

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))
        (print { event: ""withdraw-stx"", recipient: recipient, amount: amount })

        (ok true)
    )
)


(define-private (create-node-hash
        (curr-hash (buff 32))
        (sibling-hash (buff 32))
        (is-sibling-left-side bool)
    )
    (let (
            (concatted-hash (if is-sibling-left-side
                    (concat sibling-hash curr-hash)
                    (concat curr-hash sibling-hash)
                ))
          )

          (concat 0x01 concatted-hash)
    )
)
(define-private (hash-help
        (sibling {
            hash: (buff 32),
            is-left-side: bool,
        })
        (curr-node-hash (buff 32))
    )
    (let (
            (sibling-hash (get hash sibling))
            (is-sibling-left-side (get is-left-side sibling))
            (new-buff (create-node-hash curr-node-hash sibling-hash is-sibling-left-side))
        )
       (sha512/256 new-buff)
    )
)
(define-private (check-withdrawal-hashes
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (is-some (map-get? withdrawal-roots-map withdrawal-root)) (err ERR_INVALID_MERKLE_ROOT))
        (asserts!
            (is-none
             (map-get? processed-withdrawal-leaves-map
                       { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root }))
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (let ((calculated-withdrawal-root (fold hash-help sibling-hashes withdrawal-leaf-hash))
              (roots-match (is-eq calculated-withdrawal-root withdrawal-root)))
             (if roots-match
                (ok true)
                (err ERR_MERKLE_ROOT_DOES_NOT_MATCH))
        )
    )
)
(define-private (finish-withdraw
        (withdraw-info {
            withdrawal-leaf-hash: (buff 32),
            withdrawal-root-hash: (buff 32)
        })
    )
    (map-insert processed-withdrawal-leaves-map withdraw-info true)
)"
"Generate a Clarity smart contract for a non-fungible token (NFT) that implements the nft-trait interface, defines a token called funny-dog with a unique identifier of type uint, and includes functionality for minting new tokens, transferring ownership, and retrieving metadata such as the token URI and owner. Ensure the contract enforces ownership restrictions, prevents minting beyond a predefined collection limit, and uses a base URI template for token metadata. Include error handling for unauthorized actions, invalid transfers, and exceeding the collection size","Chain-of-Thought for Designing the Funny-Dog NFT Contract
First, I need to understand what I'm being asked to build: a Clarity smart contract for an NFT collection called ""funny-dog"" that implements the standard NFT trait interface. Let's break down the requirements and think about how to structure this.
I'll start by implementing the nft-trait interface since this is a standard requirement for NFT contracts in Clarity. This ensures my contract will be compatible with other applications in the Stacks ecosystem. The trait implementation should be the first line of the contract.
Next, I need to define the non-fungible token itself. Since we're creating a token called ""funny-dog"" with a unique identifier of type uint, I'll use the define-non-fungible-token command. This establishes the token domain and specifies that each token will be identified by an unsigned integer.
Wait, I need to track the last minted token ID to ensure uniqueness when minting new tokens. A data variable seems appropriate for this, starting at 0 since we haven't minted any tokens yet.
Okay, now I should consider ownership and permissions. The contract creator should have special privileges, like the ability to mint new tokens. I'll define a constant to store the contract owner's address (captured during contract deployment as tx-sender).
For robust error handling, I should define constants for different error types. I'll need errors for when non-owners attempt privileged operations, when users try to transfer tokens they don't own, and when someone tries to mint beyond our collection limit.
The requirement mentions metadata retrieval with a base URI template. I should store this as a data variable, allowing it to potentially be updated later. The URI will include a placeholder for the token ID.
Let's move on to core functionality. I need read-only functions to query information about tokens: the last token ID, a token's URI, and a token's owner. These are straightforward implementations using the appropriate getter functions.
For ownership transfers, I need a public function that checks if the sender is the current owner before allowing the transfer. This prevents unauthorized transfers and is a critical security feature.
Finally, I need a minting function that creates new tokens. This should verify the minter is the contract owner, check that we haven't exceeded the collection limit, perform the minting operation, update our token counter, and return the new token ID.
Wait, I notice I'm missing the COLLECTION_LIMIT constant. This should be defined to cap the total number of tokens that can be minted, as specified in the requirements.
The metadata function uses a base URI template, but I might want to enhance this to actually replace the {id} placeholder with the actual token ID. However, for a basic implementation, returning the template string provides the necessary information.
Let me think about additional security considerations... I should ensure that only the current owner can transfer a token, which I've done with the assertion in the transfer function. The mint function should restrict minting privileges to the contract owner, which I've also included.
This design approach satisfies all the requirements: implementing the nft-trait interface, defining a token with uint identifiers, providing minting, transfer, and metadata functionality, and including appropriate error handling and ownership restrictions.",";;title: funny dog
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-non-fungible-token funny-dog uint)

(define-data-var last-token-id uint u0)

(define-constant CONTRACT_OWNER tx-sender)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? funny-dog token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? funny-dog token-id sender recipient)
  )
)

(define-public (mint (recipient principal))
  (let ((token-id (+ (var-get last-token-id) u1)))
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    (try! (nft-mint? funny-dog token-id recipient))

    (var-set last-token-id token-id)
    (ok token-id)
  )
)"
"Generate a Clarity smart contract for an NFT marketplace that allows users to list NFTs for sale, cancel listings, and fulfill listings using either STX or fungible tokens. The contract should include error handling for scenarios like expired listings, unauthorized actions, and asset mismatches. Implement whitelisting for asset contracts, ensure proper validation of listing details, and define functions for transferring NFTs and fungible tokens securely. Focus on creating a robust and efficient implementation without including deployment or testing components.""




","First, I need to analyze what an NFT marketplace requires at its core. The fundamental operations would be listing items for sale, canceling listings, and allowing buyers to purchase items. Since we need to support both STX (native Stacks token) and other fungible tokens as payment methods, I'll need to implement separate fulfillment functions for each.
Let's start by defining the necessary traits. I'll need to use the NFT trait for handling non-fungible tokens and the FT trait for fungible tokens. This allows our contract to interact with any NFT or FT that conforms to these standard interfaces without knowing their specific implementation details.
Next, I should establish the state management for our marketplace. A map to store listings would be essential, where each listing needs to contain information about the seller (maker), potential specific buyer (taker), token ID, NFT contract, expiration time, price, and payment asset contract. I'll need a nonce counter to generate unique listing IDs.
I'll also need a way to whitelist asset contracts to ensure only verified contracts can be used in the marketplace. This helps prevent scams and adds a layer of security.
Then, I should think about error handling. There are various scenarios where operations might fail: expired listings, unauthorized actions, asset mismatches, etc. I'll define constants for these error codes to make the contract more readable and maintainable.
For the listing functionality, the contract needs to verify that the NFT asset is whitelisted, the price is greater than zero, and the payment asset (if specified) is whitelisted. After validation, the NFT should be transferred to the contract as escrow until the listing is fulfilled or canceled.
Wait, I should also implement helper functions for transferring NFTs and FTs. These abstractions will make the main functions cleaner and less error-prone.
The cancellation function needs to verify that the caller is the maker of the listing and that the NFT contract matches. If everything checks out, the listing is removed, and the NFT is returned to the maker.
For fulfillment, I need separate functions for STX and FT payments. Both should verify that the listing exists, the caller isn't the maker, the listing hasn't expired, and the asset contracts match. If a specific taker is set, only that principal can fulfill the listing. After validation, the NFT is transferred to the buyer, and the payment is sent to the seller.
Okay, let me think about additional security considerations. The contract should ensure that actions are performed by authorized parties. For example, only the contract owner should be able to modify the whitelist, and only the maker of a listing can cancel it.
Let's see, I should also ensure that when the contract transfers assets, it does so safely using appropriate error handling. The contract should verify all conditions before making any transfers to prevent partial executions that could lead to asset loss.
I might need to implement the as-contract function when the contract needs to transfer assets it holds. This ensures the contract acts as the sender for these operations.
Finally, the functions that read state without modifying it should be defined as read-only to optimize gas costs. This includes functions like getting listing details or checking if an asset is whitelisted.
Actually, I should also provide proper documentation and naming conventions to make the contract more maintainable. This is especially important for complex contracts like an NFT marketplace.
Therefore, my implementation would include defining relevant traits, creating data structures for listings and whitelisting, implementing secure transfer functions, and providing comprehensive error handling. The contract would support listing assets with optional specific takers, expiration times, and different payment methods. It would ensure that all operations are secure, validated, and performed by authorized parties.",";;title: nft-marketplace
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
  (default-to true (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    (var-set listing-nonce (+ listing-id u1))
    (ok listing-id)
  )
)

(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    (map-delete listings listing-id)
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)

(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)"
"Generate a Clarity smart contract for a decentralized marketplace called 'tiny-market' that allows users to list, cancel, and fulfill NFT asset trades. The contract should include functionality for whitelisting asset contracts, managing listings with details like maker, taker, token ID, expiry, and price, and enforcing rules such as expiration checks, price validation, and payment asset restrictions. It should support trading using STX or fungible tokens (FTs), enforce proper permissions for actions like canceling or fulfilling listings, and validate asset and payment contract matches. Ensure the use of traits for NFT and FT standards, implement error handling for common issues like unauthorized access or expired listings, and provide helper functions for transferring assets securely.","First, we need to design a smart contract that enables users to list, cancel, and fulfill NFT trades in a decentralized marketplace. The contract must support trading via STX or fungible tokens (FTs) while ensuring security through proper validations and error handling. Given this, we must incorporate mechanisms to enforce expiration checks, price validation, and contract whitelisting for NFTs and payment assets.

Wait, before diving into the core functionality, we must define and utilize traits for NFTs and FTs, ensuring compatibility with Clarity's standards. By using use-trait, we allow our contract to interact with external NFT and FT implementations while enforcing adherence to the required transfer functions. Next, we establish a contract-owner to manage administrative functions like asset contract whitelisting.

Let’s see, a core aspect of the marketplace is maintaining listings. We define a listings map where each listing is uniquely identified by an integer key. Each entry should store critical details: the maker (who lists the asset), an optional taker (if a specific buyer is required), token ID, NFT contract address, expiry timestamp, price, and an optional payment asset contract. To track unique listings, we maintain a listing-nonce variable, ensuring that each listing receives a unique ID. Additionally, to prevent unauthorized assets from being traded, we introduce a whitelisted-asset-contracts map, allowing only approved contracts to be used for trading.

Okay, then we need a function to manage contract whitelisting. A read-only function is-whitelisted determines if a given contract is allowed for trading. Meanwhile, set-whitelisted lets the contract owner modify this whitelist, ensuring only authorized contracts can participate in the marketplace. To support asset transfers, we define helper functions: transfer-nft and transfer-ft, which delegate transfer logic to the respective asset contracts via contract-call?, enforcing security and compatibility.

Maybe the most critical functionality is list-asset. This function allows a user to list an NFT for trade. First, we ensure the NFT contract is whitelisted. Then, we validate that the expiry timestamp is in the future and that the price is greater than zero. If a payment asset is specified, it must also be whitelisted. After these checks, we transfer the NFT to the contract's custody, ensuring that the seller cannot reclaim or modify the asset before trade completion. Finally, we store the listing details and increment listing-nonce for future listings.

Next, for retrieval purposes, we define get-listing, a simple read-only function that returns a listing's details given its ID. This function enables users to inspect available listings before proceeding with transactions. Now, let’s address cancellations. The cancel-listing function allows the maker to remove a listing before it is fulfilled. First, we verify that the listing exists and that the caller is the maker. Then, we check that the stored NFT contract matches the provided contract to prevent mismatches. If all checks pass, we delete the listing from storage and return the NFT to its original owner.

Might there be any complications in fulfilling listings? Yes, we must enforce strict validation to prevent unauthorized transactions. The assert-can-fulfil function ensures that the buyer is not the same as the maker, the taker (if specified) matches the caller, the listing has not expired, and the correct NFT and payment asset contracts are used. This function centralizes validation logic, reducing redundancy in fulfillment functions.

Finally, we implement two fulfillment functions: fulfil-listing-stx and fulfil-listing-ft. The former is used when the buyer pays in STX, while the latter is used for FT payments. Both follow a structured process: they retrieve the listing, validate fulfillment conditions, transfer the NFT to the buyer, transfer the payment to the seller, and remove the listing upon successful execution. The structured use of try! ensures that if any step fails, the entire transaction is reverted, preventing asset loss or unintended transfers.

In conclusion, this contract is designed to facilitate secure and flexible NFT trading while enforcing strict validation to prevent fraud and errors. It achieves this through robust state management, proper whitelisting mechanisms, and secure asset transfer logic.",";; title:tiny-market
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant err-expiry-in-past (err u1000))
(define-constant err-price-zero (err u1001))

;; cancelling and fulfiling errors
(define-constant err-unknown-listing (err u2000))
(define-constant err-unauthorised (err u2001))
(define-constant err-listing-expired (err u2002))
(define-constant err-nft-asset-mismatch (err u2003))
(define-constant err-payment-asset-mismatch (err u2004))
(define-constant err-maker-taker-equal (err u2005))
(define-constant err-unintended-taker (err u2006))
(define-constant err-asset-contract-not-whitelisted (err u2007))
(define-constant err-payment-contract-not-whitelisted (err u2008))

(define-map listings
	uint
	{
		maker: principal,
		taker: (optional principal),
		token-id: uint,
		nft-asset-contract: principal,
		expiry: uint,
		price: uint,
		payment-asset-contract: (optional principal)
	}
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
	(default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
	(begin
		(asserts! (is-eq contract-owner tx-sender) err-unauthorised)
		(ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
	)
)

(define-private (transfer-nft (token-contract <nft-trait>) (token-id uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft (token-contract <ft-trait>) (amount uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset (nft-asset-contract <nft-trait>) (nft-asset {taker: (optional principal), token-id: uint, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(let ((listing-id (var-get listing-nonce)))
		(asserts! (is-whitelisted (contract-of nft-asset-contract)) err-asset-contract-not-whitelisted)
		(asserts! (> (get expiry nft-asset) block-height) err-expiry-in-past)
		(asserts! (> (get price nft-asset) u0) err-price-zero)
		(asserts! (match (get payment-asset-contract nft-asset) payment-asset (is-whitelisted payment-asset) true) err-payment-contract-not-whitelisted)
		(try! (transfer-nft nft-asset-contract (get token-id nft-asset) tx-sender (as-contract tx-sender)))
		(map-set listings listing-id (merge {maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract)} nft-asset))
		(var-set listing-nonce (+ listing-id u1))
		(ok listing-id)
	)
)

(define-read-only (get-listing (listing-id uint))
	(map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(maker (get maker listing))
		)
		(asserts! (is-eq maker tx-sender) err-unauthorised)
		(asserts! (is-eq (get nft-asset-contract listing) (contract-of nft-asset-contract)) err-nft-asset-mismatch)
		(map-delete listings listing-id)
		(as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
	)
)

(define-private (assert-can-fulfil (nft-asset-contract principal) (payment-asset-contract (optional principal)) (listing {maker: principal, taker: (optional principal), token-id: uint, nft-asset-contract: principal, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(begin
		(asserts! (not (is-eq (get maker listing) tx-sender)) err-maker-taker-equal)
		(asserts! (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true) err-unintended-taker)
		(asserts! (< block-height (get expiry listing)) err-listing-expired)
		(asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) err-nft-asset-mismatch)
		(asserts! (is-eq (get payment-asset-contract listing) payment-asset-contract) err-payment-asset-mismatch)
		(ok true)
	)
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (stx-transfer? (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)

(define-public (fulfil-listing-ft (listing-id uint) (nft-asset-contract <nft-trait>) (payment-asset-contract <ft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) (some (contract-of payment-asset-contract)) listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)"