Question,CoT,Response
"Create a detailed Clarity smart contract for the Stacks blockchain that implements a decentralized lending protocol allowing users to deposit STX tokens, borrow against their collateral, and earn yield. The contract should include functionality for managing deposits with user-specific balances, implementing a loan system with dynamic interest calculations based on block height, and distributing yield to depositors. Incorporate a 50% loan-to-value ratio limit, a 10% interest rate, and proper error handling for various scenarios including excessive borrowing and repayment issues. Include comprehensive read-only functions for querying user balances and outstanding loan amounts, and ensure all STX transfers are handled securely using the appropriate contract-based transaction patterns. Provide detailed comments explaining the purpose and functionality of each data structure and function in the contract.","I'll generate a detailed Chain-of-Thought explaining the reasoning process behind the Clarity smart contract implementation.

Let's start by understanding what we need to build: a decentralized lending protocol on the Stacks blockchain with STX tokens as the primary asset. The core functionality requires deposit management, borrowing against collateral, loan processing, and yield distribution.

First, the data structure design. The contract needs to track two primary types of data: deposits and loans. For deposits, a map structure is used to associate user principals (blockchain addresses) with their deposit amounts. This approach provides user-specific accounting while maintaining the simplicity needed for a lending protocol. Similarly, loans are tracked with a separate map associating borrowers with both their loan amounts and the block height of their last interaction, which is crucial for interest calculations.

Next, global state variables are defined. The total-deposits tracks the aggregate deposits in the contract, which is necessary for calculating proportional yields. The pool-reserve holds accumulated interest payments, effectively serving as the yield source for depositors. The loan-interest-rate is set at 10% as specified in the requirements.

Error constants are defined to handle various failure scenarios, providing clear feedback to users when operations fail. This follows best practices for smart contract development where error handling is crucial for security and user experience.

Moving to the functional implementation, the deposit function allows users to add STX to the contract. It uses stx-transfer? to move tokens from the user to the contract, updates the user's balance in the deposits map, and increases the total-deposits counter. The function uses a combination of let bindings and map operations to manage state transitions safely.

The borrow function implements the 50% loan-to-value ratio requirement. It calculates the allowed borrowing limit based on half the user's deposit (/ user-deposit u2), ensuring users can't borrow more than 50% of their collateral value. Before issuing new loans, it calculates any accrued interest on existing loans using the calculate-accrued-interest private function. The function then updates the loan record with the new total and the current block height for future interest calculations.

For repayments, the repay function first calculates the total amount due including accrued interest. It then ensures users don't overpay, transfers the repayment amount to the contract, and updates the loan record. Importantly, it adds the interest portion to the pool-reserve, making it available for yield distribution.

The claim-yield function distributes accumulated interest to depositors proportionally based on their share of the total deposits. This implements the yield earning requirement in the original specification. The calculation (/ (* (var-get pool-reserve) user-deposit) (var-get total-deposits)) determines each user's fair share of the yield.

The read-only functions get-balance-by-sender, get-balance, and get-amount-owed provide transparency, allowing users to query their current positions and obligations without modifying the contract state. This supports the requirement for comprehensive query functions.

Finally, the calculate-accrued-interest private function implements the dynamic interest calculation based on block height as required. It determines the elapsed time in blocks since the last loan interaction and calculates interest proportionally. The calculation (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000) applies the 10% interest rate over the elapsed blocks.

Wait, there seems to be an error in the borrow function. The new-loan calculation is incomplete - it only adds the amount without including the existing loan or accrued interest. This might lead to incorrect loan accounting.

Overall, the implementation adheres to the required functionality: deposits with user-specific balances, a loan system with dynamic interest calculations, yield distribution, a 50% loan-to-value ratio, a 10% interest rate, and comprehensive error handling. The contract includes both the required functionality and the necessary read-only functions for querying balances and loan amounts.",";; Define the contract's data variables

;; Maps a user's principal address to their deposited amount.
(define-map deposits { owner: principal } { amount: uint })

;; Maps a borrower's principal address to their loan details: amount and the last interaction block.
(define-map loans principal { amount: uint, last-interaction-block: uint })

;; Holds the total amount of deposits in the contract, initialized to 0.
(define-data-var total-deposits uint u0)

;; Represents the reserve funds in the pool, initialized to 0.
(define-data-var pool-reserve uint u0)

;; The interest rate for loans, represented as 10% (out of a base of 100).
(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate

;; Error constants for various failure scenarios.
(define-constant err-no-interest (err u100))
(define-constant err-overpay (err u200))
(define-constant err-overborrow (err u300))

;; Public function for users to deposit STX into the contract.
;; Updates their balance and the total deposits in the contract.
(define-public (deposit (amount uint))
    (let (
        ;; Fetch the current balance or default to 0 if none exists.
        (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        )
        ;; Transfer the STX from sender = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM"" to recipient = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.stx-defi (ie: contract identifier on the chain!)"".
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's deposit amount in the map.
        (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
        ;; Update the total deposits variable.
        (var-set total-deposits (+ (var-get total-deposits) amount))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to borrow STX based on their deposits.
(define-public (borrow (amount uint))
    (let (
        ;; Fetch user's deposit or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)
        (allowed-borrow (/ user-deposit u2))
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
        ;; Calculate the new loan total after borrowing additional amount.
        (new-loan (+ amount))
    )
        ;; Ensure the requested borrow amount does not exceed the allowed amount.
        (asserts! (<= new-loan allowed-borrow) err-overborrow)
        ;; Transfer the borrowed STX to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? amount tx-sender recipient)))
        )
        ;; Update the user's loan details in the map.
        (map-set loans tx-sender { amount: new-loan, last-interaction-block: burn-block-height })
        ;; Return success.
        (ok true)
    )
)

;; Read-only function to get the total balance by tx-sender
(define-read-only (get-balance-by-sender)
    (ok (map-get? deposits { owner: tx-sender }))
)

;; Read-only function to get the total balance 
(define-read-only (get-balance)
    (ok (var-get total-deposits))
)

;; Read-only function to get the total amount owed by the user.
(define-read-only (get-amount-owed)
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
    )
    ;; Return the total amount due.
    (ok total-due)
    )
)

;; Public function for users to repay their STX loans.
(define-public (repay (amount uint))
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest since the last interaction.
        (accrued-interest (unwrap! (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)) err-no-interest))
        ;; Calculate the total amount due including accrued interest.
        (total-due (+ (get amount current-loan-details) accrued-interest))
    )
        ;; Ensure the repayment amount is not more than the total due.
        (asserts! (>= total-due amount) err-overpay)
        ;; Transfer the repayment amount from the user to the contract.
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's loan details in the map with the new total due.
        (map-set loans tx-sender { amount: (- total-due amount), last-interaction-block: burn-block-height })
        ;; Update the pool reserve with the paid interest.
        (var-set pool-reserve (+ (var-get pool-reserve) accrued-interest))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to claim their yield based on the pool reserve and their deposits.
(define-public (claim-yield)
    (let (
        ;; Fetch user's deposit amount or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the yield amount based on user's share of the pool.
        (yield-amount (/ (* (var-get pool-reserve) user-deposit) (var-get total-deposits)))
    )
        ;; Transfer the yield amount from the contract to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? yield-amount tx-sender recipient)))
        )
        ;; Update the pool reserve by subtracting the claimed yield.
        (var-set pool-reserve (- (var-get pool-reserve) yield-amount))
        ;; Return success.
        (ok true)
    )
)

;; Private function to calculate the accrued interest on a loan.
(define-private (calculate-accrued-interest (principal uint) (start-block uint))
    (let (
        ;; Calculate the number of blocks elapsed since the last interaction.
        (elapsed-blocks (- burn-block-height start-block))
        ;; Calculate the interest based on the principal, rate, and elapsed time.
        (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
        ;; Ensure the loan started in the past (not at block 0).
        (asserts! (not (is-eq start-block u0)) (ok u0))
        ;; Return the calculated interest.
       (ok interest)
    )
)"
"Create a Clarity smart contract for the Stacks blockchain that implements a minimal NFT marketplace allowing users to list NFTs for sale with configurable parameters including token ID, expiry, price, payment asset type (STX or SIP010 tokens), and optional intended buyer. Include functionality for whitelisting contracts, listing assets, canceling listings, and fulfilling purchases with both STX and fungible tokens. Implement proper error handling, security checks, and use the standard NFT and fungible token traits for compatibility.","## Chain-of-Thought Analysis: NFT Marketplace Smart Contract

First, I need to understand the requirements for this smart contract. We need to create a marketplace for NFTs on the Stacks blockchain where users can list their tokens with configurable parameters. These parameters include token ID, expiry, price, payment type, and optional intended buyer. The contract should also handle whitelisting, asset management, and transaction processing with both STX and fungible tokens.

Wait, before designing the implementation, I should consider the technical constraints of the Clarity language and Stacks blockchain. Clarity is a decidable language designed for financial use cases, with strict typing and no reentrancy vulnerabilities. This makes it suitable for a marketplace where asset ownership and payments need to be securely managed.

Let's see, one of the fundamental design decisions is how to structure the state storage for listings. The implemented solution uses a map with unique integer IDs as keys, which provides efficient lookup. Each listing needs to store all configurable parameters, so the map value contains fields for the maker, optional taker, token ID, NFT contract, expiry, price, and payment asset contract. This directly maps to the requirements for configurable parameters.

Then, we need a mechanism to generate unique IDs for listings. The chosen approach uses a nonce variable that increments with each new listing. This is a simple yet effective way to ensure each listing has a unique identifier without collisions.

Okay, security is a critical concern for a marketplace handling valuable assets. The contract implements a whitelist mechanism to control which contracts can interact with the marketplace. This prevents potentially malicious contracts from being used, adding a layer of security. The whitelist is managed through a separate map and controlled by the contract owner, following the principle of least privilege.

The error handling approach is comprehensive, with distinct error codes for different failure scenarios. This makes debugging easier and provides clear feedback to users about why operations failed. The errors are logically organized into listing-related and fulfillment-related categories.

Now, for the core functionality, the contract needs to enable listing, viewing, canceling, and fulfilling purchases. The list-asset function incorporates several validation checks: ensuring the contract is whitelisted, the expiry is valid, the price is non-zero, and the payment contract is approved. After validation, it transfers the NFT to the marketplace contract and records the listing details.

The get-listing function is straightforward, simply retrieving listing information by ID. This read-only function is essential for marketplace transparency, allowing users to view listing details.

For cancellation, the cancel-listing function includes critical authorization checks to ensure only the original maker can cancel a listing. It also verifies the NFT contract matches the one in the listing before returning the NFT to the maker and removing the listing from the map.

The fulfillment process is split into two functions: one for STX payments and another for fungible token payments. Both share validation logic through the assert-can-fulfil function, which checks that the buyer isn't the maker, the intended taker is valid, the listing isn't expired, and the asset contracts match. This validation ensures the integrity of the transaction.

May I emphasize the smart use of helper functions for token transfers. The transfer-nft and transfer-ft functions abstract the specifics of token transfers, making the code more maintainable and reducing duplication. This is particularly important given that the contract handles both NFT and fungible token transfers.

The contract also leverages the as-contract context when transferring assets. This is a crucial security feature in Clarity that allows the contract to act on behalf of itself, ensuring proper authorization during token transfers.

Let me look at how the contract handles the payment process. For STX payments, it uses the built-in stx-transfer? function, while for fungible tokens, it uses the transfer-ft helper function. Both approaches ensure that payment is sent from the buyer to the seller, completing the exchange.

I notice that the contract doesn't include a commission mechanism for the marketplace. This keeps the implementation minimal as required, though in a production environment, a fee structure might be added.

The transaction flow is well-designed: first validate all conditions, then transfer the NFT to the buyer, then process the payment, and finally update the state by removing the listing. This sequence ensures that transactions are atomic and prevents partial execution.

Then, thinking about edge cases, the contract handles scenarios like expired listings, unauthorized attempts to cancel, and unexpected asset contracts. This comprehensive error handling makes the contract robust and secure.

In conclusion, the smart contract elegantly addresses all the requirements by implementing a clear data structure for listings, secure whitelisting mechanisms, comprehensive validation checks, and separate functions for different payment types. The design follows good software engineering principles like separation of concerns, proper error handling, and code reuse, resulting in a minimal yet complete NFT marketplace implementation.",";; A tiny NFT marketplace that allows users to list NFT for sale. They can specify the following:
;; - The NFT token to sell.
;; - Listing expiry in block height.
;; - The payment asset, either STX or a SIP010 fungible token.
;; - The NFT price in said payment asset.
;; - An optional intended taker. If set, only that principal will be able to fulfil the listing.
;;
;; Source: https://github.com/clarity-lang/book/tree/main/projects/tiny-market

(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

;; cancelling and fulfiling errors
(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

;; Define a map data structure for the asset listings
(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

;; Used for unique IDs for each listing
(define-data-var listing-nonce uint u0)

;; This marketplace requires any contracts used for assets or payments to be whitelisted
;; by the contract owner of this (marketplace) contract.
(define-map whitelisted-asset-contracts principal bool)

;; Function that checks if the given contract has been whitelisted.
(define-read-only (is-whitelisted (asset-contract principal))
  (default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

;; Only the contract owner of this (marketplace) contract can whitelist an asset contract.
(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

;; Internal function to transfer an NFT asset from a sender to a given recipient.
(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

;; Internal function to transfer fungible tokens from a sender to a given recipient.
(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

;; Public function to list an asset along with its contract
(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    ;; Verify that the contract of this asset is whitelisted
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    ;; Verify that the asset is not expired
    (asserts! (> (get expiry nft-asset) burn-block-height) ERR_EXPIRY_IN_PAST)
    ;; Verify that the asset price is greater than zero
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    ;; Verify that the contract of the payment is whitelisted
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    ;; Transfer the NFT ownership to this contract's principal
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    ;; List the NFT in the listings map
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    ;; Increment the nonce to use for the next unique listing ID
    (var-set listing-nonce (+ listing-id u1))
    ;; Return the created listing ID
    (ok listing-id)
  )
)

;; Public read-only function to retrieve a listing by its ID
(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

;; Public function to cancel a listing using an asset contract.
;; This function can only be called by the NFT's creator, and must use the same asset contract that
;; the NFT uses.
(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    ;; Verify that the caller of the function is the creator of the NFT to be cancelled
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    ;; Verify that the asset contract to use is the same one that the NFT uses
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    ;; Delete the listing
    (map-delete listings listing-id)
    ;; Transfer the NFT from this contract's principal back to the creator's principal
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

;; Private function to validate that a purchase can be fulfilled
(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    ;; Verify that the buyer is not the same as the NFT creator
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    ;; Verify the buyer has been set in the listing metadata as its `taker`
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    ;; Verify the listing for purchase is not expired
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    ;; Verify the asset contract used to purchase the NFT is the same as the one set on the NFT
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    ;; Verify the payment contract used to purchase the NFT is the same as the one set on the NFT
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

;; Public function to purchase a listing using STX as payment
(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the STX payment from the purchaser to the creator of the NFT
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)

;; Public function to purchase a listing using another fungible token as payment
(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the tokens as payment from the purchaser to the creator of the NFT
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)"
"Create a Clarity smart contract for the Stacks Blockchain that implements the SIP-009 NFT standard. The contract should define a non-fungible token named ""Your-NFT-Name"" that tracks the last minted token ID and enforces a collection limit of 1000 tokens. Include constants for the contract owner (set to tx-sender), appropriate error codes for ownership verification and collection limits, and a configurable base URI for token metadata. Implement all required SIP-009 functions including get-last-token-id, get-token-uri, get-owner, and a transfer function with sender verification. Also create a mint function that can only be called by the contract owner, enforces the collection limit, mints tokens to a specified recipient, increments the token ID counter, and returns the newly minted token ID. Ensure proper error handling and assertions throughout all functions to maintain security and expected behavior.","First, I need to implement a Clarity smart contract for the Stacks blockchain that follows the SIP-009 NFT standard. To ensure compatibility with other applications and services, I'll start by implementing the required trait from its canonical location. This establishes that my contract adheres to the expected interface and behavior of NFTs on the Stacks blockchain.

Next, I need to define the actual NFT token. I'll use ""Your-NFT-Name"" as a placeholder that can be customized later, and specify that token IDs will be represented as unsigned integers. This is a common pattern for NFTs, where each token has a unique numerical identifier.

Let's see, I need a way to track which tokens have been minted. The simplest approach is to use a counter variable that gets incremented with each mint. I'll define a data variable initialized to zero that will store the last token ID that was created. This helps maintain the state of the contract and ensures token IDs are sequential and unique.

Then, I need to set up some important constants. The contract owner should be whoever deploys the contract, so using tx-sender makes sense here. I also need to enforce a collection limit of 1000 tokens as specified, so I'll define that as a constant. For proper error handling, I should define specific error codes for common failure scenarios like unauthorized access attempts or hitting the collection limit.

Wait, I also need somewhere to store metadata about the tokens. Following best practices, I'll define a base URI string variable that can point to the metadata for all tokens in the collection. This URI template can include a placeholder for the token ID, allowing each token to have its own metadata while sharing the same base path.

Okay, now I need to implement the required SIP-009 functions. First is get-last-token-id which simply returns the current counter value - this lets applications know how many tokens have been minted. Next is get-token-uri which returns the URI for a specific token's metadata. Then get-owner to check who owns a particular token, which uses the built-in nft-get-owner? function. Finally, the transfer function that allows owners to send their tokens to others.

For the transfer function, security is critical. I must verify that the caller is actually the owner of the token being transferred. This prevents unauthorized transfers and protects users' assets. I'll use an assertion to check that the transaction sender matches the specified sender parameter, returning an error if they don't match.

Now for the mint function, which needs several safeguards. First, I should calculate the new token ID by incrementing the last one. Then I must check that we haven't exceeded the collection limit, otherwise return an error. I also need to verify that only the contract owner can call this function. If all checks pass, I can mint the token to the specified recipient, update the last token ID counter, and return the new token ID.

Finally, I should make sure all functions return properly formatted responses. For read-only functions, wrapping the result in an (ok ...) tuple ensures compatibility with the SIP-009 standard. For state-changing functions, using try! for operations that might fail allows for proper error propagation, while asserts! provides clean permission checking and validation. This approach to error handling makes the contract more robust and user-friendly.",";; This contract implements the SIP-009 community-standard Non-Fungible Token trait
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

;; Define the NFT's name
(define-non-fungible-token Your-NFT-Name uint)

;; Keep track of the last minted token ID
(define-data-var last-token-id uint u0)

;; Define constants
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COLLECTION_LIMIT u1000) ;; Limit to series of 1000

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

;; SIP-009 function: Get the last minted token ID.
(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

;; SIP-009 function: Get link where token metadata is hosted
(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

;; SIP-009 function: Get the owner of a given token
(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? Your-NFT-Name token-id))
)

;; SIP-009 function: Transfer NFT token to another owner.
(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    ;; #[filter(sender)]
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? Your-NFT-Name token-id sender recipient)
  )
)

;; Mint a new NFT.
(define-public (mint (recipient principal))
  ;; Create the new token ID by incrementing the last minted ID.
  (let ((token-id (+ (var-get last-token-id) u1)))
    ;; Ensure the collection stays within the limit.
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    ;; Only the contract owner can mint.
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    ;; Mint the NFT and send it to the given recipient.
    (try! (nft-mint? Your-NFT-Name token-id recipient))

    ;; Update the last minted token ID.
    (var-set last-token-id token-id)
    ;; Return a success status and the newly minted NFT ID.
    (ok token-id)
  )
)"
"Generate a Clarity smart contract for Stacks Blockchain that implements a SIP-013 semi-fungible token with both 'sip013-semi-fungible-token-trait' and 'sip013-transfer-many-trait' from 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V'. The contract should define a fungible token, a non-fungible token ID system, and maps for balances and supplies. Include functions for transfers (single and batch, with and without memos), balance queries, supply tracking, and owner-only minting. Implement proper error handling, access controls, and event logging while maintaining token ID ownership using the non-fungible token tagging system.","First, I notice there's a significant mismatch between the question and the provided code. The question asks for a SIP-009 NFT standard implementation with specific features like a collection limit of 1000 tokens and a ""Your-NFT-Name"" token. However, the code implements a SIP-013 semi-fungible token standard instead, which is fundamentally different.

Let's see what's happening here. The code implements two traits: 'sip013-semi-fungible-token-trait' and 'sip013-transfer-many-trait' rather than the SIP-009 NFT standard mentioned in the question. This indicates a complete shift in the token standard being implemented.

The provided code creates a semi-fungible token system which combines aspects of both fungible and non-fungible tokens. It defines a fungible token called ""semi-fungible-token"" and a non-fungible token called ""semi-fungible-token-id"" with a composite key structure. This design allows tracking ownership of specific token IDs with varying amounts, unlike the pure NFT model requested in the question.

Wait, there's also no implementation of the collection limit of 1000 tokens mentioned in the question. Instead, the code provides a general-purpose implementation that can mint any amount of any token ID without restrictions. This further confirms the divergence from the requirements.

Then we have the storage structure. The code uses data maps to track token balances and supplies, which makes sense for a semi-fungible token where users can own multiple units of the same token ID. This differs from a pure NFT where ownership is binary - either you own it or you don't.

The error handling in the code addresses ownership verification with 'err-owner-only' and balance checks with 'err-insufficient-balance', but nothing specifically about collection limits as requested in the question. The code has proper sender verification in the transfer function, which aligns with general security practices mentioned in the question.

Okay, examining the functions, the code implements all required SIP-013 functions, including balance queries, supply tracking, and transfer capabilities. It even includes batch transfer functionality through 'transfer-many' and 'transfer-many-memo', which wasn't mentioned in the original question but is part of the SIP-013 standard.

The mint function does include owner-only restrictions as requested, but it doesn't increment any token ID counter or enforce collection limits. Instead, it allows the owner to specify any token ID and amount during minting, which is appropriate for semi-fungible tokens but not for the sequential NFT minting requested.

Maybe the most telling discrepancy is that there's no implementation of 'get-last-token-id' function requested in the question. This function would be critical for an NFT with sequential minting but is unnecessary in a semi-fungible token implementation.

The code does include a clever 'tag-nft-token-id' helper function that manages the non-fungible aspects of token ownership, creating a hybrid token system that can track both quantity (fungible aspect) and specific ownership (non-fungible aspect).

In conclusion, the provided code is a well-structured implementation of the SIP-013 semi-fungible token standard, but it doesn't address the requirements specified in the question, which asked for a SIP-009 NFT implementation with sequential minting and collection limits.","(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-semi-fungible-token-trait.sip013-semi-fungible-token-trait)
(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-transfer-many-trait.sip013-transfer-many-trait)

(define-fungible-token semi-fungible-token)
(define-non-fungible-token semi-fungible-token-id {token-id: uint, owner: principal})
(define-map token-balances {token-id: uint, owner: principal} uint)
(define-map token-supplies uint uint)

(define-constant contract-owner tx-sender)

(define-constant err-owner-only (err u100))
(define-constant err-insufficient-balance (err u1))
(define-constant err-invalid-sender (err u4))

(define-private (set-balance (token-id uint) (balance uint) (owner principal))
	(map-set token-balances {token-id: token-id, owner: owner} balance)
)

(define-private (get-balance-uint (token-id uint) (who principal))
	(default-to u0 (map-get? token-balances {token-id: token-id, owner: who}))
)

(define-read-only (get-balance (token-id uint) (who principal))
	(ok (get-balance-uint token-id who))
)

(define-read-only (get-overall-balance (who principal))
	(ok (ft-get-balance semi-fungible-token who))
)

(define-read-only (get-total-supply (token-id uint))
	(ok (default-to u0 (map-get? token-supplies token-id)))
)

(define-read-only (get-overall-supply)
	(ok (ft-get-supply semi-fungible-token))
)

(define-read-only (get-decimals (token-id uint))
	(ok u0)
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

;; #[allow(unchecked_params)]
(define-public (transfer (token-id uint) (amount uint) (sender principal) (recipient principal))
	(let
		(
			(sender-balance (get-balance-uint token-id sender))
		)
		(asserts! (or (is-eq sender tx-sender) (is-eq sender contract-caller)) err-invalid-sender)
		(asserts! (<= amount sender-balance) err-insufficient-balance)
		(try! (ft-transfer? semi-fungible-token amount sender recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: sender}))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (- sender-balance amount) sender)
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(print {type: ""sft_transfer"", token-id: token-id, amount: amount, sender: sender, recipient: recipient})
		(ok true)
	)
)

(define-public (transfer-memo (token-id uint) (amount uint) (sender principal) (recipient principal) (memo (buff 34)))
	(begin
		(try! (transfer token-id amount sender recipient))
		(print memo)
		(ok true)
	)
)

(define-private (transfer-many-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer (get token-id item) (get amount item) (get sender item) (get recipient item)) prev-err previous-response)
)

(define-public (transfer-many (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal})))
	(fold transfer-many-iter transfers (ok true))
)

(define-private (transfer-many-memo-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer-memo (get token-id item) (get amount item) (get sender item) (get recipient item) (get memo item)) prev-err previous-response)
)

(define-public (transfer-many-memo (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)})))
	(fold transfer-many-memo-iter transfers (ok true))
)

(define-public (mint (token-id uint) (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (ft-mint? semi-fungible-token amount recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(map-set token-supplies token-id (+ (unwrap-panic (get-total-supply token-id)) amount))
		(print {type: ""sft_mint"", token-id: token-id, amount: amount, recipient: recipient})
		(ok true)
	)
)

(define-private (tag-nft-token-id (nft-token-id {token-id: uint, owner: principal}))
	(begin
		(and
			(is-some (nft-get-owner? semi-fungible-token-id nft-token-id))
			(try! (nft-burn? semi-fungible-token-id nft-token-id (get owner nft-token-id)))
		)
		(nft-mint? semi-fungible-token-id nft-token-id (get owner nft-token-id))
	)
)"
"Create a Clarity smart contract for a bridged stablecoin token on the Stacks blockchain. The contract should implement the SIP-10 token standard and additional traits for bridging functionality. Include administrative features such as ownership control, minting allowances, token pausing capability, and address banning. The token should have configurable metadata (name, symbol, URI) and precise decimal handling. Implement core token operations (transfer, mint, burn) with appropriate security checks and error handling. Add an extension system allowing authorized contracts to interact with the token through a controlled interface. Ensure all operations emit relevant events for tracking and include comprehensive error codes. The initial token state should be paused until explicitly activated by the contract owner, and all sensitive functions should verify caller authorization before execution.","First, the contract starts by implementing multiple traits which establish its interfaces. The SIP-10 trait is crucial as it defines the standard token interface on Stacks. The additional traits for bridging and extension capabilities allow the token to interact with external systems and be extended with new functionality over time.

The contract then defines a series of error constants with descriptive codes. This approach centralizes error handling and makes the code more maintainable. The constants use a consistent numbering scheme starting at u10000, which allows for clear error identification when issues occur.

Let's see how the state management is implemented. The contract uses a combination of data variables and maps to store its state. Token metadata is stored in string variables with appropriate size limits. The core token balance data is handled through the built-in fungible-token type, which provides atomic operations and consistency guarantees. Maps are used for tracking minter allowances and banned addresses, which enables efficient lookups.

Wait, we need to consider the security model. The contract implements a robust ownership system where sensitive operations require the caller to be the contract owner. This pattern appears consistently throughout the code. The token also starts in a paused state (token-pause is initially true), requiring explicit activation by the owner before transfers can occur.

The minting system uses a dual-map approach to both define allowances and track usage. This prevents minters from exceeding their allowed limits and provides an audit trail. Each mint operation updates the tracking map, ensuring that accumulated mints don't exceed the allowance.

Okay, then the SIP-10 implementation provides the standard interface functions that other contracts expect. These read-only functions allow external contracts to query metadata and balances. The transfer function notably delegates to an internal transfer! function that includes additional checks.

Looking at the administrative functions, they all follow a consistent pattern: verify authorization, perform the operation, emit an event, and return success. This consistency makes the contract more predictable and easier to reason about. The events emitted through the print function enable off-chain monitoring of important state changes.

The address banning system provides a way to restrict malicious users from transferring tokens. The transfer! function checks both sender and recipient against the banned addresses map, preventing sanctioned addresses from using the token.

The extension system is particularly sophisticated. It allows the token to interact with authorized external contracts in a controlled manner. Extensions must be explicitly authorized by the owner, and there's a mechanism to revoke this authorization if needed. The run-extension! function uses as-contract to execute extension code with the token's context, allowing controlled access to internal functions.

The error handling throughout the code is comprehensive. Each function performs appropriate validation before executing its core logic. The use of unwrap! and match expressions handles potential failures in a controlled way. This prevents inconsistent states and improves security.

Finally, the token implements memo support, which is important for compliance and record-keeping in financial applications. All transfer operations support an optional memo field that gets emitted in events, allowing off-chain systems to track additional context for transactions.",";; title: circle-usdce-token
;; version:
;; summary:
;; description:

(impl-trait 'SP2J933XB2CP2JQ1A4FGN8JA968BBG3NK3EKZ7Q9F.hk-tokens-v1.sip10-token)
(impl-trait .token-traits.allbrige-bridged-token-trait)
(impl-trait .token-traits.extendable-token-actions-v1)
(impl-trait .token-traits.extendable-token)

(use-trait token-extension .token-traits.token-extension)
(use-trait extendable-token-actions-v1 .token-traits.extendable-token-actions-v1)

(define-constant ERR-NOT-AUTHORIZED (err u10000))
(define-constant ERR-MINT-ALLOWANCE-OVERFLOW (err u10001))
(define-constant ERR-PRINCIPAL-INVALID (err u10002))
(define-constant ERR-AMOUNT-INVALID (err u10003))
(define-constant ERR-TOKEN-PAUSED (err u10004))

(define-constant PRECISION u8)
(define-map authorized-extensions principal bool)

(define-data-var token-uri (string-utf8 256) u""http://url.to/token-metadata.json"")
(define-data-var name (string-ascii 32) ""USDC.e (Bridged by X)"")
(define-data-var symbol (string-ascii 32) ""USDC.e"")
(define-data-var contract-owner principal contract-caller)

(define-fungible-token token-data)

(define-map minters-allowances principal uint)

(define-map minters-allowances-tracking principal uint)

(define-data-var token-pause bool true)

(define-public (set-minter-allowance (minter principal) (allowance uint))
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Update minter's allowance
		(map-set minters-allowances minter allowance)
		;; Emit an event to increase observability
		(print { type: ""allowance"", action: ""update"", object: { minter: minter, allowance: allowance } })
		;; Ok response
		(ok { minter: minter, allowance: allowance })))

(define-read-only (is-token-paused)
  	(ok (var-get token-pause)))

(define-public (pause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Pause token
		(var-set token-pause true)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

(define-public (unpause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Unpause token
		(var-set token-pause false)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

;;;; SIP-10 trait implementation
;; The logic of these functions will not be upgradable.
;; Constraint: we'd need to have them right from the get go.

(define-read-only (get-total-supply)
  	(ok (ft-get-supply token-data)))

(define-read-only (get-name)
  	(ok (var-get name)))

(define-read-only (get-symbol)
  	(ok (var-get symbol)))

(define-read-only (get-decimals)
   	(ok PRECISION))

(define-read-only (get-balance (account principal))
  	(ok (ft-get-balance token-data account)))

(define-read-only (get-token-uri)
  	(ok (some (var-get token-uri))))

(define-public (transfer 
		(amount uint) 
		(sender principal) 
		(recipient principal) 
		(memo (optional (buff 34))))
	;; All-bridge requirement - To be explored
	(transfer! amount sender recipient memo))

;;;; Ownership management

(define-read-only (get-contract-owner)
  	(ok (var-get contract-owner)))

(define-public (set-contract-owner (owner principal))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(asserts! (is-standard owner) ERR-NOT-AUTHORIZED)
		(ok (var-set contract-owner owner))))

;;;; Token Extensions
;;;; Functions available for the token extensions

(define-public (set-token-uri (value (string-utf8 256)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set token-uri value))))

(define-public (set-token-name (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set name value))))

(define-public (set-token-symbol (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set symbol value))))

(define-map banned-addresses principal bool)

(define-public (ban-address (address principal))
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-set banned-addresses address true)
		(ok address)))

(define-public 
	(unban-address 
		(address principal)
	)
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-delete banned-addresses address)
		(ok address)))

;; Mint tokens
(define-public (mint! (recipient principal) (amount uint) (memo (optional (buff 34))))
	(let ((minting-allowance (unwrap! (map-get? minters-allowances contract-caller) ERR-NOT-AUTHORIZED))
		  (minted-pre-op (default-to u0 (map-get? minters-allowances-tracking contract-caller)))
		  (minted-post-op (+ minted-pre-op amount)))
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that minter can mint
		(asserts! (>= amount u0) ERR-AMOUNT-INVALID)
		;; Ensure that minter can mint
		(asserts! (>= minting-allowance minted-post-op) ERR-MINT-ALLOWANCE-OVERFLOW)
		;; Mint tokens
		(unwrap-panic (ft-mint? token-data amount recipient))
		;; Update allowance tracking
		(map-set minters-allowances-tracking contract-caller minted-post-op)
		;; Emit memo event
		(print memo)
		;; Return Ok
		(ok true)))

;; Burn tokens
(define-public (burn! (sender principal) (amount uint) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		(match 
			(ft-burn? token-data amount sender)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Transfer tokens
(define-public (transfer! 
		(amount uint)
		(sender principal)
		(recipient principal)
		(memo (optional (buff 34))))
	(begin 
		;; Ensure amount is positive
		(asserts! (> amount u0) ERR-AMOUNT-INVALID)
		;; Ensure the sender is not banned
		(asserts! (is-none (map-get? banned-addresses sender)) ERR-NOT-AUTHORIZED)
		;; Ensure the recipient is not banned
		(asserts! (is-none (map-get? banned-addresses recipient)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that send tokens are owned by the tx-sender
		(asserts! (is-eq sender tx-sender) ERR-NOT-AUTHORIZED)
		(match 
			(ft-transfer? token-data amount sender recipient)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Extension management

(define-public (authorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""authorized"", object: { extension: extension } })
        (map-insert authorized-extensions (contract-of extension) true)
        (ok true)))

(define-public (deauthorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""deprecated"", object: { extension: extension } })
        (map-delete authorized-extensions (contract-of extension))
        (ok true)))

(define-public (run-extension! 
		(self <extendable-token-actions-v1>)
		(extension <token-extension>)
		(payload (buff 8192)))
	(begin
        (asserts! (is-eq (as-contract tx-sender) (contract-of self)) ERR-NOT-AUTHORIZED)
        (asserts! (is-eq (map-get? authorized-extensions (contract-of extension)) (some true)) ERR-NOT-AUTHORIZED)
		(as-contract (contract-call? extension run! self payload))))"
"Create a Clarity smart contract for Stacks blockchain that functions as a simple bank or ""piggy bank"" where users can deposit and withdraw STX tokens. The contract should maintain a map of user accounts with their balances, implement secure deposit functionality, and demonstrate multiple withdrawal implementations with varying security patterns (including an intentionally unsafe version for educational purposes). Include read-only balance checking, administrative functions allowing a bank owner to withdraw from any account, and a time-based withdrawal feature that unlocks after a certain block height. The contract should serve as an educational example with clear comments explaining security considerations, input validation techniques, and demonstrate both proper error handling with constants and the use of Clarity's security features like assertions and conditional checks.","First, I need to identify the core requirements for this piggy bank contract. The question asks for a bank-like system where users can deposit and withdraw STX tokens with their balances tracked. It specifically mentions multiple withdrawal implementations with varying security patterns and administrative functions.

Looking at the contract structure, it begins by defining error constants, which addresses the requirement for ""proper error handling with constants."" The two error types - insufficient balance and unauthorized access - cover the critical failure modes for this banking application.

Next, the contract establishes a data map called ""accounts"" to track balances. This directly implements the requirement to ""maintain a map of user accounts with their balances"" by associating each principal (user address) with their token amount stored as an integer.

The deposit function handles the first core requirement. It retrieves the current balance using map-get?, adds the deposit amount after converting it to an integer, updates the map, and transfers tokens to the contract. The implementation includes a comment about allowing unchecked data since the STX transfer will fail and rollback operations if the sender lacks sufficient tokens.

Now for the withdrawal implementations. The contract includes multiple versions as required, starting with an intentionally unsafe version that lacks balance validation. This educational ""anti-pattern"" shows what happens when input validation is missing - allowing users to potentially withdraw more than they deposited.

Then, the contract implements three secure withdrawal variants. The standard ""withdrawal"" function uses assertions to validate the user has sufficient balance before proceeding. The ""withdrawal-if"" function accomplishes the same security check using conditional logic instead. The ""withdrawal-callee-filter"" demonstrates a more modular approach by delegating the validation to a separate helper function. These implementations directly satisfy the requirement to ""demonstrate multiple withdrawal implementations with varying security patterns.""

Wait, there's also the read-only function requirement. The contract includes ""get-balance"" which allows users to check their current balance without modifying state, implementing precisely what was required.

Looking at administrative features, the contract defines a bank-owner variable and implements a ""take"" function that allows this owner to withdraw from any account, satisfying the requirement for ""administrative functions allowing a bank owner to withdraw from any account."" It includes proper authorization checks to ensure only the bank owner can call this function.

Finally, the contract includes a time-based feature with ""take-after-time"" and an expiration-height variable that allows funds to be withdrawn after a certain block height, fulfilling the requirement for ""a time-based withdrawal feature that unlocks after a certain block height.""

Throughout the implementation, the code includes detailed comments explaining security considerations like tainted input, the check-checker's warnings, and annotations for security features. These comments serve the educational purpose specified in the requirements, highlighting both secure and insecure patterns in Clarity.

The contract effectively demonstrates Clarity's security features through assertions, conditional checks, and even optional annotations like filter() and allow(). Each function showcases different aspects of secure programming in Clarity, from basic validation to more advanced patterns like trusted sender checks and delegated validation.

Okay, so the implementation completely satisfies all the requirements from the question, providing a comprehensive educational example of a banking contract on the Stacks blockchain with appropriate error handling, security patterns, and administrative features.",";; bank
;; This contract serves as a simple piggy bank, where users can deposit STX
;; and withdrawal it later. It serves as an example program to demonstrate
;; features of the check-checker.

;; constants
(define-constant err-insufficient-balance (err u1))
(define-constant err-unauthorized (err u2))

;; data maps and vars
(define-map accounts { holder: principal } { amount: int })

;; public functions

;; A user deposits money into the piggy bank.
(define-public (deposit (amount uint))
    (let ((balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))))
        ;; A user should be allowed to specify any amount to deposit, and the
        ;; `stx-transfer?` will fail and rollback all operations if the sender
        ;; does not have enough STX, so it is safe to allow the unchecked data
        ;; here.
        ;; #[allow(unchecked_data)]
        (map-set accounts {holder: tx-sender} {amount: (+ balance (to-int amount))})
        (stx-transfer? amount tx-sender (as-contract tx-sender))
    )
)

;; A user withdrawals from the piggy bank.
;; This unsafe implementation of withdrawal forgets to include a check on the
;; amount. See the tests for what can happen!
(define-public (withdrawal-unsafe (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
         ;; `balance` is tainted by the untrusted input, `amount`, so the
         ;; check-checker reports a warning when it is written into a map.
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        ;; `amount` is untrusted input, so it is dangerous to use it in a
        ;; `stx_transfer?` call.
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; A user withdrawals from the piggy bank.
(define-public (withdrawal (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; This `asserts!` is a check on `amount`, allowing it to be used
        ;; without warnings from the check-checker.
        (asserts! (>= balance (to-int amount)) err-insufficient-balance)
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; A user withdrawals from the piggy bank.
;; This version of withdrawal uses an 'if'.
(define-public (withdrawal-if (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; Here is another example of a way to check the untrusted input.
        (if (<= (to-int amount) balance)
            (begin
                (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
                (as-contract (stx-transfer? amount tx-sender customer))
            )
            err-insufficient-balance
        )
    )
)

;; Check that the amount is less than or equal to the balance.
(define-private (check-balance (amount uint))
    (let ((balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))))
        (asserts! (<= (to-int amount) balance) err-insufficient-balance)
        (ok true)
    )
)

;; A user withdrawals from the piggy bank.
;; This version of withdrawal calls another function to perform the check.
(define-public (withdrawal-callee-filter (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; This call to `check-balance` serves as a check on `amount`, if the
        ;; `callee_filter` option is enabled.
        (try! (check-balance amount))
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; Retrieve the sender's balance.
(define-read-only (get-balance)
    (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))
)

(define-data-var bank-owner principal tx-sender)

;; The owner of the bank can take money from any account.
(define-public (take (amount uint) (from principal))
    (let (
          (balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) (to-int amount)))
          (banker tx-sender)
        )
        ;; When the `trusted_sender` option is enabled, the check on
        ;; `tx-sender` below tells the check-checker that this is a trusted
        ;; sender, so we trust all inputs. If you disable this option (in
        ;; Clarinet.toml) you will see warnings on the uses below.
        (asserts! (is-eq tx-sender (var-get bank-owner)) err-unauthorized)
        (map-set accounts {holder: from} {amount: balance})
        (as-contract (stx-transfer? amount tx-sender banker))
    )
)

(define-data-var expiration-height uint u100)

;; If a certain block has passed, any user can take money out of any account.
(define-public (take-after-time (amount uint) (from principal))
    (let ((balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) (to-int amount))))
        (asserts! (>= balance (to-int amount)) err-insufficient-balance)
        ;; The annotation `filter(from)` tells the check-checker to consider
        ;; the variable `from` to be considered filtered by the asserts below.
        ;; Without this annotation, the check-checker would report a warning
        ;; on the `map-set`.
        ;; #[filter(from)]
        (asserts! (> block-height (var-get expiration-height)) err-unauthorized)
        (map-set accounts {holder: from} {amount: balance})
        (stx-transfer? amount (as-contract tx-sender) tx-sender)
    )
)"
"I need you to create a Clarity smart contract for a fundraising campaign on the Stacks blockchain. The contract should allow donations in both STX and sBTC cryptocurrencies. It should include initialization functionality where I can set a funding goal and campaign duration, with a default duration of approximately 30 days (in Bitcoin blocks). The contract should track donations by donor address, allow the campaign owner to cancel the campaign, enable donors to request refunds if the campaign is cancelled, and allow the beneficiary to withdraw funds once the campaign ends. Please include appropriate error handling, getter functions to check campaign status and donation information, and ensure all functions have proper authorization checks. The contract should maintain data on total donations, campaign status, and individual contribution amounts.","First, I need to understand what we're trying to build: a fundraising campaign contract for the Stacks blockchain. This requires careful state management to track donations, campaign status, and handle various transactions securely.

Let's start with the core state management needs. The contract must maintain several pieces of crucial information: whether the campaign is initialized, cancelled or withdrawn, who the beneficiary is, timing parameters (duration and start), goal amounts, and donation tracking. These are implemented as data variables to maintain the contract's state across transactions.

Then, we need to track individual donations, which requires associating donor addresses with contribution amounts. Maps are the appropriate data structure here - one for STX donations and another for sBTC, both using the donor's principal (address) as the key.

Wait, error handling is critical for blockchain contracts. I should define error constants upfront to make the code more readable and maintainable. These error codes (like err-not-authorized, err-campaign-ended) help provide clear feedback when operations fail.

Now for campaign initialization. The initialize-campaign function needs ownership validation (only the contract owner can initialize), checks to prevent double-initialization, and logic to set campaign parameters. Including a default duration option (approximately 30 days in Bitcoin blocks) adds flexibility.

Okay, campaign management requires capabilities to cancel campaigns and handle funds. The cancel-campaign function includes proper authorization checks, ensures the campaign was initialized, and prevents cancellation after funds have been withdrawn.

The donation functionality needs separate methods for STX and sBTC. Both donation functions must verify the campaign is initialized and active, check that the campaign hasn't ended, transfer the funds to the contract, update the donor's contribution records, and increment total donation amounts.

For fund withdrawal, security is paramount. The withdraw function must verify proper authorization (only the beneficiary can withdraw), ensure the campaign is active and hasn't been withdrawn from already, and confirm the campaign period has ended. Then it needs to handle the actual transfer of both STX and sBTC assets to the beneficiary.

The refund mechanism must only function when the campaign is cancelled. It retrieves the donor's contributions, transfers the appropriate assets back, and cleans up the donation records.

Finally, read-only getter functions provide transparency and data access without modifying state. These functions allow checking individual donations, viewing overall campaign metrics, and monitoring the contract's balance.

Looking at the implementation, I can see the code addresses all requirements through a logical structure that handles campaign lifecycle, donations, withdrawals, and refunds with appropriate authorization and state management.",";; Fundraising Campaign Contract
;; A simple contract to accept crypto donations in STX or sBTC.

;; Constants 
(define-constant contract-owner tx-sender)
(define-constant err-not-authorized (err u100))
(define-constant err-campaign-ended (err u101))
(define-constant err-not-initialized (err u102))
(define-constant err-not-cancelled (err u103))
(define-constant err-campaign-not-ended (err u104))
(define-constant err-campaign-cancelled (err u105))
(define-constant err-already-initialized (err u106))
(define-constant err-already-withdrawn (err u107))

(define-constant default-duration u4320) ;; Duration in *Bitcoin* blocks. This default value means is if a block is 10 minutes, this is roughly 30 days.

;; Data vars
(define-data-var is-campaign-initialized bool false)
(define-data-var is-campaign-cancelled bool false)
(define-data-var beneficiary principal contract-owner)
(define-data-var campaign-duration uint u173000)
(define-data-var campaign-start uint u0)
(define-data-var campaign-goal uint u0)
(define-data-var total-stx uint u0) ;; in microstacks
(define-data-var total-sbtc uint u0) ;; in sats
(define-data-var donation-count uint u0)
(define-data-var is-campaign-withdrawn bool false)

;; Maps
(define-map stx-donations principal uint)  ;; donor -> amount
(define-map sbtc-donations principal uint) ;; donor -> amount

;; Initialize the campaign (goal in US dollars)
;; Pass duration as 0 to use the default duration (~30 days)
;; Can only be called once
(define-public (initialize-campaign (goal uint) (duration uint))
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (not (var-get is-campaign-initialized)) err-already-initialized)
    (var-set is-campaign-initialized true)
    (var-set campaign-start burn-block-height)
    (var-set campaign-goal goal)
    (var-set campaign-duration duration)
    (var-set campaign-duration (if (is-eq duration u0) 
      default-duration
      duration))
    (ok true)))

;; Cancel the campaign
;; Only the owner can call this, at any time during or after the campaign
;; Allows donors to get a refund
;; Can only be called once
(define-public (cancel-campaign)
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (var-set is-campaign-cancelled true)
    (ok true)))

;; Donate STX. Pass amount in microstacks.
(define-public (donate-stx (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set stx-donations tx-sender 
      (+ (default-to u0 (map-get? stx-donations tx-sender)) amount))
    (var-set total-stx (+ (var-get total-stx) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Donate sBTC. Pass amount in Satoshis.
(define-public (donate-sbtc (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
      amount 
      contract-caller
      (as-contract tx-sender) 
      none))
    (map-set sbtc-donations tx-sender
      (+ (default-to u0 (map-get? sbtc-donations tx-sender)) amount))
    (var-set total-sbtc (+ (var-get total-sbtc) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Withdraw funds (only beneficiary, only if campaign is ended)
(define-public (withdraw)
  (let (
    (total-stx-amount (var-get total-stx))
    (total-sbtc-amount (var-get total-sbtc))
  )
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (asserts! (is-eq tx-sender (var-get beneficiary)) err-not-authorized)
    (asserts! (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration)))
              err-campaign-not-ended)
    (as-contract
      (begin
        (if (> total-stx-amount u0)
          (try! (stx-transfer? total-stx-amount (as-contract tx-sender) (var-get beneficiary)))
          true)
        (if (> total-sbtc-amount u0)
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            total-sbtc-amount
            (as-contract tx-sender)
            (var-get beneficiary)
            none))
          true)
        (var-set is-campaign-withdrawn true)
        (ok true)))))

;; Refund to donor
;; Campaign owner can choose to allow this by cancelling the campaign
(define-public (refund)
  (let (
    (stx-amount (default-to u0 (map-get? stx-donations tx-sender)))
    (sbtc-amount (default-to u0 (map-get? sbtc-donations tx-sender)))
    (contributor tx-sender)
  )
    (asserts! (var-get is-campaign-cancelled) err-not-cancelled)
    (if (> stx-amount u0)
      (begin
        (as-contract
          (try! (stx-transfer? stx-amount tx-sender contributor))))
      true)
      (map-delete stx-donations tx-sender)
    (if (> sbtc-amount u0)
      (begin
        (as-contract
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            sbtc-amount
            tx-sender
            contributor
            none))))
      true)
      (map-delete sbtc-donations tx-sender)
    (ok true)))

;; Getter functions
(define-read-only (get-stx-donation (donor principal))
  (ok (default-to u0 (map-get? stx-donations donor))))

(define-read-only (get-sbtc-donation (donor principal))
  (ok (default-to u0 (map-get? sbtc-donations donor))))

(define-read-only (get-campaign-info)
  (ok {
    start: (var-get campaign-start),
    end: (+ (var-get campaign-start) (var-get campaign-duration)),
    goal: (var-get campaign-goal),
    totalStx: (var-get total-stx),
    totalSbtc: (var-get total-sbtc),
    donationCount: (var-get donation-count),
    isExpired: (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))),
    isWithdrawn: (var-get is-campaign-withdrawn),
    isCancelled: (var-get is-campaign-cancelled),
  }))

(define-read-only (get-contract-balance)
  (stx-get-balance (as-contract tx-sender)))"
"Create a Clarity smart contract for Stacks Blockchain that implements a payment streaming protocol. The contract should allow users to create streams of sBTC payments that automatically transfer funds from sender to recipient gradually over a specified number of blocks. Include functionality for creating new streams, refueling existing streams, withdrawing accumulated funds (for recipients), refunding unused funds (for senders after the stream ends), and allowing both parties to update stream parameters with mutual consent verified by cryptographic signatures. The contract should maintain a mapping of streams with their properties including sender, recipient, balance, withdrawn amount, payment rate, and timeframe details. Implement proper error handling for unauthorized access, invalid signatures, active streams, and non-existent stream IDs. Also include helper functions to calculate available balances and block deltas.","First, I need to understand what the contract aims to accomplish: a payment streaming protocol for Stacks Blockchain using Clarity. The fundamental concept here is to allow gradual transfers of sBTC from a sender to a recipient over a specified timeframe measured in blocks, rather than sending the entire amount at once.

Let's start by examining the state management approach. The contract needs to track multiple payment streams, each with its own properties. This naturally calls for a mapping data structure, which is implemented through the ""streams"" map using unique stream IDs as keys. Each stream stores essential information: the sender, recipient, total balance, withdrawn amount, payment rate, and time boundaries.

Next, the contract requires a way to generate unique identifiers for each stream. This is handled through a ""latest-stream-id"" data variable that incrementally increases with each new stream creation, ensuring uniqueness and proper record-keeping.

For the core functionality, the contract must implement several operations. The most fundamental is ""stream-to,"" which creates a new payment stream. This function locks the initial balance from the sender by transferring sBTC to the contract, sets up the stream parameters, and returns the stream ID. The implementation uses ""contract-caller"" to identify the sender, enforcing that the person creating the stream is the one funding it.

Then, we have the ""refuel"" function. This addresses the need to add more funds to an existing stream without altering other parameters. The function checks that only the original sender can add funds, ensuring proper authorization. It then transfers additional sBTC to the contract and updates the stream's balance.

Wait, how do we calculate how much of the funds has been ""streamed"" at any point? This is handled by ""calculate-block-delta"" and ""balance-of"" functions. The first determines how many blocks have passed in the stream's lifetime, considering the current block height against the start and stop blocks. The second uses this delta to calculate the exact amounts available to both the sender and recipient based on the payment rate and time elapsed.

Now, for the withdrawal mechanics. The ""withdraw"" function allows the recipient to claim their accumulated funds. It verifies the caller is the legitimate recipient, calculates the available balance, updates the withdrawn amount, and transfers the sBTC. This ensures recipients can access their funds without waiting for the entire stream to finish.

Similarly, ""refund"" lets senders reclaim excess funds after a stream ends. It verifies the stream has concluded by checking if the current block height exceeds the stop block, preventing premature withdrawals. This protects the recipient's interests while allowing senders to retrieve unused funds.

Okay, but what about modifications to stream parameters? The contract includes an update mechanism through ""update-details,"" but this requires consent from both parties to prevent unilateral changes. This is cleverly implemented using cryptographic signatures: one party proposes changes and the other signs off on them. The ""hash-stream"" and ""validate-signature"" functions support this by creating a hash of the proposed changes and verifying the signature against it.

The contract's error handling is thorough, with distinct error codes for different scenarios: unauthorized access, invalid signatures, attempts to refund active streams, and references to non-existent streams. This makes the contract more robust and helps users identify issues.

Then, there's the interesting decision to make some functions read-only (like ""balance-of"" and ""calculate-block-delta""). This optimizes gas usage since these operations only read state without modifying it. They serve as helper functions for both the contract's internal logic and external queries.

Finally, the implementation carefully manages the transfer of sBTC tokens using the standard token interface through ""contract-call?"" to interact with the sBTC token contract. The ""as-contract"" pattern is used for withdrawals and refunds to ensure the contract itself initiates these transfers, maintaining proper custody of funds throughout the stream's lifecycle.",";; payment-stream.clar

;; Error codes
(define-constant ERR_UNAUTHORIZED (err u0))
(define-constant ERR_INVALID_SIGNATURE (err u1))
(define-constant ERR_STREAM_STILL_ACTIVE (err u2))
(define-constant ERR_INVALID_STREAM_ID (err u3))

;; Data vars
(define-data-var latest-stream-id uint u0)
(define-data-var nonce uint u0)

;; Streams mapping
(define-map streams
    uint  ;; stream-id
    {
        sender: principal,
        recipient: principal,
        balance: uint,
        withdrawn-balance: uint,
        payment-per-block: uint,
        timeframe: (tuple (start-block uint) (stop-block uint))
    }
)

;; Create a new stream
(define-public (stream-to
    (recipient principal)
    (initial-balance uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (payment-per-block uint)
)
    (let (
        (stream {
            sender: contract-caller,
            recipient: recipient,
            balance: initial-balance,
            withdrawn-balance: u0,
            payment-per-block: payment-per-block,
            timeframe: timeframe
        })
        (current-stream-id (var-get latest-stream-id))
    )
        ;; Transfer sBTC from sender to contract
        (try! (contract-call?
            .sbtc-token
            transfer
            initial-balance
            contract-caller
            (as-contract tx-sender)
            none
        ))
        (map-set streams current-stream-id stream)
        (var-set latest-stream-id (+ current-stream-id u1))
        (ok current-stream-id)
    )
)

;; Increase the locked sBTC balance for a stream
(define-public (refuel
    (stream-id uint)
    (amount uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (try! (contract-call?
      .sbtc-token
      transfer
      amount
      contract-caller
      (as-contract tx-sender)
      none
    ))
    (map-set streams stream-id
      (merge stream {balance: (+ (get balance stream) amount)})
    )
    (ok amount)
  )
)

;; Check balance for a party involved in a stream
(define-read-only (balance-of
    (stream-id uint)
    (who principal)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) u0))
    (block-delta (calculate-block-delta (get timeframe stream)))
    (recipient-balance (* block-delta (get payment-per-block stream)))
  )
    (if (is-eq who (get recipient stream))
      (- recipient-balance (get withdrawn-balance stream))
      (if (is-eq who (get sender stream))
        (- (get balance stream) recipient-balance)
        u0
      )
    )
  )
)

;; Calculate the number of blocks a stream has been active
(define-read-only (calculate-block-delta
    (timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (start-block (get start-block timeframe))
    (stop-block (get stop-block timeframe))

    (delta
      (if (<= block-height start-block)
        ;; then
        u0
        ;; else
        (if (< block-height stop-block)
          ;; then
          (- block-height start-block)
          ;; else
          (- stop-block start-block)
        )
      )
    )
  )
    delta
  )
)

;; Withdraw received tokens
(define-public (withdraw
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id contract-caller))
  )
    (asserts! (is-eq contract-caller (get recipient stream)) ERR_UNAUTHORIZED)
    (map-set streams stream-id
      (merge stream {withdrawn-balance: (+ (get withdrawn-balance stream) balance)})
    )
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get recipient stream)
      none
    )))
    (ok balance)
  )
)

;; Withdraw excess locked tokens
(define-public (refund
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id (get sender stream)))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (asserts! (< (get stop-block (get timeframe stream)) block-height) ERR_STREAM_STILL_ACTIVE)
    (map-set streams stream-id (merge stream {
        balance: (- (get balance stream) balance),
      }
    ))
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get sender stream)
      none
    )))
    (ok balance)
  )
)

;; Get hash of stream
(define-read-only (hash-stream
    (stream-id uint)
    (new-payment-per-block uint)
    (new-timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) (sha256 0)))
    (msg (concat (concat (unwrap-panic (to-consensus-buff? stream)) (unwrap-panic (to-consensus-buff? new-payment-per-block))) (unwrap-panic (to-consensus-buff? new-timeframe))))
  )
    (sha256 msg)
  )
)

;; Signature verification
(define-read-only (validate-signature (hash (buff 32)) (signature (buff 65)) (signer principal))
  (is-eq
    (principal-of? (unwrap! (secp256k1-recover? hash signature) false))
    (ok signer)
  )
)

;; Update stream configuration
(define-public (update-details
    (stream-id uint)
    (payment-per-block uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (signer principal)
    (signature (buff 65))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (validate-signature (hash-stream stream-id payment-per-block timeframe) signature signer) ERR_INVALID_SIGNATURE)
    (asserts!
      (or
        (and (is-eq (get sender stream) contract-caller) (is-eq (get recipient stream) signer))
        (and (is-eq (get sender stream) signer) (is-eq (get recipient stream) contract-caller))
      )
      ERR_UNAUTHORIZED
    )
    (map-set streams stream-id (merge stream {
        payment-per-block: payment-per-block,
        timeframe: timeframe
    }))
    (ok true)
  )
)"
"Create a time-locked wallet smart contract in Clarity language for the Stacks blockchain that allows the contract owner to lock STX tokens for a designated beneficiary until a specific block height is reached. The contract should include a lock function that permits the owner to specify the beneficiary, set a future unlock height, and deposit tokens; a bestow function allowing the current beneficiary to transfer their rights; and a claim function enabling the beneficiary to withdraw all tokens after the unlock height is reached. Include appropriate error handling for owner-only operations, preventing multiple locks, ensuring the unlock height is in the future, validating token amounts, restricting beneficiary-only actions, and preventing premature withdrawals. Use data variables to track the beneficiary (initially none) and unlock height (initially zero). Name it ""timelocked-wallet"" and add explanatory comments about its purpose.","First, I need to understand what the question is asking for: a time-locked wallet in Clarity language for the Stacks blockchain. This requires knowledge of Clarity's syntax and blockchain concepts like principals, token transfers, and block heights.
Let's see what core functionality is needed. The contract must lock STX tokens until a specific block height is reached, with three main functions: lock, bestow, and claim. The contract owner should be able to lock tokens for a beneficiary, the beneficiary should be able to transfer rights, and finally claim the tokens after the unlock height.
Okay, starting with the contract's foundational structure, the code begins with comments explaining the purpose—a time-locked vault that allows claiming after a certain block height. It then defines the contract owner as the transaction sender (tx-sender), which establishes ownership at contract deployment time.
Then, the code defines error constants with meaningful names and unique error codes. This is good practice for smart contracts as it makes error handling more explicit and debugging easier. The errors cover all the requirements: owner-only operations, preventing multiple locks, ensuring future unlock heights, validating amounts, restricting beneficiary actions, and preventing premature withdrawals.
Next, the data variables are established. The beneficiary is defined as an optional principal type (allowing it to be ""none"") and the unlock height as a uint initialized to zero. These align with the requirement to track the beneficiary and unlock height with initial values of none and zero respectively.
For the lock function, it first performs several assertions to validate the operation. It checks that the sender is the contract owner, the beneficiary is currently none (preventing multiple locks), the unlock height is in the future, and the amount is greater than zero. Then it transfers the STX tokens from the sender to the contract itself using stx-transfer?, sets the beneficiary and unlock height variables, and returns ok true on success.
The bestow function allows the current beneficiary to transfer their rights to a new beneficiary. It first asserts that the transaction sender is the current beneficiary, then updates the beneficiary variable to the new beneficiary, and returns ok true.
Finally, the claim function enables the beneficiary to withdraw all tokens after the unlock height is reached. It asserts that the transaction sender is the current beneficiary and that the current block height is greater than or equal to the unlock height. Then it transfers all STX tokens from the contract to the beneficiary using as-contract to execute the transfer as the contract itself.
Wait, there's an important design consideration in the claim function. It uses stx-get-balance to determine how many tokens to transfer, ensuring all tokens in the contract are sent. It also uses unwrap-panic to extract the principal from the optional beneficiary, which is safe because the assertion earlier guarantees the beneficiary exists.
Throughout the code, the assertions use the error constants defined at the beginning, providing clear error messages when operations fail due to unmet conditions. This approach makes the contract more user-friendly and facilitates debugging.
To summarize, the code fully implements the requirements with careful design considerations for security, usability, and maintainability. It handles edge cases appropriately, uses Clarity's type system effectively, and follows best practices for smart contract development on the Stacks blockchain.",";; timelocked-wallet
;; A time-locked vault contract that becomes eligible to claim by the beneficiary after a certain block-height has been reached.

;; Owner
(define-constant contract-owner tx-sender)

;; Errors
(define-constant err-owner-only (err u100))
(define-constant err-already-locked (err u101))
(define-constant err-unlock-in-past (err u102))
(define-constant err-no-value (err u103))
(define-constant err-beneficiary-only (err u104))
(define-constant err-unlock-height-not-reached (err u105))

;; Data
(define-data-var beneficiary (optional principal) none)
(define-data-var unlock-height uint u0)

(define-public (lock (new-beneficiary principal) (unlock-at uint) (amount uint))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(asserts! (is-none (var-get beneficiary)) err-already-locked)
		(asserts! (> unlock-at block-height) err-unlock-in-past)
		(asserts! (> amount u0) err-no-value)
		(try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
		(var-set beneficiary (some new-beneficiary))
		(var-set unlock-height unlock-at)
		(ok true)
	)
)

(define-public (bestow (new-beneficiary principal))
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(var-set beneficiary (some new-beneficiary))
		(ok true)
	)
)

(define-public (claim)
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(asserts! (>= block-height (var-get unlock-height)) err-unlock-height-not-reached)
		(as-contract (stx-transfer? (stx-get-balance tx-sender) tx-sender (unwrap-panic (var-get beneficiary))))
	)
)"
"I need a Clarity smart contract for a fungible token on Stacks blockchain called ""Clarity Coin"" with symbol ""CC"" that implements the SIP-010 standard. The token should have no maximum supply, with only the contract owner able to mint new tokens. Include standard functions like transfer (with sender verification and optional memo parameter), plus all required read-only functions (get-name, get-symbol, get-decimals, get-balance, get-total-supply, get-token-uri). Add appropriate error constants for unauthorized minting attempts and invalid transfer attempts.","First, I need to implement the SIP-010 standard trait for fungible tokens on Stacks. This is accomplished by the initial line that implements the trait from its standard location at 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait'. This ensures the contract adheres to the expected interface for fungible tokens.

Next, I need to establish ownership and access control. The contract sets the deployer (tx-sender at deployment time) as the contract-owner using a constant definition. This will be used later to restrict certain functions. I'll also need error codes, so I define two constants: err-owner-only (u100) for unauthorized minting attempts and err-not-token-owner (u101) for invalid transfer attempts.

Now for the core token functionality. Since the requirement specifies no maximum supply, I simply define a fungible token called 'clarity-coin' without any supply cap. This creates the base token that will be managed by this contract.

Let's implement the transfer function as required. It needs to verify the sender, handle the actual transfer, and process an optional memo. The function takes four parameters: amount, sender, recipient, and an optional memo buffer. The function first asserts that the transaction sender is the same as the specified sender using the asserts! function, which will return err-not-token-owner if false. Then it attempts the transfer using ft-transfer?, capturing any errors with try!. Finally, it handles the memo parameter using match - if a memo is provided, it prints it; otherwise, it returns a default byte 0x.

Then I need to implement all the required read-only functions specified by the SIP-010 standard. get-name returns ""Clarity Coin"" as specified in the requirements. get-symbol returns ""CC"" as required. get-decimals returns u0 indicating no decimal places. get-balance uses the built-in ft-get-balance function to retrieve a principal's token balance. get-total-supply uses ft-get-supply to get the current total supply. get-token-uri returns none since no URI was specified in the requirements.

Finally, I need a mint function that's restricted to the owner only. This function takes an amount and recipient, checks that the caller is the contract owner using asserts!, and then mints the specified amount to the recipient using ft-mint?. This satisfies the requirement that only the contract owner can mint new tokens.

Wait, I should check if I've covered all requirements. The contract implements SIP-010, handles token transfers with sender verification, includes an optional memo parameter, has all required read-only functions, restricts minting to the owner, has no maximum supply, and includes appropriate error constants. Yes, all requirements have been addressed in the code.","(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

;; No maximum supply!
(define-fungible-token clarity-coin)

(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(try! (ft-transfer? clarity-coin amount sender recipient))
		(match memo to-print (print to-print) 0x)
		(ok true)
	)
)

(define-read-only (get-name)
	(ok ""Clarity Coin"")
)

(define-read-only (get-symbol)
	(ok ""CC"")
)

(define-read-only (get-decimals)
	(ok u0)
)

(define-read-only (get-balance (who principal))
	(ok (ft-get-balance clarity-coin who))
)

(define-read-only (get-total-supply)
	(ok (ft-get-supply clarity-coin))
)

(define-read-only (get-token-uri)
	(ok none)
)

(define-public (mint (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(ft-mint? clarity-coin amount recipient)
	)
)"
"Create a Stacks blockchain NFT smart contract using Clarity language that implements the nft-trait standard. The contract should manage a non-fungible token collection called ""stacksies"" with sequential token IDs tracked by a data variable. Include functionality for the contract owner to mint new tokens, allow token owners to transfer their tokens, and provide read-only functions to query token information (last token ID, token URI, and token ownership). Implement proper error handling for permission checks, ensuring only the contract owner can mint tokens and only token owners can transfer them. The contract should follow Clarity best practices with appropriate constants, data variables, and clearly defined public and read-only functions.","First, I need to understand the question's requirements: creating an NFT smart contract on Stacks that follows the nft-trait standard, manages ""stacksies"" tokens, and includes proper functionality and error handling. The contract must allow minting by the owner and transfers by token owners, plus provide read-only query functions.

Let's analyze how the response code implements these requirements. The first line implements the standard NFT trait from a specific principal address, which ensures our contract follows the expected interface for NFTs on the Stacks blockchain. Next, the code establishes key constants: contract-owner is set to tx-sender (the deployer of the contract), and two error constants are defined for permission checks.

Then, the core NFT definition is created with ""define-non-fungible-token stacksies uint"" which names our token collection ""stacksies"" and uses integers as token IDs. A data variable ""last-token-id"" is initialized to zero to track the sequential token IDs.

For the read-only functions, the code implements three required methods: get-last-token-id returns the current highest token ID, get-token-uri returns information about a specific token (though currently returns none as a placeholder), and get-owner returns the principal that owns a given token ID.

The transfer function handles ownership transfers with proper permission checks. It uses ""asserts!"" to verify that the transaction sender is the same as the provided sender argument, returning the not-token-owner error if this check fails. If the check passes, it attempts to transfer the NFT using the built-in nft-transfer? function.

Finally, the mint function implements the creation of new tokens. It calculates the next token ID by incrementing the last-token-id, verifies the caller is the contract owner, mints the token to the specified recipient, updates the last-token-id variable, and returns the new token ID. The permission check is critical here, ensuring only the contract owner can create new tokens.

Overall, the response code addresses all requirements from the question with a clean implementation that follows Clarity best practices. The code is minimal yet complete, with proper error handling and clear delineation between public and read-only functions.","(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

(define-non-fungible-token stacksies uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
	(ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

(define-read-only (get-owner (token-id uint))
	(ok (nft-get-owner? stacksies token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(nft-transfer? stacksies token-id sender recipient)
	)
)

(define-public (mint (recipient principal))
	(let
		(
			(token-id (+ (var-get last-token-id) u1))
		)
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (nft-mint? stacksies token-id recipient))
		(var-set last-token-id token-id)
		(ok token-id)
	)
)"