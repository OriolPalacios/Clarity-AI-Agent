Question,CoT,Response
"Rephrase the original request for a Clarity smart contract on the Stacks blockchain that handles decentralized lending. The contract should let users deposit and earn yield on STX, as well as borrow STX against their deposits, up to a certain limit. Detail the required functionality, including interest accrual, error handling, and information retrieval.","Summarize the thought process for creating the Clarity smart contract. This includes outlining requirements like managing STX deposits, calculating loan amounts based on collateral and a set loan-to-value ratio, handling loan repayments and yield distribution, accruing interest dynamically, incorporating error handling, and providing read-only functions for data transparency and identified errors during the analysis of the borrow and other functions. ",";; Define the contract's data variables

;; Maps a user's principal address to their deposited amount.
(define-map deposits { owner: principal } { amount: uint })

;; Maps a borrower's principal address to their loan details: amount and the last interaction block.
(define-map loans principal { amount: uint, last-interaction-block: uint })

;; Holds the total amount of deposits in the contract, initialized to 0.
(define-data-var total-deposits uint u0)

;; Represents the reserve funds in the pool, initialized to 0.
(define-data-var pool-reserve uint u0)

;; The interest rate for loans, represented as 10% (out of a base of 100).
(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate

;; Error constants for various failure scenarios.
(define-constant err-no-interest (err u100))
(define-constant err-overpay (err u200))
(define-constant err-overborrow (err u300))

;; Public function for users to deposit STX into the contract.
;; Updates their balance and the total deposits in the contract.
(define-public (deposit (amount uint))
    (let (
        ;; Fetch the current balance or default to 0 if none exists.
        (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        )
        ;; Transfer the STX from sender = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM"" to recipient = ""ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.stx-defi (ie: contract identifier on the chain!)"".
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's deposit amount in the map.
        (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
        ;; Update the total deposits variable.
        (var-set total-deposits (+ (var-get total-deposits) amount))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to borrow STX based on their deposits.
(define-public (borrow (amount uint))
    (let (
        ;; Fetch user's deposit or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)
        (allowed-borrow (/ user-deposit u2))
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
        ;; Calculate the new loan total after borrowing additional amount.
        (new-loan (+ amount))
    )
        ;; Ensure the requested borrow amount does not exceed the allowed amount.
        (asserts! (<= new-loan allowed-borrow) err-overborrow)
        ;; Transfer the borrowed STX to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? amount tx-sender recipient)))
        )
        ;; Update the user's loan details in the map.
        (map-set loans tx-sender { amount: new-loan, last-interaction-block: burn-block-height })
        ;; Return success.
        (ok true)
    )
)

;; Read-only function to get the total balance by tx-sender
(define-read-only (get-balance-by-sender)
    (ok (map-get? deposits { owner: tx-sender }))
)

;; Read-only function to get the total balance 
(define-read-only (get-balance)
    (ok (var-get total-deposits))
)

;; Read-only function to get the total amount owed by the user.
(define-read-only (get-amount-owed)
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest on the current loan.
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        ;; Calculate the total amount due including interest.
        (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
    )
    ;; Return the total amount due.
    (ok total-due)
    )
)

;; Public function for users to repay their STX loans.
(define-public (repay (amount uint))
    (let (
        ;; Fetch current loan details or default to initial values.
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        ;; Calculate accrued interest since the last interaction.
        (accrued-interest (unwrap! (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)) err-no-interest))
        ;; Calculate the total amount due including accrued interest.
        (total-due (+ (get amount current-loan-details) accrued-interest))
    )
        ;; Ensure the repayment amount is not more than the total due.
        (asserts! (>= total-due amount) err-overpay)
        ;; Transfer the repayment amount from the user to the contract.
        (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
        ;; Update the user's loan details in the map with the new total due.
        (map-set loans tx-sender { amount: (- total-due amount), last-interaction-block: burn-block-height })
        ;; Update the pool reserve with the paid interest.
        (var-set pool-reserve (+ (var-get pool-reserve) accrued-interest))
        ;; Return success.
        (ok true)
    )
)

;; Public function for users to claim their yield based on the pool reserve and their deposits.
(define-public (claim-yield)
    (let (
        ;; Fetch user's deposit amount or default to 0.
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        ;; Calculate the yield amount based on user's share of the pool.
        (yield-amount (/ (* (var-get pool-reserve) user-deposit) (var-get total-deposits)))
    )
        ;; Transfer the yield amount from the contract to the user.
        (let ((recipient tx-sender))
            (try! (as-contract (stx-transfer? yield-amount tx-sender recipient)))
        )
        ;; Update the pool reserve by subtracting the claimed yield.
        (var-set pool-reserve (- (var-get pool-reserve) yield-amount))
        ;; Return success.
        (ok true)
    )
)

;; Private function to calculate the accrued interest on a loan.
(define-private (calculate-accrued-interest (principal uint) (start-block uint))
    (let (
        ;; Calculate the number of blocks elapsed since the last interaction.
        (elapsed-blocks (- burn-block-height start-block))
        ;; Calculate the interest based on the principal, rate, and elapsed time.
        (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
        ;; Ensure the loan started in the past (not at block 0).
        (asserts! (not (is-eq start-block u0)) (ok u0))
        ;; Return the calculated interest.
       (ok interest)
    )
)"
"Develop a Stacks blockchain Clarity smart contract for a basic NFT marketplace. This marketplace should enable users to offer NFTs for sale, specifying details such as the NFT's ID, a sale expiration time, the asking price, the accepted payment method (either STX or SIP010 tokens), and an optional specific buyer. The contract must support features for adding approved contracts to a whitelist, adding new NFT listings, removing existing listings, and completing sales using both STX and alternative fungible tokens. Ensure the contract includes appropriate error handling, security measures, and utilizes the standard NFT and fungible token traits to maintain compatibility.","The task is to build an NFT marketplace smart contract on the Stacks blockchain using Clarity. Key requirements include configurable listing parameters (token ID, expiry, price, payment type, optional intended buyer), contract whitelisting, asset listing/delisting/purchase handling (STX and fungible tokens), security, and error handling. Clarity's properties (decidability, no reentrancy) are beneficial for secure asset management. The design revolves around a map for storing listings, keyed by unique integer IDs, with each entry storing all listing details. A nonce is used to generate unique listing IDs. A whitelist, managed by the contract owner, restricts interactions to approved contracts. Comprehensive error codes enhance debugging. The `list-asset` function validates input, transfers the NFT to the contract, and stores the listing. `get-listing` retrieves listing details. `cancel-listing` allows only the maker to cancel, returning the NFT. Purchase fulfillment is split into STX and fungible token functions, both validating conditions (buyer, taker, expiry, asset contracts) via `assert-can-fulfil`, ensuring a secure trade. Helper functions (`transfer-nft`, `transfer-ft`) handle token transfers, promoting maintainability. The `as-contract` context strengthens security by acting on the contract's behalf. STX payments use `stx-transfer?`; fungible tokens utilize `transfer-ft`. Listings are verified first, then transfer the assets, payment is finalized, and finally remove listing. No marketplace commission is included for minimality. Edge cases (expired listings, unauthorized cancellations) are handled. The contract efficiently meets all requirements with a secure, well-structured design, adhering to good software development practices.",";; A tiny NFT marketplace that allows users to list NFT for sale. They can specify the following:
;; - The NFT token to sell.
;; - Listing expiry in block height.
;; - The payment asset, either STX or a SIP010 fungible token.
;; - The NFT price in said payment asset.
;; - An optional intended taker. If set, only that principal will be able to fulfil the listing.
;;
;; Source: https://github.com/clarity-lang/book/tree/main/projects/tiny-market

(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

;; cancelling and fulfiling errors
(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

;; Define a map data structure for the asset listings
(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

;; Used for unique IDs for each listing
(define-data-var listing-nonce uint u0)

;; This marketplace requires any contracts used for assets or payments to be whitelisted
;; by the contract owner of this (marketplace) contract.
(define-map whitelisted-asset-contracts principal bool)

;; Function that checks if the given contract has been whitelisted.
(define-read-only (is-whitelisted (asset-contract principal))
  (default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

;; Only the contract owner of this (marketplace) contract can whitelist an asset contract.
(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

;; Internal function to transfer an NFT asset from a sender to a given recipient.
(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

;; Internal function to transfer fungible tokens from a sender to a given recipient.
(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

;; Public function to list an asset along with its contract
(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    ;; Verify that the contract of this asset is whitelisted
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    ;; Verify that the asset is not expired
    (asserts! (> (get expiry nft-asset) burn-block-height) ERR_EXPIRY_IN_PAST)
    ;; Verify that the asset price is greater than zero
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    ;; Verify that the contract of the payment is whitelisted
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    ;; Transfer the NFT ownership to this contract's principal
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    ;; List the NFT in the listings map
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    ;; Increment the nonce to use for the next unique listing ID
    (var-set listing-nonce (+ listing-id u1))
    ;; Return the created listing ID
    (ok listing-id)
  )
)

;; Public read-only function to retrieve a listing by its ID
(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

;; Public function to cancel a listing using an asset contract.
;; This function can only be called by the NFT's creator, and must use the same asset contract that
;; the NFT uses.
(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    ;; Verify that the caller of the function is the creator of the NFT to be cancelled
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    ;; Verify that the asset contract to use is the same one that the NFT uses
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    ;; Delete the listing
    (map-delete listings listing-id)
    ;; Transfer the NFT from this contract's principal back to the creator's principal
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

;; Private function to validate that a purchase can be fulfilled
(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    ;; Verify that the buyer is not the same as the NFT creator
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    ;; Verify the buyer has been set in the listing metadata as its `taker`
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    ;; Verify the listing for purchase is not expired
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    ;; Verify the asset contract used to purchase the NFT is the same as the one set on the NFT
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    ;; Verify the payment contract used to purchase the NFT is the same as the one set on the NFT
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

;; Public function to purchase a listing using STX as payment
(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the STX payment from the purchaser to the creator of the NFT
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)

;; Public function to purchase a listing using another fungible token as payment
(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    ;; Verify the given listing ID exists
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    ;; Set the NFT's taker to the purchaser (caller of the_function)
    (taker tx-sender)
  )
    ;; Validate that the purchase can be fulfilled
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    ;; Transfer the NFT to the purchaser (caller of the function)
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    ;; Transfer the tokens as payment from the purchaser to the creator of the NFT
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    ;; Remove the NFT from the marketplace listings
    (map-delete listings listing-id)
    ;; Return the listing ID that was just purchased
    (ok listing-id)
  )
)"
"Develop a Stacks Blockchain smart contract in Clarity that adheres to the SIP-009 standard for Non-Fungible Tokens (NFTs). This contract should define an NFT called ""Your-NFT-Name"" with a maximum supply of 1000. It should track the ID of the most recently minted token.  The contract should include: an owner (initialized to the deployer), error codes for failed ownership checks and exceeding the supply limit, and a configurable base URI for metadata. Implement all SIP-009 functions (get-last-token-id, get-token-uri, get-owner, transfer), and a mint function restricted to the contract owner. The mint function must enforce the supply cap, assign the token to a designated recipient, increment the token ID, and return the ID of the newly minted token.  All functions must include comprehensive error handling and validation to guarantee secure and predictable operation.","1.  Create a Clarity smart contract adhering to the SIP-009 NFT standard by implementing the required trait. This ensures interoperability.
2.  Define the NFT, ""Your-NFT-Name"", using unsigned integers for token IDs.
3.  Implement a counter (data variable initialized to zero) to track the last minted token ID, ensuring uniqueness.
4.  Define constants: contract owner (tx-sender), collection limit (1000), and error codes for unauthorized access and exceeding the limit.
5.  Create a base URI variable for token metadata, allowing individual token metadata through a token ID placeholder.
6.  Implement SIP-009 functions:
    -   `get-last-token-id`: Returns the current token ID counter.
    -   `get-token-uri`: Returns the metadata URI for a given token ID.
    -   `get-owner`: Retrieves the owner of a specific token.
    -   `transfer`: Transfers a token, verifying the sender's ownership.
7.  Implement the `transfer` function with sender verification, ensuring only the owner can transfer a token.
8.  Implement the `mint` function with the following checks and actions:
    -   Increment the last token ID.
    -   Verify the collection limit hasn't been reached.
    -   Restrict access to the contract owner.
    -   Mint the token to the specified recipient.
    -   Update the last token ID.
    -   Return the new token ID.
9.  Ensure all functions return appropriate responses, using `(ok ...)` for read-only functions and `try!` or `asserts!` for error handling and validation in state-changing functions.",";; This contract implements the SIP-009 community-standard Non-Fungible Token trait
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

;; Define the NFT's name
(define-non-fungible-token Your-NFT-Name uint)

;; Keep track of the last minted token ID
(define-data-var last-token-id uint u0)

;; Define constants
(define-constant CONTRACT_OWNER tx-sender)
(define-constant COLLECTION_LIMIT u1000) ;; Limit to series of 1000

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

;; SIP-009 function: Get the last minted token ID.
(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

;; SIP-009 function: Get link where token metadata is hosted
(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

;; SIP-009 function: Get the owner of a given token
(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? Your-NFT-Name token-id))
)

;; SIP-009 function: Transfer NFT token to another owner.
(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    ;; #[filter(sender)]
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? Your-NFT-Name token-id sender recipient)
  )
)

;; Mint a new NFT.
(define-public (mint (recipient principal))
  ;; Create the new token ID by incrementing the last minted ID.
  (let ((token-id (+ (var-get last-token-id) u1)))
    ;; Ensure the collection stays within the limit.
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    ;; Only the contract owner can mint.
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    ;; Mint the NFT and send it to the given recipient.
    (try! (nft-mint? Your-NFT-Name token-id recipient))

    ;; Update the last minted token ID.
    (var-set last-token-id token-id)
    ;; Return a success status and the newly minted NFT ID.
    (ok token-id)
  )
)"
"Create a Clarity smart contract for the Stacks Blockchain that adheres to the SIP-013 standard for semi-fungible tokens. This contract should implement both the 'sip013-semi-fungible-token-trait' and 'sip013-transfer-many-trait' from 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V'.  The contract should include a fungible token, a system for non-fungible token IDs, and mappings for balances and total supplies. It should provide functions for single and batch transfers (both with and without memos), checking balances, tracking total supply, and minting by the contract owner only. Ensure the contract includes error handling, access controls (specifically who has permission to call specific functions), event logging, and uses non-fungible token tagging to manage token ID ownership.","The provided code and initial question have significant differences. The question outlines requirements for a SIP-009 NFT (Non-Fungible Token) with a 1000-token limit and the name 'Your-NFT-Name'. However, the code implements a SIP-013 semi-fungible token, a different standard altogether. The code utilizes the traits 'sip013-semi-fungible-token-trait' and 'sip013-transfer-many-trait', not SIP-009. It creates a semi-fungible token named 'semi-fungible-token' and an NFT for ID management called 'semi-fungible-token-id', using composite keys. This allows tracking both the specific ID and quantity owned, unlike the pure NFT requested. Crucially, the 1000-token limit is absent; the code provides a general implementation without quantity or specific number of IDs restrictions. Storage uses data maps for balances/supplies, typical for semi-fungible tokens where users can own multiple of the same ID. Error handling is present for ownership ('err-owner-only') and balance ('err-insufficient-balance'), but not for collection size. Sender verification in the transfer function is handled correctly. All SIP-013 functions are implemented, including balance queries, supply, transfers (single and batch, even batch transfers which are not mentioned in question), and a owner restricted minting function. The code includes a utility function 'tag-nft-token-id' for a non-fungible token tagging strategy. The most substantial mismatch is the absence of 'get-last-token-id', essential for sequential NFT minting but irrelevant for semi-fungible tokens. In summary, the code implements SIP-013 correctly but does *not* fulfill the question's SIP-009 NFT requirements.","(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-semi-fungible-token-trait.sip013-semi-fungible-token-trait)
(impl-trait 'SPDBEG5X8XD50SPM1JJH0E5CTXGDV5NJTKAKKR5V.sip013-transfer-many-trait.sip013-transfer-many-trait)

(define-fungible-token semi-fungible-token)
(define-non-fungible-token semi-fungible-token-id {token-id: uint, owner: principal})
(define-map token-balances {token-id: uint, owner: principal} uint)
(define-map token-supplies uint uint)

(define-constant contract-owner tx-sender)

(define-constant err-owner-only (err u100))
(define-constant err-insufficient-balance (err u1))
(define-constant err-invalid-sender (err u4))

(define-private (set-balance (token-id uint) (balance uint) (owner principal))
	(map-set token-balances {token-id: token-id, owner: owner} balance)
)

(define-private (get-balance-uint (token-id uint) (who principal))
	(default-to u0 (map-get? token-balances {token-id: token-id, owner: who}))
)

(define-read-only (get-balance (token-id uint) (who principal))
	(ok (get-balance-uint token-id who))
)

(define-read-only (get-overall-balance (who principal))
	(ok (ft-get-balance semi-fungible-token who))
)

(define-read-only (get-total-supply (token-id uint))
	(ok (default-to u0 (map-get? token-supplies token-id)))
)

(define-read-only (get-overall-supply)
	(ok (ft-get-supply semi-fungible-token))
)

(define-read-only (get-decimals (token-id uint))
	(ok u0)
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

;; #[allow(unchecked_params)]
(define-public (transfer (token-id uint) (amount uint) (sender principal) (recipient principal))
	(let
		(
			(sender-balance (get-balance-uint token-id sender))
		)
		(asserts! (or (is-eq sender tx-sender) (is-eq sender contract-caller)) err-invalid-sender)
		(asserts! (<= amount sender-balance) err-insufficient-balance)
		(try! (ft-transfer? semi-fungible-token amount sender recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: sender}))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (- sender-balance amount) sender)
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(print {type: ""sft_transfer"", token-id: token-id, amount: amount, sender: sender, recipient: recipient})
		(ok true)
	)
)

(define-public (transfer-memo (token-id uint) (amount uint) (sender principal) (recipient principal) (memo (buff 34)))
	(begin
		(try! (transfer token-id amount sender recipient))
		(print memo)
		(ok true)
	)
)

(define-private (transfer-many-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer (get token-id item) (get amount item) (get sender item) (get recipient item)) prev-err previous-response)
)

(define-public (transfer-many (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal})))
	(fold transfer-many-iter transfers (ok true))
)

(define-private (transfer-many-memo-iter (item {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)}) (previous-response (response bool uint)))
	(match previous-response prev-ok (transfer-memo (get token-id item) (get amount item) (get sender item) (get recipient item) (get memo item)) prev-err previous-response)
)

(define-public (transfer-many-memo (transfers (list 200 {token-id: uint, amount: uint, sender: principal, recipient: principal, memo: (buff 34)})))
	(fold transfer-many-memo-iter transfers (ok true))
)

(define-public (mint (token-id uint) (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (ft-mint? semi-fungible-token amount recipient))
		(try! (tag-nft-token-id {token-id: token-id, owner: recipient}))
		(set-balance token-id (+ (get-balance-uint token-id recipient) amount) recipient)
		(map-set token-supplies token-id (+ (unwrap-panic (get-total-supply token-id)) amount))
		(print {type: ""sft_mint"", token-id: token-id, amount: amount, recipient: recipient})
		(ok true)
	)
)

(define-private (tag-nft-token-id (nft-token-id {token-id: uint, owner: principal}))
	(begin
		(and
			(is-some (nft-get-owner? semi-fungible-token-id nft-token-id))
			(try! (nft-burn? semi-fungible-token-id nft-token-id (get owner nft-token-id)))
		)
		(nft-mint? semi-fungible-token-id nft-token-id (get owner nft-token-id))
	)
)"
"How can we design a Clarity smart contract for a Stacks blockchain-based stablecoin that supports bridging, adheres to the SIP-10 standard, and includes features like administrative control, minting/burning, pausing, address banning, and an extension system for interaction with authorized contracts? The token should handle decimals precisely, have configurable metadata, emit events for all operations, and start in a paused state.","The contract begins by defining multiple traits, including SIP-10 for standard token functionality, and others for bridging and extensibility.  Error codes, starting at u10000, are defined as constants for consistent error handling. State is managed using data variables and maps. Token metadata is stored as string variables.  Token balances are managed with the `fungible-token` type. Maps track minter allowances and bans, and data-var to manage pausing. Security centers around an ownership model; sensitive operations necessitate the caller to be the owner. The token starts paused, requiring owner activation. Minting uses a dual-map system (allowance and usage tracking). Standard SIP-10 functions are implemented. Administrative functions consistently verify authorization, perform the task, emit an event, and indicate success. Address banning prevents transfers to/from banned addresses. An extension system grants authorized contracts controlled access via `as-contract`. Thorough error handling is present in all functions via validations, `unwrap!`, and match expressions, and token supports memo field for compliance and tracking.",";; title: circle-usdce-token
;; version:
;; summary:
;; description:

(impl-trait 'SP2J933XB2CP2JQ1A4FGN8JA968BBG3NK3EKZ7Q9F.hk-tokens-v1.sip10-token)
(impl-trait .token-traits.allbrige-bridged-token-trait)
(impl-trait .token-traits.extendable-token-actions-v1)
(impl-trait .token-traits.extendable-token)

(use-trait token-extension .token-traits.token-extension)
(use-trait extendable-token-actions-v1 .token-traits.extendable-token-actions-v1)

(define-constant ERR-NOT-AUTHORIZED (err u10000))
(define-constant ERR-MINT-ALLOWANCE-OVERFLOW (err u10001))
(define-constant ERR-PRINCIPAL-INVALID (err u10002))
(define-constant ERR-AMOUNT-INVALID (err u10003))
(define-constant ERR-TOKEN-PAUSED (err u10004))

(define-constant PRECISION u8)
(define-map authorized-extensions principal bool)

(define-data-var token-uri (string-utf8 256) u""http://url.to/token-metadata.json"")
(define-data-var name (string-ascii 32) ""USDC.e (Bridged by X)"")
(define-data-var symbol (string-ascii 32) ""USDC.e"")
(define-data-var contract-owner principal contract-caller)

(define-fungible-token token-data)

(define-map minters-allowances principal uint)

(define-map minters-allowances-tracking principal uint)

(define-data-var token-pause bool true)

(define-public (set-minter-allowance (minter principal) (allowance uint))
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Update minter's allowance
		(map-set minters-allowances minter allowance)
		;; Emit an event to increase observability
		(print { type: ""allowance"", action: ""update"", object: { minter: minter, allowance: allowance } })
		;; Ok response
		(ok { minter: minter, allowance: allowance })))

(define-read-only (is-token-paused)
  	(ok (var-get token-pause)))

(define-public (pause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Pause token
		(var-set token-pause true)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

(define-public (unpause-token)
	(begin
		;; Ensure that the actor calling this contract is allowed to do so
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Unpause token
		(var-set token-pause false)
		;; Emit an event to increase observability
		(print { type: ""token"", action: ""paused"" })
		;; Ok response
		(ok true)))

;;;; SIP-10 trait implementation
;; The logic of these functions will not be upgradable.
;; Constraint: we'd need to have them right from the get go.

(define-read-only (get-total-supply)
  	(ok (ft-get-supply token-data)))

(define-read-only (get-name)
  	(ok (var-get name)))

(define-read-only (get-symbol)
  	(ok (var-get symbol)))

(define-read-only (get-decimals)
   	(ok PRECISION))

(define-read-only (get-balance (account principal))
  	(ok (ft-get-balance token-data account)))

(define-read-only (get-token-uri)
  	(ok (some (var-get token-uri))))

(define-public (transfer 
		(amount uint) 
		(sender principal) 
		(recipient principal) 
		(memo (optional (buff 34))))
	;; All-bridge requirement - To be explored
	(transfer! amount sender recipient memo))

;;;; Ownership management

(define-read-only (get-contract-owner)
  	(ok (var-get contract-owner)))

(define-public (set-contract-owner (owner principal))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(asserts! (is-standard owner) ERR-NOT-AUTHORIZED)
		(ok (var-set contract-owner owner))))

;;;; Token Extensions
;;;; Functions available for the token extensions

(define-public (set-token-uri (value (string-utf8 256)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set token-uri value))))

(define-public (set-token-name (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set name value))))

(define-public (set-token-symbol (value (string-ascii 32)))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(ok (var-set symbol value))))

(define-map banned-addresses principal bool)

(define-public (ban-address (address principal))
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-set banned-addresses address true)
		(ok address)))

(define-public 
	(unban-address 
		(address principal)
	)
	(begin
		;; Check ACL
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ban address
		(map-delete banned-addresses address)
		(ok address)))

;; Mint tokens
(define-public (mint! (recipient principal) (amount uint) (memo (optional (buff 34))))
	(let ((minting-allowance (unwrap! (map-get? minters-allowances contract-caller) ERR-NOT-AUTHORIZED))
		  (minted-pre-op (default-to u0 (map-get? minters-allowances-tracking contract-caller)))
		  (minted-post-op (+ minted-pre-op amount)))
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that minter can mint
		(asserts! (>= amount u0) ERR-AMOUNT-INVALID)
		;; Ensure that minter can mint
		(asserts! (>= minting-allowance minted-post-op) ERR-MINT-ALLOWANCE-OVERFLOW)
		;; Mint tokens
		(unwrap-panic (ft-mint? token-data amount recipient))
		;; Update allowance tracking
		(map-set minters-allowances-tracking contract-caller minted-post-op)
		;; Emit memo event
		(print memo)
		;; Return Ok
		(ok true)))

;; Burn tokens
(define-public (burn! (sender principal) (amount uint) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		(match 
			(ft-burn? token-data amount sender)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Transfer tokens
(define-public (transfer! 
		(amount uint)
		(sender principal)
		(recipient principal)
		(memo (optional (buff 34))))
	(begin 
		;; Ensure amount is positive
		(asserts! (> amount u0) ERR-AMOUNT-INVALID)
		;; Ensure the sender is not banned
		(asserts! (is-none (map-get? banned-addresses sender)) ERR-NOT-AUTHORIZED)
		;; Ensure the recipient is not banned
		(asserts! (is-none (map-get? banned-addresses recipient)) ERR-NOT-AUTHORIZED)
		;; Ensure that token is not paused
		(asserts! (is-eq (var-get token-pause) false) ERR-TOKEN-PAUSED)
		;; Ensure that send tokens are owned by the tx-sender
		(asserts! (is-eq sender tx-sender) ERR-NOT-AUTHORIZED)
		(match 
			(ft-transfer? token-data amount sender recipient)
			response (begin
				(print memo)
				(ok response)
			)
			error (err error))))

;; Extension management

(define-public (authorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""authorized"", object: { extension: extension } })
        (map-insert authorized-extensions (contract-of extension) true)
        (ok true)))

(define-public (deauthorize-extension (extension <token-extension>))
	(begin 
		(asserts! (is-eq contract-caller (var-get contract-owner)) ERR-NOT-AUTHORIZED)
		(print { type: ""extension"", action: ""deprecated"", object: { extension: extension } })
        (map-delete authorized-extensions (contract-of extension))
        (ok true)))

(define-public (run-extension! 
		(self <extendable-token-actions-v1>)
		(extension <token-extension>)
		(payload (buff 8192)))
	(begin
        (asserts! (is-eq (as-contract tx-sender) (contract-of self)) ERR-NOT-AUTHORIZED)
        (asserts! (is-eq (map-get? authorized-extensions (contract-of extension)) (some true)) ERR-NOT-AUTHORIZED)
		(as-contract (contract-call? extension run! self payload))))"
"Develop a Clarity smart contract for the Stacks blockchain that simulates a basic bank or piggy bank.  Users should be able to deposit and withdraw STX tokens. The contract must track user balances, offer secure deposit functionality, and showcase several withdrawal methods, each demonstrating different security approaches (including a deliberately insecure one for learning purposes).  It needs a read-only function for checking balances, administrative controls enabling a designated bank owner to withdraw from any account, and a time-locked withdrawal feature that activates after a specified block height. The contract should be well-commented, explaining security aspects, input validation methods, and proper error handling using constants. The contract must show use of Clarity's security features such as assertions, and if statements.","The solution will involve creating a Clarity smart contract that fulfills all listed banking features. First, it is necessary to define error constants for the contract to enable consistent error handling. A data map named ""accounts"" will store user balances, associating principals with their STX token balances. The `deposit` function will manage STX deposits, incrementing user balances accordingly. Multiple withdrawal functions will be implemented, demonstrating different security levels. One should be intentionally unsafe to expose vulnerabilities. Others will utilize assertions and `if` conditional checks to show secure patterns. A `get-balance` read-only function will address retrieving the user balance. Administrative functions allowing a bank owner to withdraw from user accounts will be included, as well as and a time-locked withdrawal function.  Detailed comments will explain security considerations, input validation, and error handling techniques, showing effective use of Clarity's built-in features that enhance contract security.",";; bank
;; This contract serves as a simple piggy bank, where users can deposit STX
;; and withdrawal it later. It serves as an example program to demonstrate
;; features of the check-checker.

;; constants
(define-constant err-insufficient-balance (err u1))
(define-constant err-unauthorized (err u2))

;; data maps and vars
(define-map accounts { holder: principal } { amount: int })

;; public functions

;; A user deposits money into the piggy bank.
(define-public (deposit (amount uint))
    (let ((balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))))
        ;; A user should be allowed to specify any amount to deposit, and the
        ;; `stx-transfer?` will fail and rollback all operations if the sender
        ;; does not have enough STX, so it is safe to allow the unchecked data
        ;; here.
        ;; #[allow(unchecked_data)]
        (map-set accounts {holder: tx-sender} {amount: (+ balance (to-int amount))})
        (stx-transfer? amount tx-sender (as-contract tx-sender))
    )
)

;; A user withdrawals from the piggy bank.
;; This unsafe implementation of withdrawal forgets to include a check on the
;; amount. See the tests for what can happen!
(define-public (withdrawal-unsafe (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
         ;; `balance` is tainted by the untrusted input, `amount`, so the
         ;; check-checker reports a warning when it is written into a map.
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        ;; `amount` is untrusted input, so it is dangerous to use it in a
        ;; `stx_transfer?` call.
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; A user withdrawals from the piggy bank.
(define-public (withdrawal (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; This `asserts!` is a check on `amount`, allowing it to be used
        ;; without warnings from the check-checker.
        (asserts! (>= balance (to-int amount)) err-insufficient-balance)
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; A user withdrawals from the piggy bank.
;; This version of withdrawal uses an 'if'.
(define-public (withdrawal-if (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; Here is another example of a way to check the untrusted input.
        (if (<= (to-int amount) balance)
            (begin
                (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
                (as-contract (stx-transfer? amount tx-sender customer))
            )
            err-insufficient-balance
        )
    )
)

;; Check that the amount is less than or equal to the balance.
(define-private (check-balance (amount uint))
    (let ((balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))))
        (asserts! (<= (to-int amount) balance) err-insufficient-balance)
        (ok true)
    )
)

;; A user withdrawals from the piggy bank.
;; This version of withdrawal calls another function to perform the check.
(define-public (withdrawal-callee-filter (amount uint))
    (let (
          (balance (default-to 0 (get amount (map-get? accounts {holder: tx-sender}))))
          (customer tx-sender)
         )
        ;; This call to `check-balance` serves as a check on `amount`, if the
        ;; `callee_filter` option is enabled.
        (try! (check-balance amount))
        (map-set accounts {holder: tx-sender} {amount: (- balance (to-int amount))})
        (as-contract (stx-transfer? amount tx-sender customer))
    )
)

;; Retrieve the sender's balance.
(define-read-only (get-balance)
    (default-to 0 (get amount (map-get? accounts {holder: tx-sender})))
)

(define-data-var bank-owner principal tx-sender)

;; The owner of the bank can take money from any account.
(define-public (take (amount uint) (from principal))
    (let (
          (balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) (to-int amount)))
          (banker tx-sender)
        )
        ;; When the `trusted_sender` option is enabled, the check on
        ;; `tx-sender` below tells the check-checker that this is a trusted
        ;; sender, so we trust all inputs. If you disable this option (in
        ;; Clarinet.toml) you will see warnings on the uses below.
        (asserts! (is-eq tx-sender (var-get bank-owner)) err-unauthorized)
        (map-set accounts {holder: from} {amount: balance})
        (as-contract (stx-transfer? amount tx-sender banker))
    )
)

(define-data-var expiration-height uint u100)

;; If a certain block has passed, any user can take money out of any account.
(define-public (take-after-time (amount uint) (from principal))
    (let ((balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) (to-int amount))))
        (asserts! (>= balance (to-int amount)) err-insufficient-balance)
        ;; The annotation `filter(from)` tells the check-checker to consider
        ;; the variable `from` to be considered filtered by the asserts below.
        ;; Without this annotation, the check-checker would report a warning
        ;; on the `map-set`.
        ;; #[filter(from)]
        (asserts! (> block-height (var-get expiration-height)) err-unauthorized)
        (map-set accounts {holder: from} {amount: balance})
        (stx-transfer? amount (as-contract tx-sender) tx-sender)
    )
)"
"Develop a Clarity smart contract for a Stacks blockchain-based fundraising campaign. This contract should accept donations in STX and sBTC.  It needs functions for setting a funding goal and duration (defaulting to ~30 days in Bitcoin blocks) during initialization, tracking donations per donor, allowing the owner to cancel the campaign, enabling donor refunds if canceled, and permitting the beneficiary to withdraw funds post-campaign. Include error handling, getter functions for checking status and donations, and authorization checks for all functions. The contract should track total donations, status, and individual contributions.","The goal is to create a Stacks fundraising contract. State management is crucial for donations, campaign status, and secure transactions. Core state variables include initialization status, cancellation flag, withdrawal status, beneficiary, duration, start time, goal, and donation tracking. Data variables maintain contract state. Individual donations are tracked via maps (one for STX, one for sBTC) using donor addresses as keys. Error constants enhance readability/maintainability, providing feedback on failures. Initialization requires ownership checks, prevents double-initialization, and sets parameters; a default duration is included. Campaign management includes cancellation/fund handling with authorization and initialization checks, preventing cancellation post-withdrawal.  Donation functions for STX and sBTC verify campaign status, check end time, transfer funds, update donor records, and increase totals. Withdrawal requires authorization, checks for active campaign and prior withdrawal, and verifies the end time before transferring STX and sBTC. Refunds work only after cancellation, returning funds and cleaning records. Read-only getter functions enable checking donations, metrics, and contract balance. The implementation covers campaign lifecycle, donations, withdrawals/refunds with authorization and state management.",";; Fundraising Campaign Contract
;; A simple contract to accept crypto donations in STX or sBTC.

;; Constants 
(define-constant contract-owner tx-sender)
(define-constant err-not-authorized (err u100))
(define-constant err-campaign-ended (err u101))
(define-constant err-not-initialized (err u102))
(define-constant err-not-cancelled (err u103))
(define-constant err-campaign-not-ended (err u104))
(define-constant err-campaign-cancelled (err u105))
(define-constant err-already-initialized (err u106))
(define-constant err-already-withdrawn (err u107))

(define-constant default-duration u4320) ;; Duration in *Bitcoin* blocks. This default value means is if a block is 10 minutes, this is roughly 30 days.

;; Data vars
(define-data-var is-campaign-initialized bool false)
(define-data-var is-campaign-cancelled bool false)
(define-data-var beneficiary principal contract-owner)
(define-data-var campaign-duration uint u173000)
(define-data-var campaign-start uint u0)
(define-data-var campaign-goal uint u0)
(define-data-var total-stx uint u0) ;; in microstacks
(define-data-var total-sbtc uint u0) ;; in sats
(define-data-var donation-count uint u0)
(define-data-var is-campaign-withdrawn bool false)

;; Maps
(define-map stx-donations principal uint)  ;; donor -> amount
(define-map sbtc-donations principal uint) ;; donor -> amount

;; Initialize the campaign (goal in US dollars)
;; Pass duration as 0 to use the default duration (~30 days)
;; Can only be called once
(define-public (initialize-campaign (goal uint) (duration uint))
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (not (var-get is-campaign-initialized)) err-already-initialized)
    (var-set is-campaign-initialized true)
    (var-set campaign-start burn-block-height)
    (var-set campaign-goal goal)
    (var-set campaign-duration duration)
    (var-set campaign-duration (if (is-eq duration u0) 
      default-duration
      duration))
    (ok true)))

;; Cancel the campaign
;; Only the owner can call this, at any time during or after the campaign
;; Allows donors to get a refund
;; Can only be called once
(define-public (cancel-campaign)
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-not-authorized)
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (var-set is-campaign-cancelled true)
    (ok true)))

;; Donate STX. Pass amount in microstacks.
(define-public (donate-stx (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set stx-donations tx-sender 
      (+ (default-to u0 (map-get? stx-donations tx-sender)) amount))
    (var-set total-stx (+ (var-get total-stx) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Donate sBTC. Pass amount in Satoshis.
(define-public (donate-sbtc (amount uint))
  (begin
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (< burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))) 
              err-campaign-ended)
    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
      amount 
      contract-caller
      (as-contract tx-sender) 
      none))
    (map-set sbtc-donations tx-sender
      (+ (default-to u0 (map-get? sbtc-donations tx-sender)) amount))
    (var-set total-sbtc (+ (var-get total-sbtc) amount))
    (var-set donation-count (+ (var-get donation-count) u1))
    (ok true)))

;; Withdraw funds (only beneficiary, only if campaign is ended)
(define-public (withdraw)
  (let (
    (total-stx-amount (var-get total-stx))
    (total-sbtc-amount (var-get total-sbtc))
  )
    (asserts! (var-get is-campaign-initialized) err-not-initialized)
    (asserts! (not (var-get is-campaign-cancelled)) err-campaign-cancelled)
    (asserts! (not (var-get is-campaign-withdrawn)) err-already-withdrawn)
    (asserts! (is-eq tx-sender (var-get beneficiary)) err-not-authorized)
    (asserts! (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration)))
              err-campaign-not-ended)
    (as-contract
      (begin
        (if (> total-stx-amount u0)
          (try! (stx-transfer? total-stx-amount (as-contract tx-sender) (var-get beneficiary)))
          true)
        (if (> total-sbtc-amount u0)
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            total-sbtc-amount
            (as-contract tx-sender)
            (var-get beneficiary)
            none))
          true)
        (var-set is-campaign-withdrawn true)
        (ok true)))))

;; Refund to donor
;; Campaign owner can choose to allow this by cancelling the campaign
(define-public (refund)
  (let (
    (stx-amount (default-to u0 (map-get? stx-donations tx-sender)))
    (sbtc-amount (default-to u0 (map-get? sbtc-donations tx-sender)))
    (contributor tx-sender)
  )
    (asserts! (var-get is-campaign-cancelled) err-not-cancelled)
    (if (> stx-amount u0)
      (begin
        (as-contract
          (try! (stx-transfer? stx-amount tx-sender contributor))))
      true)
      (map-delete stx-donations tx-sender)
    (if (> sbtc-amount u0)
      (begin
        (as-contract
          (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
            sbtc-amount
            tx-sender
            contributor
            none))))
      true)
      (map-delete sbtc-donations tx-sender)
    (ok true)))

;; Getter functions
(define-read-only (get-stx-donation (donor principal))
  (ok (default-to u0 (map-get? stx-donations donor))))

(define-read-only (get-sbtc-donation (donor principal))
  (ok (default-to u0 (map-get? sbtc-donations donor))))

(define-read-only (get-campaign-info)
  (ok {
    start: (var-get campaign-start),
    end: (+ (var-get campaign-start) (var-get campaign-duration)),
    goal: (var-get campaign-goal),
    totalStx: (var-get total-stx),
    totalSbtc: (var-get total-sbtc),
    donationCount: (var-get donation-count),
    isExpired: (>= burn-block-height (+ (var-get campaign-start) (var-get campaign-duration))),
    isWithdrawn: (var-get is-campaign-withdrawn),
    isCancelled: (var-get is-campaign-cancelled),
  }))

(define-read-only (get-contract-balance)
  (stx-get-balance (as-contract tx-sender)))"
"Develop a Clarity smart contract for the Stacks Blockchain that enables payment streaming. This contract should facilitate the gradual transfer of sBTC from a sender to a receiver over a defined period (measured in blocks). It should support creating new streams, adding funds to existing ones, allowing recipients to withdraw earned funds, enabling senders to reclaim unstreamed funds after the stream's completion, and permitting mutually agreed-upon modifications to stream details, verified via cryptographic signatures.  The contract should store stream data, including sender, recipient, total deposit, amount withdrawn, rate of payment, and start/end blocks.  Incorporate error handling for unauthorized actions, incorrect signatures, actions on active/inactive streams, and invalid stream IDs. Provide helper functions for calculating available balances and the number of elapsed blocks.","The goal is to create a Stacks/Clarity smart contract for streaming sBTC payments. This means payments are transferred gradually over time (measured in blocks), not all at once. The contract needs mappings to store each stream's details (sender, receiver, amount, rate, start/end blocks, withdrawn amount) using unique stream IDs.  A stream ID counter will ensure unique IDs. The 'stream-to' function will create a new stream, transferring the initial sBTC deposit from the sender to the contract and setting the stream's parameters. 'Refuel' will allow the sender to add more sBTC to an existing stream. To calculate the streamed amount, helper functions 'calculate-block-delta' (determine elapsed blocks) and 'balance-of' (calculate available amounts for sender/receiver based on the rate and elapsed time) are needed. 'Withdraw' will allow the recipient to claim their accumulated sBTC.  'Refund' will allow the sender to reclaim any remaining sBTC *after* the stream's end block. An 'update-details' function, secured by cryptographic signatures from both parties ('hash-stream' and 'validate-signature' facilitate this), will allow modifications to the stream's terms.  Robust error handling is crucial, covering unauthorized access, bad signatures, actions on active/finished streams, and nonexistent stream IDs. Read-only functions (like 'balance-of') optimize gas usage.  sBTC token transfers will use the standard token interface ('contract-call?') and the 'as-contract' pattern to ensure the contract controls fund transfers.",";; payment-stream.clar

;; Error codes
(define-constant ERR_UNAUTHORIZED (err u0))
(define-constant ERR_INVALID_SIGNATURE (err u1))
(define-constant ERR_STREAM_STILL_ACTIVE (err u2))
(define-constant ERR_INVALID_STREAM_ID (err u3))

;; Data vars
(define-data-var latest-stream-id uint u0)
(define-data-var nonce uint u0)

;; Streams mapping
(define-map streams
    uint  ;; stream-id
    {
        sender: principal,
        recipient: principal,
        balance: uint,
        withdrawn-balance: uint,
        payment-per-block: uint,
        timeframe: (tuple (start-block uint) (stop-block uint))
    }
)

;; Create a new stream
(define-public (stream-to
    (recipient principal)
    (initial-balance uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (payment-per-block uint)
)
    (let (
        (stream {
            sender: contract-caller,
            recipient: recipient,
            balance: initial-balance,
            withdrawn-balance: u0,
            payment-per-block: payment-per-block,
            timeframe: timeframe
        })
        (current-stream-id (var-get latest-stream-id))
    )
        ;; Transfer sBTC from sender to contract
        (try! (contract-call?
            .sbtc-token
            transfer
            initial-balance
            contract-caller
            (as-contract tx-sender)
            none
        ))
        (map-set streams current-stream-id stream)
        (var-set latest-stream-id (+ current-stream-id u1))
        (ok current-stream-id)
    )
)

;; Increase the locked sBTC balance for a stream
(define-public (refuel
    (stream-id uint)
    (amount uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (try! (contract-call?
      .sbtc-token
      transfer
      amount
      contract-caller
      (as-contract tx-sender)
      none
    ))
    (map-set streams stream-id
      (merge stream {balance: (+ (get balance stream) amount)})
    )
    (ok amount)
  )
)

;; Check balance for a party involved in a stream
(define-read-only (balance-of
    (stream-id uint)
    (who principal)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) u0))
    (block-delta (calculate-block-delta (get timeframe stream)))
    (recipient-balance (* block-delta (get payment-per-block stream)))
  )
    (if (is-eq who (get recipient stream))
      (- recipient-balance (get withdrawn-balance stream))
      (if (is-eq who (get sender stream))
        (- (get balance stream) recipient-balance)
        u0
      )
    )
  )
)

;; Calculate the number of blocks a stream has been active
(define-read-only (calculate-block-delta
    (timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (start-block (get start-block timeframe))
    (stop-block (get stop-block timeframe))

    (delta
      (if (<= block-height start-block)
        ;; then
        u0
        ;; else
        (if (< block-height stop-block)
          ;; then
          (- block-height start-block)
          ;; else
          (- stop-block start-block)
        )
      )
    )
  )
    delta
  )
)

;; Withdraw received tokens
(define-public (withdraw
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id contract-caller))
  )
    (asserts! (is-eq contract-caller (get recipient stream)) ERR_UNAUTHORIZED)
    (map-set streams stream-id
      (merge stream {withdrawn-balance: (+ (get withdrawn-balance stream) balance)})
    )
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get recipient stream)
      none
    )))
    (ok balance)
  )
)

;; Withdraw excess locked tokens
(define-public (refund
    (stream-id uint)
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
    (balance (balance-of stream-id (get sender stream)))
  )
    (asserts! (is-eq contract-caller (get sender stream)) ERR_UNAUTHORIZED)
    (asserts! (< (get stop-block (get timeframe stream)) block-height) ERR_STREAM_STILL_ACTIVE)
    (map-set streams stream-id (merge stream {
        balance: (- (get balance stream) balance),
      }
    ))
    (try! (as-contract (contract-call?
      .sbtc-token
      transfer
      balance
      tx-sender
      (get sender stream)
      none
    )))
    (ok balance)
  )
)

;; Get hash of stream
(define-read-only (hash-stream
    (stream-id uint)
    (new-payment-per-block uint)
    (new-timeframe (tuple (start-block uint) (stop-block uint)))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) (sha256 0)))
    (msg (concat (concat (unwrap-panic (to-consensus-buff? stream)) (unwrap-panic (to-consensus-buff? new-payment-per-block))) (unwrap-panic (to-consensus-buff? new-timeframe))))
  )
    (sha256 msg)
  )
)

;; Signature verification
(define-read-only (validate-signature (hash (buff 32)) (signature (buff 65)) (signer principal))
  (is-eq
    (principal-of? (unwrap! (secp256k1-recover? hash signature) false))
    (ok signer)
  )
)

;; Update stream configuration
(define-public (update-details
    (stream-id uint)
    (payment-per-block uint)
    (timeframe (tuple (start-block uint) (stop-block uint)))
    (signer principal)
    (signature (buff 65))
  )
  (let (
    (stream (unwrap! (map-get? streams stream-id) ERR_INVALID_STREAM_ID))
  )
    (asserts! (validate-signature (hash-stream stream-id payment-per-block timeframe) signature signer) ERR_INVALID_SIGNATURE)
    (asserts!
      (or
        (and (is-eq (get sender stream) contract-caller) (is-eq (get recipient stream) signer))
        (and (is-eq (get sender stream) signer) (is-eq (get recipient stream) contract-caller))
      )
      ERR_UNAUTHORIZED
    )
    (map-set streams stream-id (merge stream {
        payment-per-block: payment-per-block,
        timeframe: timeframe
    }))
    (ok true)
  )
)"
"Develop a Clarity smart contract for the Stacks blockchain named ""timelocked-wallet"". This contract should function as a time-locked wallet, enabling the contract owner to deposit STX tokens for a specified beneficiary, which can only be claimed after a predetermined block height. The contract must include: 1. A `lock` function for the owner to deposit tokens, set the beneficiary, and specify the future unlock block height. 2. A `bestow` function allowing the current beneficiary to transfer their beneficiary rights to another principal. 3. A `claim` function for the beneficiary to withdraw the tokens once the unlock block height has been reached. Implement comprehensive error handling to ensure only the owner can perform owner actions, prevent double-locking, enforce future unlock heights, validate deposit amounts, restrict beneficiary-specific actions, and prevent early withdrawals. Utilize data variables to store the beneficiary (initially unset) and the unlock height (initially zero). Include comments explaining its functionality.","The task is to create a Clarity smart contract for a time-locked wallet on Stacks. This involves understanding Clarity syntax and blockchain elements like principals, transfers, and block heights. The core requirements are a wallet that locks STX until a set block height, with `lock`, `bestow`, and `claim` functions. The owner locks tokens for a beneficiary, who can transfer rights or claim tokens post-unlock height. The contract should start with comments explaining its function. The contract deployer is set as the owner. Define error constants for clarity. Data variables track the beneficiary (optional principal, initially none) and unlock height (uint, initially zero). The `lock` function validates that the sender is the owner, no beneficiary exists (no double-locking), the unlock height is in the future, and the amount is positive. It transfers STX, sets beneficiary and unlock height, returning `ok`. `bestow` lets the current beneficiary transfer rights, updating the beneficiary after validating the sender. `claim` lets the beneficiary withdraw after the unlock height, validating the sender and height. The contract uses `stx-get-balance` for a full withdrawal and `unwrap-panic` for the beneficiary (safe due to prior assertion). Error constants provide informative messages. The contract addresses all requirements, prioritizing security, usability, and maintainability using Clarity's type system and following best practices.",";; timelocked-wallet
;; A time-locked vault contract that becomes eligible to claim by the beneficiary after a certain block-height has been reached.

;; Owner
(define-constant contract-owner tx-sender)

;; Errors
(define-constant err-owner-only (err u100))
(define-constant err-already-locked (err u101))
(define-constant err-unlock-in-past (err u102))
(define-constant err-no-value (err u103))
(define-constant err-beneficiary-only (err u104))
(define-constant err-unlock-height-not-reached (err u105))

;; Data
(define-data-var beneficiary (optional principal) none)
(define-data-var unlock-height uint u0)

(define-public (lock (new-beneficiary principal) (unlock-at uint) (amount uint))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(asserts! (is-none (var-get beneficiary)) err-already-locked)
		(asserts! (> unlock-at block-height) err-unlock-in-past)
		(asserts! (> amount u0) err-no-value)
		(try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
		(var-set beneficiary (some new-beneficiary))
		(var-set unlock-height unlock-at)
		(ok true)
	)
)

(define-public (bestow (new-beneficiary principal))
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(var-set beneficiary (some new-beneficiary))
		(ok true)
	)
)

(define-public (claim)
	(begin
		(asserts! (is-eq (some tx-sender) (var-get beneficiary)) err-beneficiary-only)
		(asserts! (>= block-height (var-get unlock-height)) err-unlock-height-not-reached)
		(as-contract (stx-transfer? (stx-get-balance tx-sender) tx-sender (unwrap-panic (var-get beneficiary))))
	)
)"
"Create a Stacks Clarity smart contract for a fungible token named ""Clarity Coin"" (symbol ""CC"") conforming to the SIP-010 standard. The token should have an unlimited supply, mintable only by the contract owner.  The contract must include standard functions like `transfer` (verifying the sender and accepting an optional memo) and all SIP-010 read-only functions (`get-name`, `get-symbol`, `get-decimals`, `get-balance`, `get-total-supply`, `get-token-uri`). Define error constants for unauthorized minting and transfer attempts.","1. **Implement SIP-010 Trait:** Begin by implementing the SIP-010 trait to ensure the contract meets the fungible token standard interface.
2. **Establish Ownership and Error Codes:** Define a contract owner (the deployer) and error codes for unauthorized minting (`err-owner-only`) and invalid transfers (`err-not-token-owner`).
3. **Create the Token:** Define the fungible token 'clarity-coin' without a supply cap.
4. **Implement `transfer` Function:** Create a `transfer` function that takes amount, sender, recipient, and an optional memo. It must:
    - Verify that `tx-sender` is the same as the provided `sender`.
    - Perform the token transfer using `ft-transfer?`.
    - Handle the optional memo: print it if provided, or return a default value if not.
5. **Implement SIP-010 Read-Only Functions:**
    - `get-name`: Return ""Clarity Coin"".
    - `get-symbol`: Return ""CC"".
    - `get-decimals`: Return `u0` (no decimals).
    - `get-balance`: Use `ft-get-balance` to get a principal's balance.
    - `get-total-supply`: Use `ft-get-supply` to get the total supply.
    - `get-token-uri`: Return `none` (no URI specified).
6. **Implement `mint` Function:** Create a `mint` function that takes an amount and recipient.  It should:
    - Check if the caller is the contract owner.
    - Mint the specified amount to the recipient using `ft-mint?`.
7. **Requirement Verification:** Confirm that all requirements (SIP-010 compliance, sender verification in `transfer`, optional memo, read-only functions, owner-only minting, no maximum supply, and error constants) are met.","(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

;; No maximum supply!
(define-fungible-token clarity-coin)

(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(try! (ft-transfer? clarity-coin amount sender recipient))
		(match memo to-print (print to-print) 0x)
		(ok true)
	)
)

(define-read-only (get-name)
	(ok ""Clarity Coin"")
)

(define-read-only (get-symbol)
	(ok ""CC"")
)

(define-read-only (get-decimals)
	(ok u0)
)

(define-read-only (get-balance (who principal))
	(ok (ft-get-balance clarity-coin who))
)

(define-read-only (get-total-supply)
	(ok (ft-get-supply clarity-coin))
)

(define-read-only (get-token-uri)
	(ok none)
)

(define-public (mint (amount uint) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(ft-mint? clarity-coin amount recipient)
	)
)"
"Develop a Clarity smart contract for a Stacks blockchain NFT collection named ""stacksies"". This contract should adhere to the nft-trait standard and feature sequential token IDs. Implement functionalities for minting (restricted to the contract owner), transferring (restricted to token owners), and querying token details (last token ID, URI, and owner). Include error handling to enforce these restrictions and follow Clarity's best practices.","The task is to build a Stacks NFT contract using Clarity. This contract needs to implement the `nft-trait` standard, manage a collection called ""stacksies"", and provide specific functions with access controls. The contract owner should be the only one able to mint, token owners should be able to transfer, and read-only functions should provide token information.

The provided solution's approach is analyzed as follows:
1.  **Trait Implementation:** The code begins by implementing the standard NFT trait, which is crucial for interoperability on Stacks.
2.  **Constants:**  It defines constants for the contract owner (set to the deployer) and error codes, enhancing readability and error handling.
3.  **NFT Definition:** It correctly defines the NFT collection named ""stacksies"" with `uint` token IDs and uses a `last-token-id` data variable to track the sequence.
4.  **Read-Only Functions:** It implements `get-last-token-id`, `get-token-uri` (currently a placeholder), and `get-owner`, fulfilling the query requirements.
5.  **Transfer Function:** The transfer function includes a vital check to ensure only the token owner can initiate a transfer, correctly using `asserts!` and built in `nft-transfer?` function.
6.  **Mint Function:**  The mint function restricts minting to the contract owner, increments the `last-token-id`, mints the token, and updates the ID. This permission check is essential.
7.  **Overall Assessment:** The response effectively implements all specified features, adhering to Clarity standards, incorporating error handling, separates core code into relevant functions, and distinguishes clearly between read-only and public functions.","(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))

(define-non-fungible-token stacksies uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
	(ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
	(ok none)
)

(define-read-only (get-owner (token-id uint))
	(ok (nft-get-owner? stacksies token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
	(begin
		(asserts! (is-eq tx-sender sender) err-not-token-owner)
		(nft-transfer? stacksies token-id sender recipient)
	)
)

(define-public (mint (recipient principal))
	(let
		(
			(token-id (+ (var-get last-token-id) u1))
		)
		(asserts! (is-eq tx-sender contract-owner) err-owner-only)
		(try! (nft-mint? stacksies token-id recipient))
		(var-set last-token-id token-id)
		(ok token-id)
	)
)"
Develop a Stacks smart contract in Clarity that fetches the current BTC/USD price from the Pyth Network via the Stacks-Pyth Bridge. Provide instructions for deploying and testing the contract.,"The goal is to build a Clarity smart contract that gets the live BTC/USD price from Pyth Network using the Stacks-Pyth Bridge. This involves understanding the interaction between Pyth and Stacks, using traits like `pyth-storage-trait` and `pyth-decoder-trait`. First, define constants for contract addresses (Pyth Oracle, storage) and the BTC/USD feed ID (32-byte hex). The core function will use the Pyth Oracle's `get-price` method, passing the feed ID and storage contract address. Context switching with `as-contract` might be necessary for the storage contract. Proper error handling (e.g., `try!`, `unwrap!`) is crucial for issues like invalid addresses or stale data.  A `define-public` function is likely needed, given prior examples and potential state changes.  The function might need to manage errors internally or return a response type. The `pyth-storage-trait` will be integrated. Inline documentation will explain each step, including governance checks, `as-contract` usage, and response handling.  The code structure will be modular for easier testing (e.g., with Clarinet) and maintainability, covering governance, price retrieval, and error handling.",";; Pyth Oracle integration for BTC/USD price feed
(use-trait pyth-storage-trait 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q.pyth-traits-v1.storage-trait)

(define-constant PYTH-ORACLE 'SP3Z6MY8HT7D7KJE0D1BZ4YF40S7RMM9Y8G1B9P5G)
(define-constant PYTH-STORAGE 'SP2JXKMS5S3D5K6Z5X6Y5Q5Q5Y5Q5Y5Q5Y5Q5Y5Q)
(define-constant BTC-USD-FEED-ID 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43)

(define-read-only (get-btc-price)
  (match (contract-call? 
          PYTH-ORACLE 
          get-price 
          BTC-USD-FEED-ID 
          (as-contract PYTH-STORAGE)
         )
    price (ok price)
    err (err err)
  )
)

(define-public (update-btc-price (price-feed-bytes (buff 8192)))
  (begin
    (contract-call? 
      PYTH-ORACLE 
      verify-and-update-price-feeds 
      price-feed-bytes 
      {
        pyth-storage-contract: PYTH-STORAGE,
        pyth-decoder-contract: 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR,
        wormhole-core-contract: 'SP3HXJJMJQ06GNAZ8XWDN1QM48JEDC6PP6W3YZPZJ
      }
    )
  )
)"
"Develop a Clarity smart contract for a fungible token named 'MyToken' (MTK) with 8 decimal places and an initial supply of 21,000,000,000 tokens. Distribute 200 tokens to ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M and 100 tokens to ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9.  The contract should support standard token operations: transferring tokens, approving allowances for other users to spend tokens, checking account balances, viewing the total token supply, revoking spending permissions. Include a link to this off-chain metadata: ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc.","The objective is to create a Clarity smart contract for a fungible token, 'MyToken' (MTK), with specific initial conditions and functionalities. First define the token with 8 decimal places and setup the total supply and initial token allocations. Implement standard token functions, including a mechanism to track and manage allowances, allowing owners to authorize spenders to transact on their behalf. This needs private helper functions for managing allowance. The core functionality should encompass transferring tokens, approving spenders, revoking spender permissions, querying balances, and retrieving the total supply, interacting with metadata. Ensure thorough error handling, secure access controls, and include public and private functions so the contract should be modular, secure, maintainable, and well-documented."," 
(define-fungible-token fungible-token)

;; Storage
(define-map allowances
  ((spender principal) (owner principal))
  ((allowance uint)))
(define-data-var total-supply uint u21000000000)

;; Internals

;; Total number of tokens in existence.
(define-private (get-total-supply)
  (var-get total-supply))

;; Gets the amount of tokens that an owner allowed to a spender.
(define-private (allowance (spender principal) (owner principal))
  (let ((allowance-val (default-to u0 (map-get? allowances (tuple (spender owner))))))
    allowance-val
  )
)


;; Transfers tokens to a specified principal.
(define-private (transfer (amount uint) (sender principal) (recipient principal) )
  (match (ft-transfer? fungible-token amount sender recipient)
    result (ok true)
    error (err false))
)

;; Decrease allowance of a specified spender.
(define-private (decrease-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (or (> amount allowance-val) (<= amount u0))
      true
      (begin
        (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (- allowance-val amount))))
        true)))
        )
        
;; Internal - Increase allowance of a specified spender.
(define-private (increase-allowance (amount uint) (spender principal) (owner principal))
  (let ((allowance-val (allowance spender owner)))
    (if (<= amount u0)
      false
      (begin
         (map-set allowances
          ((spender spender) (owner owner))
          ((allowance-val (+ allowance-val amount))))
        true))))

;; Public functions

;; Transfers tokens to a specified principal.
(define-public (transfer-token (amount uint) (recipient principal) )
  (transfer amount tx-sender recipient)
)

;; Transfers tokens to a specified principal, performed by a spender
(define-public (transfer-from (amount uint) (owner principal) (recipient principal) )
  (let ((allowance (allowance tx-sender owner)))
    (begin
      (if (or (> amount allowance-val) (<= amount u0))
        (err false)
        (if (and
            (unwrap! (transfer amount owner recipient) (err false))
            (decrease-allowance amount tx-sender owner))
        (ok true)
        (err false)))))
)

;; Update the allowance for a given spender
(define-public (approve (amount uint) (spender principal) )
  (if (and (> amount u0)
           (print (increase-allowance amount spender tx-sender )))
      (ok amount)
      (err false)))

;; Revoke a given spender
(define-public (revoke (spender principal))
  (let ((allowance-val (allowance spender tx-sender)))
    (if (and (> allowance-val u0)
             (decrease-allowance allowance-val spender tx-sender))
        (ok 0)
        (err false))))

;; Retrieve the human-readable name of the token
(define-public (get-name)
  ""MyToken""
)

;; Retrieve the ticker symbol of the token
(define-public (get-symbol)
  ""MTK""
)

;; Retrieve the number of decimals used
(define-public (get-decimals)
  8 ;; Assuming 8 decimals
)

;; Retrieve the balance of a specific principal
(define-public (get-balance (owner principal))
  (ft-get-balance fungible-token owner)
)

;; Retrieve the current total supply
(define-public (get-total-supply)
  (var-get total-supply)
)

;; Retrieve an example URI that represents metadata of this token
(define-public (get-token-uri)
  ""ipfs://QmXwNHQ1BmE2hLRykAMMxjsmdeDGFSFg63KDMBUhtcMcKc""
)

;; Mint new tokens.
(define-private (mint (amount uint) (account principal))
  (if (<= amount u0)
      (err false)
      (begin
        (var-set total-supply (+ (var-get total-supply) amount))
        (ft-mint? fungible-token amount account)
        (ok amount))))

;; Initialize the contract
(begin
  (mint u200 'ST398K1WZTBVY6FE2YEHM6HP20VSNVSSPJTW0D53M)
  (mint u100 'ST1JDEC841ZDWN9CKXKJMDQGP5TW1AM10B7EV0DV9))"
"Develop a Clarity smart contract for a Stacks-based multi-signature wallet. This wallet should support adding and removing owners (subject to a confirmation threshold), submitting, confirming, revoking, and executing transactions. It should also facilitate cross-chain token swaps using an external ""magic bridge"" interface. The contract should integrate with SIP-009 (NFT) and SIP-010 (FT) traits for asset transfers. Access control must be enforced through a list of allowed callers, and transaction confirmations must be validated against the owner threshold. Ensure comprehensive error handling for situations like ownership disputes, incorrect input parameters, and unauthorized access attempts. The code should be well-documented with comments, use data maps to store transaction and owner information, and include helper functions for internal updates. Critical operations should be protected by checks for sender authorization and parameter validity.","The code represents a Clarity smart contract for a multi-signature wallet on the Stacks blockchain (Multisafe). The core function: a secure wallet needing multiple confirmations before transaction execution. It begins by importing traits defining behaviors of executors, safes, NFTs, fungible tokens, and a ""magic bridge"" for cross-chain actions. The implementation defines it as a safe, per the safe-trait. Error constants cover wide-ranging failures, including authorization and transaction states. A key feature: the utilization of 'SELF,' representing the contract's principal allowing the contract to perform actions. Key state variables are defined including a list of wallet owners(max 20), a confirmation threshold, and TX nonce (critical for multi-sig functionality). Owner management permits adding/removing with security validation. The confirmation threshold must always remain valid: >0 and <= total owners. TX management employs a flow: submission, confirmation, execution, stored in a map with details and confirmations where owners can submit, confirm, and revoke. Most functions confirm the caller's identity (contract itself or authorized owner) for security. Integration with a ""magic bridge"" enables cross-chain features, letting owners initialize swappers, and execute swaps. A critical detail: setup of initial owners/threshold (three principals, threshold of 2, requiring any 2 of 3 to confirm transactions). Contract achieves: secure, flexible multi-sig wallet with cross-chain capabilities.",";;title: safe-clar

(use-trait executor-trait .traits.executor-trait) 
(use-trait safe-trait .traits.safe-trait)
(use-trait nft-trait .traits.sip-009-trait)
(use-trait ft-trait .traits.sip-010-trait)
(use-trait magic-bridge-trait .traits.magic-bridge-trait)

(impl-trait .traits.safe-trait)

(define-constant ERR-CALLER-MUST-BE-SELF (err u100))
(define-constant ERR-OWNER-ALREADY-EXISTS (err u110))
(define-constant ERR-OWNER-NOT-EXISTS (err u120))
(define-constant ERR-UNAUTHORIZED-SENDER (err u130))
(define-constant ERR-ONLY-END-USER (err u135))
(define-constant ERR-TX-NOT-FOUND (err u140))
(define-constant ERR-TX-ALREADY-CONFIRMED-BY-OWNER (err u150))
(define-constant ERR-TX-INVALID-EXECUTOR (err u160))
(define-constant ERR-INVALID-SAFE (err u170))
(define-constant ERR-TX-CONFIRMED (err u180))
(define-constant ERR-TX-NOT-CONFIRMED-BY-SENDER (err u190))
(define-constant ERR-THRESHOLD-CANT-BE-ZERO (err u210))
(define-constant ERR-OWNER-OVERFLOW (err u220))
(define-constant ERR-THRESHOLD-OVERFLOW (err u230))
(define-constant ERR-TX-INVALID-FT (err u240))
(define-constant ERR-TX-INVALID-NFT (err u250))
(define-constant ERR-MB-ADDRESS-NOT-SET (err u260))
(define-constant ERR-INVALID-MB-ADDRESS (err u270))

(define-constant SELF (as-contract tx-sender))


(define-constant VERSION ""0.0.5.beta"")

(define-read-only (get-version) 
    VERSION
)


(define-data-var owners (list 20 principal) (list)) 

(define-read-only (get-owners)
    (var-get owners)
)

(define-private (add-owner-internal (owner principal))
    (let 
        (
           (new-owners (unwrap! (as-max-len? (append (var-get owners) owner) u20) ERR-OWNER-OVERFLOW))
        )
        (ok (var-set owners new-owners))
    )
)

(define-public (add-owner (owner principal))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (is-none (index-of (var-get owners) owner)) ERR-OWNER-ALREADY-EXISTS)
        (add-owner-internal owner)
    )
)

(define-data-var rem-owner principal tx-sender)

(define-private (remove-owner-filter (owner principal)) (not (is-eq owner (var-get rem-owner))))

(define-public (remove-owner (owner principal))
    (let
        (
            (owners-list (var-get owners))
        )
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (is-some (index-of owners-list owner)) ERR-OWNER-NOT-EXISTS)
        (asserts! (>= (- (len owners-list) u1) (var-get threshold)) ERR-THRESHOLD-OVERFLOW)
        (var-set rem-owner owner)
        (ok (var-set owners (unwrap-panic (as-max-len? (filter remove-owner-filter owners-list) u20))))
    )
)



(define-data-var threshold uint u1)

(define-read-only (get-threshold)
    (var-get threshold)
)

(define-private (set-threshold-internal (value uint))
    (var-set threshold value)
)

(define-public (set-threshold (value uint))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (asserts! (> value u0) ERR-THRESHOLD-CANT-BE-ZERO)
        (asserts! (<= value (len (var-get owners))) ERR-THRESHOLD-OVERFLOW)
        (ok (set-threshold-internal value))
    )
)


(define-data-var nonce uint u0)

(define-read-only (get-nonce)
 (var-get nonce)
)

(define-private (increase-nonce)
    (var-set nonce (+ (var-get nonce) u1))
)



(define-map allowed-callers principal bool)

(define-public (allow-caller (caller principal))
  (begin
    (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
    (ok (map-set allowed-callers caller true))
  )
)

(define-public (revoke-caller (caller principal))
  (begin
    (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
    (ok (map-delete allowed-callers caller))
  )
)

(define-read-only (is-allowed-caller (caller principal))
  (or
    (match (map-get? allowed-callers caller)
      value true
      false
    )
    (is-eq tx-sender caller)
  )
)


(define-read-only (get-info)
    (ok {
        version: (get-version),
        owners: (get-owners),
        threshold: (get-threshold),
        nonce: (get-nonce),
        mb-address: (get-mb-address)
    })
)




(define-map transactions 
    uint 
    {
        executor: principal,
        threshold: uint,
        confirmations: (list 20 principal),
        confirmed: bool,
        param-ft: principal,
        param-nft: principal,
        param-p: (optional principal),
        param-u: (optional uint),
        param-b: (optional (buff 20))
    }
)

(define-private (add (executor <executor-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>) (param-p (optional principal)) (param-u (optional uint)) (param-b (optional (buff 20))))
    (let 
        (
            (tx-id (get-nonce))
        ) 
        (map-insert transactions tx-id {
            executor: (contract-of executor),
            threshold: (var-get threshold), 
            confirmations: (list), 
            confirmed: false,
            param-ft: (contract-of param-ft),
            param-nft: (contract-of param-nft),
            param-p: param-p,
            param-u: param-u,
            param-b: param-b
        })
        (increase-nonce)
        tx-id
    )
)

(define-read-only (get-transaction (tx-id uint))
    (merge {id: tx-id} (unwrap-panic (map-get? transactions tx-id)))
)

(define-read-only (get-transactions (tx-ids (list 20 uint)))
    (map get-transaction tx-ids)
)

(define-data-var rem-confirmation principal tx-sender)

(define-private (remove-confirmation-filter (owner principal)) (not (is-eq owner (var-get rem-confirmation))))


(define-public (revoke (tx-id uint))
    (let 
        (
            (tx (unwrap! (map-get? transactions tx-id) ERR-TX-NOT-FOUND))
            (confirmations (get confirmations tx))
        )
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-eq (get confirmed tx) false) ERR-TX-CONFIRMED)
        (asserts! (is-some (index-of confirmations tx-sender)) ERR-TX-NOT-CONFIRMED-BY-SENDER)
        (var-set rem-confirmation tx-sender)
        (let 
            (
                (new-confirmations  (unwrap-panic (as-max-len? (filter remove-confirmation-filter confirmations) u20)))
                (new-tx (merge tx {confirmations: new-confirmations}))
            )
            (map-set transactions tx-id new-tx)
            (print {action: ""multisafe-revoke"", sender: tx-sender, tx-id: tx-id})
            (ok true)
        )
    )
)


(define-public (confirm (tx-id uint) (executor <executor-trait>) (safe <safe-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>))
    (begin
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (asserts! (is-eq (contract-of safe) SELF) ERR-INVALID-SAFE) 
        (let
            (
                (tx (unwrap! (map-get? transactions tx-id) ERR-TX-NOT-FOUND))
                (confirmations (get confirmations tx))
            )

            (asserts! (is-eq (get confirmed tx) false) ERR-TX-CONFIRMED)
            (asserts! (is-none (index-of confirmations tx-sender)) ERR-TX-ALREADY-CONFIRMED-BY-OWNER)
            (asserts! (is-eq (get executor tx) (contract-of executor)) ERR-TX-INVALID-EXECUTOR)
            (asserts! (is-eq (get param-ft tx) (contract-of param-ft)) ERR-TX-INVALID-FT)
            (asserts! (is-eq (get param-nft tx) (contract-of param-nft)) ERR-TX-INVALID-NFT)
            
            (let 
                (
                    (new-confirmations (unwrap-panic (as-max-len? (append confirmations tx-sender) u20)))
                    (confirmed (>= (len new-confirmations) (get threshold tx)))
                    (new-tx (merge tx {confirmations: new-confirmations, confirmed: confirmed}))
                )
                (map-set transactions tx-id new-tx)
                (and confirmed (try! (as-contract (contract-call? executor execute safe param-ft param-nft (get param-p tx) (get param-u tx) (get param-b tx)))))
                (print {action: ""multisafe-confirmation"", sender: tx-sender, tx-id: tx-id, confirmed: confirmed})
                (ok confirmed)
            )
        )
    )
)

(define-public (submit (executor <executor-trait>) (safe <safe-trait>) (param-ft <ft-trait>) (param-nft <nft-trait>) (param-p (optional principal)) (param-u (optional uint)) (param-b (optional (buff 20))))
    (begin
        (asserts! (is-allowed-caller contract-caller) ERR-ONLY-END-USER)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (asserts! (is-eq (contract-of safe) SELF) ERR-INVALID-SAFE) 
        (let
            ((tx-id (add executor param-ft param-nft param-p param-u param-b)))
            (print {action: ""multisafe-submit"", sender: tx-sender, tx-id: tx-id, executor: executor, param-ft: param-ft, param-nft: param-nft, param-p: param-p, param-u: param-u, param-b: param-b})
            (unwrap-panic (confirm tx-id executor safe param-ft param-nft))
            (ok tx-id)
        )
    )
)


(define-data-var mb-address principal SELF)

(define-public (set-mb-address (address principal))
    (begin
        (asserts! (is-eq tx-sender SELF) ERR-CALLER-MUST-BE-SELF)
        (ok (var-set mb-address address))
    )
)

(define-read-only (get-mb-address)
 (var-get mb-address)
)

(define-public (mb-initialize-swapper (bridge <magic-bridge-trait>))
    (begin
        (asserts! (not (is-eq (var-get mb-address) SELF)) ERR-MB-ADDRESS-NOT-SET)
        (asserts! (is-eq (contract-of bridge) (var-get mb-address)) ERR-INVALID-MB-ADDRESS)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (try! (as-contract (contract-call? bridge initialize-swapper)))
        (ok true)
    )
)

(define-public (mb-escrow-swap 
    (bridge <magic-bridge-trait>)
    (block { header: (buff 80), height: uint })
    (prev-blocks (list 10 (buff 80)))
    (tx (buff 1024))
    (proof { tx-index: uint, hashes: (list 12 (buff 32)), tree-depth: uint })
    (output-index uint)
    (sender (buff 33))
    (recipient (buff 33))
    (expiration-buff (buff 4))
    (hash (buff 32))
    (swapper-buff (buff 4))
    (supplier-id uint)
    (min-to-receive uint)
  )
    (begin
        (asserts! (not (is-eq (var-get mb-address) SELF)) ERR-MB-ADDRESS-NOT-SET)
        (asserts! (is-eq (contract-of bridge) (var-get mb-address)) ERR-INVALID-MB-ADDRESS)
        (asserts! (is-some (index-of (var-get owners) tx-sender)) ERR-UNAUTHORIZED-SENDER)
        (try! (as-contract (contract-call? bridge escrow-swap block prev-blocks tx proof output-index sender recipient expiration-buff hash swapper-buff supplier-id min-to-receive)))
        (ok true)
    )
)

(define-private (init (o (list 20 principal)) (m uint))
    (begin
        (map add-owner-internal o)
        (set-threshold-internal m)
        (print {action: ""multisafe-init""})
    )
)

(init (list 
    'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 
    'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG 
    'ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC
) u2) "
"Create a Stacks blockchain Clarity smart contract that acts as a price oracle for BTC/USD. This oracle should fetch both current and past prices from the Pyth Network's pyth-storage-v3 contract using a specific price feed ID. The contract should include detailed error handling. It needs to support looking up historical prices using both at-block and block header hashes. Additionally, it should connect with the sbtc-token contract to get the total supply of sBTC, adjust values by dividing by 10^8 to maintain accuracy, and calculate the total sBTC value in USD. The contract should handle errors for situations like unsuccessful external calls, bad data, and arithmetic overflow. It should also be well-organized, using read-only functions where applicable, type-safe checks, and clearly defined relationships with other needed traits/contracts.","The contract is designed to get and process BTC/USD prices from the Pyth Network, focusing on being robust to errors and having a modular structure. The error handling uses `ERR_UNEXPECTED` (u5000) to manage unexpected errors consistently. The `get-btc-price` function retrieves the current BTC price by calling `pyth-storage-v3` with `contract-call?` and a specific price feed ID. It returns the price in `some` if successful, or `none` if it fails, to avoid execution issues. The `get-btc-price-at` function retrieves historical prices. It first gets the block hash with `get-stacks-block-info?` and uses `unwrap-panic` to verify it. Then, it calls the price retrieval at that specific block using `at-block`, handling errors like the real-time price function. The contract interacts with the `sbtc-token` contract. The `get-sbtc-total-supply` function gets the total sBTC supply safely using `contract-call?`. The `get-sbtc-total-usd-value` function combines everything: it gets the total sBTC supply, adjusts it by dividing by 10^8, does the same for the BTC price, and multiplies them to calculate the total value in USD. Using `unwrap!` ensures that failures are caught immediately. The contract is well-structured by having all functions as read-only, which keeps state safe and makes reusability better. It manages dependencies on external contracts and uses type safety. By organizing logic into modular and composable function calls, the contract is easy to maintain but at the same time, it is robust.","(define-constant ERR_UNEXPECTED (err u5000))

(define-read-only (get-btc-price)
  (match
    (contract-call?
      'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
      get-price
      0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
    )
    res (some (get price res))
    e none
  )
)

(define-read-only (get-btc-price-at (height uint))
  (let (
    (hash (unwrap-panic (get-stacks-block-info? id-header-hash height)))
  )
    (at-block hash (match
      (contract-call?
        'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3
        get-price
        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43
      )
      res (some (get price res))
      e none
    ))
  )
)

(define-read-only (get-sbtc-total-supply)
  (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-total-supply)
)

(define-read-only (get-sbtc-total-usd-value)
  (let (
    (sbtc-total-supply (/ (unwrap! (get-sbtc-total-supply) ERR_UNEXPECTED) u100000000))
    (btc-price (/ (to-uint (unwrap! (get-btc-price) ERR_UNEXPECTED)) u100000000))
  )
    (ok (* sbtc-total-supply btc-price))
  )
)"
"Create a Clarity smart contract for managing a counter. This contract should include: constant definitions for error codes; storage for a count, an owner, and a cost; read-only functions for retrieving the count at the present and at a past block; and public functions for increasing, decreasing, and adding to the count, with checks for positive counts, addition limits, and correct STX payments based on the cost.","First, define error code constants for readability and maintainability, such as for a non-positive count, adding too much at once, and a failure to retrieve a specified block. Next, declare mutable state variables: 'count' initialized to zero, 'contract-owner' set to the transaction sender, and 'cost' set to 10 STX. Then, create read-only functions: one to get the current count and another to get the count at a specific block, using 'at-block' and 'get-stacks-block-info?'. Handle the case where the block isn't found. Subsequently, implement public functions. 'increment' increases the count by one, requiring an STX payment equal to the 'cost'. 'decrement' decreases it by one, ensuring the count remains non-negative. 'add' increases the count by a specified value, checking that this increment is greater than one and processing an STX transfer for the total cost (increment multiplied by cost). All public functions should return 'ok' upon success. The structure enforces the requirements through a combination of controlled state changes, error checks, and mandatory payments.",";;title: counter
(define-constant ERR_COUNT_MUST_BE_POSITIVE (err u1001))
(define-constant ERROR_ADD_MORE_THAN_ONE (err u1002))
(define-constant ERR_BLOCK_NOT_FOUND (err u1003))

(define-data-var count uint u0)
(define-data-var contract-owner principal tx-sender)
(define-data-var cost uint u10)


(define-read-only (get-count)
  (var-get count)
)

(define-read-only (get-count-at-block (block uint))
  (ok (at-block
    (unwrap! (get-stacks-block-info? id-header-hash block) ERR_BLOCK_NOT_FOUND)
    (var-get count)
  ))
)

(define-public (increment)
  (begin
    (try! (stx-transfer? (var-get cost) tx-sender (var-get contract-owner)))
    (ok (var-set count (+ (var-get count) u1)))
  )
)

(define-public (decrement)
  (let ((current-count (var-get count)))
    (asserts! (> current-count u0) ERR_COUNT_MUST_BE_POSITIVE)
    (ok (var-set count (- current-count u1)))
  )
)

(define-public (add (n uint))
  (begin
    (asserts! (> n u1) ERROR_ADD_MORE_THAN_ONE)
    (try! (stx-transfer? (* n (var-get cost)) tx-sender (var-get contract-owner)))
    (ok (var-set count (+ (var-get count) n)))
  )
)"
"How can we create a Clarity smart contract to confirm Bitcoin transactions? This contract should validate transactions by comparing them against their Merkle proofs and the corresponding block header. It must also support SegWit transactions, include thorough error checks, and enforce strict limits on data lengths.","The contract's goal is to verify Bitcoin transactions within a Clarity smart contract. This involves checking transaction specifics against Merkle proofs and block headers and handling SegWit transactions with robust error management. It's a complex process requiring knowledge of Bitcoin transactions and Clarity's features.

We'll start by planning error codes for various failure scenarios, such as buffer overflows, size discrepancies, and incorrect proofs. Defining these error codes as constants will improve code clarity and maintainability, essential for handling potentially malformed transaction data.

Next, let's consider the functions for reading Bitcoin data. Due to Bitcoin's use of variable-length fields, helper functions will be needed to parse data. These will include basic readers for fixed-length integers (read-uint8, read-uint16, read-uint32, read-uint64), taking transaction buffer and index, and returning the value and the updated index.

A dedicated parser for variable-length integers (varints) is necessary because Bitcoin uses a prefix byte to indicate the length of the integer. For byte arrays (varslices) in Bitcoin, which start with a length varint, we also need parsers. Hash conversions (e.g., reverse-buff32) will be needed for little-endian to big-endian conversion.

Transaction parsing functions (parse-tx and parse-wtx for SegWit) will use the reader functions mentioned before, conforming to Bitcoin's serialization. These must check for accurate data consumption to prevent malicious transaction truncation. Block header parsing (parse-block-header) is needed to get fields for verifying transaction inclusion.

Merkle proof verification involves hashing node pairs up the tree to reach a calculated Merkle root. This root is compared to the expected value from the header. A fold operation is used for the Merkle tree traversal.

For interaction with the underlying chain, we might consider maps to simulate chain data, useful for testing and debugging.

SegWit transaction verification will involve the was-segwit-tx-mined-compact, identifying and validating the witness commitment in an output.

Verification flow will initially examine if the block header matches the expected height. Subsequently, it checks the Merkle proof for the transaction. Witness commitment verification is performed for SegWit transactions.

User-friendly functions, was-tx-mined-compact (regular transactions) and was-segwit-tx-mined-compact (SegWit transactions), summarize the verification.

Enforced buffer limits in Clarity are managed with calls such as unwrap-panic and as-max-len?, as Clarity has these restrictions.

Execution flow and error handling are vital. We will make use of try! and unwrap! to ensure deterministic execution and to handle failures correctly.

In conclusion, the contract must parse Bitcoin transactions, verify their integrity with cryptographic proofs, and account for various edge cases, all while respecting Clarity's limitations. The final contract will provide a complete system for verifying Bitcoin transactions for use within a Clarity-based blockchain.",";; title: stateless contract to verify bitcoin transaction

(define-constant ERR-OUT-OF-BOUNDS u1)
(define-constant ERR-TOO-MANY-TXINS u2)
(define-constant ERR-TOO-MANY-TXOUTS u3)
(define-constant ERR-VARSLICE-TOO-LONG u4)
(define-constant ERR-BAD-HEADER u5)
(define-constant ERR-HEADER-HEIGHT-MISMATCH u6)
(define-constant ERR-INVALID-MERKLE-PROOF u7)
(define-constant ERR-PROOF-TOO-SHORT u8)
(define-constant ERR-TOO-MANY-WITNESSES u9)
(define-constant ERR-INVALID-COMMITMENT u10)
(define-constant ERR-WITNESS-TX-NOT-IN-COMMITMENT u11)
(define-constant ERR-NOT-SEGWIT-TRANSACTION u12)
(define-constant ERR-LEFTOVER-DATA u13)


(define-private (bool-list-of-len (n uint))
	(unwrap-panic (slice? (list true true true true true true true true) u0 n)))

(define-read-only (read-uint8 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint8: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u1)) (err ERR-OUT-OF-BOUNDS)) u1))),
						 ctx: { txbuff: data, index: (+ u1 base)}})))

(define-read-only (read-uint16 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint16: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u2)) (err ERR-OUT-OF-BOUNDS)) u2))),
						 ctx: { txbuff: data, index: (+ u2 base)}})))

(define-read-only (read-uint32 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint32: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u4)) (err ERR-OUT-OF-BOUNDS)) u4))),
						 ctx: { txbuff: data, index: (+ u4 base)}})))

(define-read-only (read-uint64 (ctx { txbuff: (buff 4096), index: uint}))
		(let ((data (get txbuff ctx))
					(base (get index ctx)))
				(ok {uint64: (buff-to-uint-le (unwrap-panic (as-max-len? (unwrap! (slice? data base (+ base u8)) (err ERR-OUT-OF-BOUNDS)) u8))),
						 ctx: { txbuff: data, index: (+ u8 base)}})))

(define-read-only (read-varint (ctx { txbuff: (buff 4096), index: uint}))
		(let ((ptr (get index ctx))
					(tx (get txbuff ctx))
					(byte (buff-to-uint-le (unwrap! (element-at tx ptr)
																	(err ERR-OUT-OF-BOUNDS)))))
		 (if (<= byte u252)
				 (ok { varint: byte, ctx: { txbuff: tx, index: (+ u1 ptr)}})
				 (if (is-eq byte u253)
						 (let (
									 (parsed-u16 (try! (read-uint16 { txbuff: tx, index: (+ u1 ptr)}))))
								 (ok { varint: (get uint16 parsed-u16), ctx: (get ctx parsed-u16)}))
						 (if (is-eq byte u254)
								 (let (
											 (parsed-u32 (try! (read-uint32 { txbuff: tx, index: (+ u1 ptr)}))))
										 (ok { varint: (get uint32 parsed-u32), ctx: (get ctx parsed-u32)}))
								 (let (
											 (parsed-u64 (try! (read-uint64 { txbuff: tx, index: (+ u1 ptr)}))))
									(ok { varint: (get uint64 parsed-u64), ctx: (get ctx parsed-u64)})))))))

(define-read-only (read-varslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed (try! (read-varint old-ctx)))
					(ctx (get ctx parsed))
					(slice-start (get index ctx))
					(target-index (+ slice-start (get varint parsed)))
					(txbuff (get txbuff ctx)))
		 (ok {varslice: (unwrap! (slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-private (reverse-buff16 (input (buff 16)))
	(unwrap-panic (slice? (unwrap-panic (to-consensus-buff? (buff-to-uint-le input))) u1 u17)))

(define-read-only (reverse-buff32 (input (buff 32)))
	(unwrap-panic (as-max-len? (concat
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u16 u32)) u16)))
		(reverse-buff16 (unwrap-panic (as-max-len? (unwrap-panic (slice? input u0 u16)) u16)))) u32)))

(define-read-only (read-hashslice (old-ctx { txbuff: (buff 4096), index: uint}))
		(let ((slice-start (get index old-ctx))
					(target-index (+ u32 slice-start))
					(txbuff (get txbuff old-ctx))
					(hash-le (unwrap-panic
											(as-max-len? (unwrap!
																			(slice? txbuff slice-start target-index) (err ERR-OUT-OF-BOUNDS)) u32))))
		 (ok {hashslice: (reverse-buff32 hash-le),
					ctx: { txbuff: txbuff, index: target-index}})))

(define-read-only (read-next-txin (ignored bool)
																	(result (response {ctx: { txbuff: (buff 4096), index: uint },
																												remaining: uint,
																												txins: (list 8 {outpoint: {
																																									 hash: (buff 32),
																																									 index: uint},
																																				sequence: uint})}
																							uint)))
		(let ((state (unwrap! result result)))
							(let ((remaining (get remaining state))
										(ctx (get ctx state))
										(parsed-hash (try! (read-hashslice ctx)))
										(parsed-index (try! (read-uint32 (get ctx parsed-hash))))
										(parsed-scriptSig (try! (read-varslice (get ctx parsed-index))))
										(parsed-sequence (try! (read-uint32 (get ctx parsed-scriptSig))))
										(new-ctx (get ctx parsed-sequence)))
								(ok {ctx: new-ctx,
										remaining: (- remaining u1),
										txins: (unwrap!
														(as-max-len?
																(append (get txins state) {   outpoint: {
																										hash: (get hashslice parsed-hash),
																										index: (get uint32 parsed-index) },
																				scriptSig: (unwrap! (as-max-len? (get varslice parsed-scriptSig) u256) (err ERR-VARSLICE-TOO-LONG)),
																				sequence: (get uint32 parsed-sequence)}) u8)
														(err ERR-TOO-MANY-TXINS))}))
							))

(define-read-only (read-txins (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txins (try! (read-varint ctx)))
					(num-txins (get varint parsed-num-txins))
					(new-ctx (get ctx parsed-num-txins)))
		 (if (> num-txins u8)
				 (err ERR-TOO-MANY-TXINS)
				 (fold read-next-txin (bool-list-of-len num-txins) (ok { ctx: new-ctx, remaining: num-txins, txins: (list)})))))

(define-read-only (read-next-txout (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																											txouts: (list 8 {value: uint,
																																			 scriptPubKey: (buff 128)})}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-value (try! (read-uint64 (get ctx state))))
					(parsed-script (try! (read-varslice (get ctx parsed-value))))
					(new-ctx (get ctx parsed-script)))
				(ok {ctx: new-ctx,
						txouts: (unwrap!
											(as-max-len?
													(append (get txouts state)
															{   value: (get uint64 parsed-value),
																	scriptPubKey: (unwrap! (as-max-len? (get varslice parsed-script) u128) (err ERR-VARSLICE-TOO-LONG))}) u8)
											(err ERR-TOO-MANY-TXOUTS))})))

(define-read-only (read-txouts (ctx { txbuff: (buff 4096), index: uint}))
		(let ((parsed-num-txouts (try! (read-varint ctx)))
					(num-txouts (get varint parsed-num-txouts))
					(new-ctx (get ctx parsed-num-txouts)))
		 (if (> num-txouts u8)
				 (err ERR-TOO-MANY-TXOUTS)
				 (fold read-next-txout (bool-list-of-len num-txouts) (ok { ctx: new-ctx, txouts: (list)})))))

(define-read-only (read-next-item (ignored bool)
																	 (result (response {ctx: { txbuff: (buff 4096), index: uint },
																												 items: (list 8 (buff 128))}
																							 uint)))
		(let ((state (unwrap! result result))
					(parsed-item (try! (read-varslice (get ctx state))))
					(new-ctx (get ctx parsed-item)))
				(ok {ctx: new-ctx,
						items: (unwrap!
											(as-max-len?
													(append (get items state) (unwrap! (as-max-len? (get varslice parsed-item) u128) (err ERR-VARSLICE-TOO-LONG))) u8)
											(err ERR-TOO-MANY-WITNESSES))})))

(define-read-only (read-next-witness (ignored bool)
	(result (response
		{ ctx: {txbuff: (buff 4096), index: uint}, witnesses: (list 8 (list 8 (buff 128))) } uint)))
	(let ((state (unwrap! result result))
				(parsed-num-items (try! (read-varint (get ctx state))))
				(ctx (get ctx parsed-num-items))
				(varint (get varint parsed-num-items)))
			(if (> varint u0)
				(let ((parsed-items (try! (fold read-next-item (bool-list-of-len varint) (ok { ctx: ctx, items: (list)})))))
						(ok {
							witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (get items parsed-items)) u8)),
							ctx: (get ctx parsed-items)
						}))
				(ok {
					witnesses: (unwrap-panic (as-max-len? (append (get witnesses state) (list)) u8)),
					ctx: ctx
				}))))

(define-read-only (read-witnesses (ctx { txbuff: (buff 4096), index: uint }) (num-txins uint))
	(fold read-next-witness (bool-list-of-len num-txins) (ok { ctx: ctx, witnesses: (list) })))

(define-read-only (parse-wtx (tx (buff 4096)) (calculate-txid bool))
		(let ((ctx { txbuff: tx, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-segwit-marker (try! (read-uint8 (get ctx parsed-version))))
					(parsed-segwit-version (try! (read-uint8 (get ctx parsed-segwit-marker))))
					(parsed-txins (try! (read-txins (get ctx parsed-segwit-version))))
					(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
					(parsed-witnesses (try! (read-witnesses (get ctx parsed-txouts) (len (get txins parsed-txins)))))
					(parsed-locktime (try! (read-uint32 (get ctx parsed-witnesses))))
					)
		(asserts! (and (is-eq (get uint8 parsed-segwit-marker) u0) (is-eq (get uint8 parsed-segwit-version) u1)) (err ERR-NOT-SEGWIT-TRANSACTION))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			segwit-marker: (get uint8 parsed-segwit-marker),
			segwit-version: (get uint8 parsed-segwit-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			txid: (if calculate-txid
				(some (reverse-buff32 (sha256 (sha256
					(concat
						(unwrap-panic (slice? tx u0 u4))
					(concat
						(unwrap-panic (slice? tx (get index (get ctx parsed-segwit-version)) (get index (get ctx parsed-txouts))))
						(unwrap-panic (slice? tx (get index (get ctx parsed-witnesses)) (len tx)))))))))
				none),
			witnesses: (get witnesses parsed-witnesses),
			locktime: (get uint32 parsed-locktime)
		})))

(define-read-only (parse-tx (tx (buff 4096)))
		(let ((ctx { txbuff: tx, index: u0})
			(parsed-version (try! (read-uint32 ctx)))
			(parsed-txins (try! (read-txins (get ctx parsed-version))))
			(parsed-txouts (try! (read-txouts (get ctx parsed-txins))))
			(parsed-locktime (try! (read-uint32 (get ctx parsed-txouts)))))
		(asserts! (is-eq (len tx) (get index (get ctx parsed-locktime))) (err ERR-LEFTOVER-DATA))
		(ok {version: (get uint32 parsed-version),
			ins: (get txins parsed-txins),
			outs: (get txouts parsed-txouts),
			locktime: (get uint32 parsed-locktime)})))

(define-read-only (parse-block-header (headerbuff (buff 80)))
		(let ((ctx { txbuff: headerbuff, index: u0})
					(parsed-version (try! (read-uint32 ctx)))
					(parsed-parent-hash (try! (read-hashslice (get ctx parsed-version))))
					(parsed-merkle-root (try! (read-hashslice (get ctx parsed-parent-hash))))
					(parsed-timestamp (try! (read-uint32 (get ctx parsed-merkle-root))))
					(parsed-nbits (try! (read-uint32 (get ctx parsed-timestamp))))
					(parsed-nonce (try! (read-uint32 (get ctx parsed-nbits)))))
		 (ok {version: (get uint32 parsed-version),
					parent: (get hashslice parsed-parent-hash),
					merkle-root: (get hashslice parsed-merkle-root),
					timestamp: (get uint32 parsed-timestamp),
					nbits: (get uint32 parsed-nbits),
					nonce: (get uint32 parsed-nonce)})))

(define-constant DEBUG-MODE true)

(define-map mock-burnchain-header-hashes uint (buff 32))

(define-public (mock-add-burnchain-block-header-hash (burn-height uint) (hash (buff 32)))
 (ok (map-set mock-burnchain-header-hashes burn-height hash)))

(define-read-only (get-bc-h-hash (bh uint))
	 (if DEBUG-MODE (map-get? mock-burnchain-header-hashes bh) (get-burn-block-info? header-hash bh)))


(define-read-only (verify-block-header (headerbuff (buff 80)) (expected-block-height uint))
	(match (get-bc-h-hash expected-block-height)
			bhh (is-eq bhh (reverse-buff32 (sha256 (sha256 headerbuff))))
			false))

(define-read-only (get-reversed-txid (tx (buff 4096)))
		(sha256 (sha256 tx)))

(define-read-only (get-txid (tx (buff 4096)))
		(reverse-buff32 (sha256 (sha256 tx))))

(define-read-only (is-bit-set (val uint) (bit uint))
	(> (bit-and val (bit-shift-left u1 bit)) u0))

(define-private (inner-merkle-proof-verify (ctr uint) (state { path: uint, root-hash: (buff 32), proof-hashes: (list 14 (buff 32)), tree-depth: uint, cur-hash: (buff 32), verified: bool}))
  (let ((path (get path state))
        (is-left (is-bit-set path ctr))
        (proof-hashes (get proof-hashes state))
        (cur-hash (get cur-hash state))
        (root-hash (get root-hash state))

        (h1 (if is-left (unwrap-panic (element-at proof-hashes ctr)) cur-hash))
        (h2 (if is-left cur-hash (unwrap-panic (element-at proof-hashes ctr))))
        (next-hash (sha256 (sha256 (concat h1 h2))))
        (is-verified (and (is-eq (+ u1 ctr) (len proof-hashes)) (is-eq next-hash root-hash))))
    (merge state { cur-hash: next-hash, verified: is-verified})))

(define-read-only (verify-merkle-proof (reversed-txid (buff 32)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(if (> (get tree-depth proof) (len (get hashes proof)))
				(err ERR-PROOF-TOO-SHORT)
				(ok
					(get verified
							(fold inner-merkle-proof-verify
									(unwrap-panic (slice? (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13) u0 (get tree-depth proof)))
									{ path: (+ (pow u2 (get tree-depth proof)) (get tx-index proof)), root-hash: merkle-root, proof-hashes: (get hashes proof), cur-hash: reversed-txid, tree-depth: (get tree-depth proof), verified: false})))))


(define-read-only (get-commitment-scriptPubKey (outs (list 8 { value: uint, scriptPubKey: (buff 128) })))
	(fold inner-get-commitment-scriptPubKey outs 0x))

(define-read-only (inner-get-commitment-scriptPubKey (out { value: uint, scriptPubKey: (buff 128) }) (result (buff 128)))
	(let ((commitment (get scriptPubKey out)))
		(if (is-commitment-pattern commitment) commitment result)))

(define-read-only (is-commitment-pattern (scriptPubKey (buff 128)))
	(asserts! (is-eq (unwrap! (slice? scriptPubKey u0 u6) false) 0x6a24aa21a9ed) false))



(define-read-only (was-tx-mined-compact (height uint) (tx (buff 4096))
	(header (buff 80))
	(proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
		(let ((block (unwrap! (parse-block-header header) (err ERR-BAD-HEADER))))
			(was-tx-mined-internal height tx header (get merkle-root block) proof)))

(define-private (was-tx-mined-internal (height uint) (tx (buff 4096)) (header (buff 80)) (merkle-root (buff 32)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
	(if (verify-block-header header height)
		(let ((reversed-txid (get-reversed-txid tx))
					(txid (reverse-buff32 reversed-txid)))
			(asserts!
				(or
					(try! (verify-merkle-proof reversed-txid (reverse-buff32 merkle-root) proof)))
				(err ERR-INVALID-MERKLE-PROOF))
			(ok txid))
		(err ERR-HEADER-HEIGHT-MISMATCH)))


(define-read-only (was-segwit-tx-mined-compact
	(height uint)
	(wtx (buff 4096))
	(header (buff 80))
	(tx-index uint)
	(tree-depth uint)
	(wproof (list 14 (buff 32)))
	(witness-merkle-root (buff 32))
	(witness-reserved-value (buff 32))
	(ctx (buff 1024))
	(cproof (list 14 (buff 32))))
	(begin
		(try! (was-tx-mined-compact height ctx header { tx-index: u0, hashes: cproof, tree-depth: tree-depth }))
		(let (
			(witness-out (get-commitment-scriptPubKey (get outs (try! (parse-tx ctx)))))
			(final-hash (sha256 (sha256 (concat witness-merkle-root witness-reserved-value))))
			(reversed-wtxid (get-reversed-txid wtx))
			(wtxid (reverse-buff32 reversed-wtxid))
		)
			(asserts! (is-eq witness-out (concat 0x6a24aa21a9ed final-hash)) (err ERR-INVALID-COMMITMENT))
			(asserts! (try! (verify-merkle-proof reversed-wtxid witness-merkle-root
													{ tx-index: tx-index, hashes: wproof, tree-depth: tree-depth })) (err ERR-WITNESS-TX-NOT-IN-COMMITMENT))
			(ok wtxid))))"
"Create a Clarity smart contract for an NFT collection with the following features: defining the NFT, managing token IDs, tracking ownership, allowing minting and transferring of tokens. The contract should also include error handling for situations like unauthorized actions and failed transactions, use a base URI for metadata, and confirm Bitcoin transaction status using an external library (clarity-bitcoin-lib-v5). The minting process should increase the token ID, check if the sender is the contract owner, verify Bitcoin transaction mining, and issue the token to a designated recipient. Transfers should only be permitted by the token's owner, and ownership should be updated correctly.","The task is to develop a Clarity smart contract for an NFT collection. The contract needs to handle token creation, ID management, ownership, minting, and transfers. It must adhere to a standard NFT trait. Error handling is crucial, covering unauthorized access, transfer issues, and Bitcoin transaction validation. State variables will track the NFT definition, the last token ID, and the base metadata URI. Key functions include a mint function (checking sender authorization, Bitcoin transaction validation via an external library, and token issuance) and a transfer function (verifying ownership and updating records). Read-only functions will provide NFT information (URI, owner). Bitcoin transaction validation is a key requirement, implying a cross-chain interaction. The mint function needs to manage token IDs, verify the contract owner, validate Bitcoin transactions, and mint. Robust error handling and appropriate return values (success or error) are essential. The transfer function must confirm the sender's ownership. Overall, the contract should securely manage NFTs, including minting linked to Bitcoin transactions and secure transfers.",";;title: btc-tx-enabled-nft
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))
(define-constant err-not-found (err u102))
(define-constant err-unsupported-tx (err u103))
(define-constant err-out-not-found (err u104))
(define-constant err-in-not-found (err u105))
(define-constant err-tx-not-mined (err u106))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-non-fungible-token Your-NFT-Name uint)

(define-data-var last-token-id uint u0)

(define-read-only (get-last-token-id)
    (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
    (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
    (ok (nft-get-owner? Your-NFT-Name token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
    (begin
        (asserts! (is-eq tx-sender sender) err-not-token-owner)
        (nft-transfer? Your-NFT-Name token-id sender recipient)
    )
)

(define-public (mint (recipient principal) (height uint) (tx (buff 1024)) (header (buff 80)) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint}))
    (let
        (
            (token-id (+ (var-get last-token-id) u1))
            (tx-was-mined (contract-call? 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.clarity-bitcoin-lib-v5 was-tx-mined-compact height tx header proof))
        )
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (asserts! (is-ok tx-was-mined) err-tx-not-mined)
        (try! (nft-mint? Your-NFT-Name token-id recipient))
        (var-set last-token-id token-id)
        (ok token-id)
    )
)"
"Create a Clarity smart contract for a SIP-010 compliant fungible token. The contract should include: implementation of the SIP-010 trait; definition of a token named 'count-token';  error constants for unauthorized access and insufficient balance; setting the contract deployer as the owner; a mutable TOKEN-URI; constants for name, symbol, and decimals;  read-only functions for balance, total supply, name, symbol, decimals, and URI; and public functions for updating URI (owner only), minting, burning (with STX fallback), and transferring tokens (with optional memo and ownership checks).","The task is to generate a Clarity smart contract for a fungible token conforming to the SIP-010 standard, analogous to Ethereum's ERC-20. The process involves several steps:

1.  **SIP-010 Trait Implementation:**  Use `impl-trait` to adhere to the SIP-010 interface, referencing the standard trait definition.
2.  **Fungible Token Definition:** Define the token using `define-fungible-token` with the name 'count-token'.
3.  **Error Constants:** Define constants `ERR_OWNER_ONLY` (u100) and `ERR_NOT_TOKEN_OWNER` (u101) for access control.
4.  **Contract Owner:** Set `CONTRACT_OWNER` to `tx-sender` to store the deployer's address.
5.  **Mutable Token URI:** Create a mutable `TOKEN-URI` using `define-data-var` with an initial value. The type must be an Optional type.
6.  **Token Constants:** Define constants for `TOKEN_NAME`, `TOKEN_SYMBOL`, and `TOKEN_DECIMALS`.
7.  **Read-Only Functions:** Implement standard SIP-010 getters: `get-balance`, `get-total-supply`, `get-name`, `get-symbol`, `get-decimals`, and `get-token-uri`.
8.  **Public Functions:**
    *   **`set-token-uri`:**  Update `TOKEN-URI` (only callable by the contract owner).
    *   **Mint Function:**  Create a minting function, callable by a `.counter` contract.
    *   **Burn Function:** Create a burning function, callable by `.counter`, with a fallback to burn STX if insufficient token balance.
    *   **`transfer`:** Implement the SIP-010 `transfer` function, including an optional memo field and checks to ensure the sender is authorized.

 The contract should include all required functions, proper error handling, and appropriate permission checks, especially in the `transfer` function where flexibility in sender authorization must be carefully managed.",";;title:count-token
(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-fungible-token count-token)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))

(define-constant CONTRACT_OWNER tx-sender)
(define-data-var TOKEN-URI (optional (string-utf8 256)) (some u""https://ustnpmyvsbtbyjiqiwge.supabase.co/storage/v1/object/public/Count%20Token%20Metadata/count-token-metadata.json""))
(define-constant TOKEN_NAME ""Count Token"")
(define-constant TOKEN_SYMBOL ""COUNT"")


(define-read-only (get-balance (who principal))
  (ok (ft-get-balance count-token who))
)

(define-read-only (get-total-supply)
  (ok (ft-get-supply count-token))
)

(define-read-only (get-name)
  (ok TOKEN_NAME)
)

(define-read-only (get-symbol)
  (ok TOKEN_SYMBOL)
)

(define-read-only (get-decimals)
  (ok TOKEN_DECIMALS)
)

(define-read-only (get-token-uri)
  (ok (var-get TOKEN-URI))
)

(define-public (set-token-uri (value (string-utf8 256)))
    (begin
        (asserts! (is-eq tx-sender CONTRACT_OWNER) (err ERR_OWNER_ONLY))
        (var-set TOKEN-URI (some value))
        (ok (print {
              notification: ""token-metadata-update"",
              payload: {
                contract-id: (as-contract tx-sender),
                token-class: ""ft""
              }
            })
        )
    )
)

(define-public (mint)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (ft-mint? count-token u1000000 tx-sender)
  )
)

(define-public (burn)
  (begin
    (asserts! (is-eq contract-caller .counter) ERR_OWNER_ONLY)
    (if (> (unwrap-panic (get-balance tx-sender)) u0)
      (ft-burn? count-token u1000000 tx-sender)
      (stx-burn? u1000000 tx-sender)
    )
  )
)

(define-public (transfer
  (amount uint)
  (sender principal)
  (recipient principal)
  (memo (optional (buff 34)))
)
  (begin
    (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) ERR_NOT_TOKEN_OWNER)
    (try! (ft-transfer? count-token amount sender recipient))
    (match memo to-print (print to-print) 0x)
    (ok true)
  )
)"
"Create a Clarity smart contract for a payment channel system on the Stacks blockchain. This system should facilitate off-chain transactions using both STX and SIP-010 tokens.  The contract must include functions for creating, updating, disputing, and settling payment channels. It should also incorporate robust security measures like signature verification and nonce management, and follow Stacks' best practices for security and performance.","The goal is to build a secure and efficient payment channel system on Stacks. Payment channels enable off-chain transactions, improving scalability and reducing fees. The core process involves parties opening a channel with initial deposits, conducting signed off-chain transactions, and finally closing the channel, settling the balances on-chain. Key functions include opening, updating, disputing, and closing channels. Signature verification is crucial for security. Channel state needs to track participants, balances, expiry, and nonces (to prevent replay attacks).  The design will start with defining constants, errors, and data structures.  The contract must support both STX and SIP-010 tokens, using a trait for flexibility and token-agnostic functions. Channel identification will use a deterministic method, sorting principals for a consistent key regardless of input order.  Security is paramount; channel operations require valid signatures, complying with SIP-018 to avoid replay attacks. Functions are needed to initialize, fund/open, cooperatively close, handle disputes (with timelocks), and allow unilateral closure. Deposit/withdrawal management during the channel's lifetime is essential. We need a robust design so maybe including an agent system is necessary.  A challenge period is needed for dispute resolution, allowing submission of newer states.  Signature verification is critical, covering all relevant data.  Edge cases, like unresponsive participants (requiring a force-close with a timeout), and invalid state transitions must be handled.  Payment execution involves escrow and correct distribution upon closure.  Consideration should be given to Hash Time-Locked Contracts (HTLCs) for conditional payments and atomic swaps.  Nonce management is vital; each update requires a higher nonce.  Maps with composite keys (participant addresses and token info) will store channel data.  Utility functions will improve readability and maintenance.  Specific error constants will aid debugging.  Security measures must prevent fund theft; only valid signed state updates are allowed.  Balance sums must remain consistent.  Events (via `print` statements) should track operations.  Withdrawals during the channel's life might improve capital efficiency. The final contract must be a secure, efficient, and user-friendly implementation of payment channels, suitable for the Stacks ecosystem.",";; title: stackflow 
;; summary: Stackflow is a payment channel network built on Stacks, enabling
;;   off-chain, non-custodial, and high-speed payments between users. Designed
;;   to be simple, secure, and efficient, it supports transactions in STX and
;;   SIP-010 fungible tokens.
(use-trait sip-010 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)(impl-trait .stackflow-token.stackflow-token)
(define-constant contract-deployer tx-sender)
(define-constant MAX_HEIGHT u340282366920938463463374607431768211455)(define-constant structured-data-prefix 0x534950303138)
(define-constant message-domain-hash (sha256 (unwrap-panic (to-consensus-buff?
        {
                name: ""StackFlow"",
                version: ""0.5.0"",
                chain-id: chain-id
        }
))))
(define-constant structured-data-header (concat structured-data-prefix message-domain-hash))
(define-constant ACTION_CLOSE u0)
(define-constant ACTION_TRANSFER u1)
(define-constant ACTION_DEPOSIT u2)
(define-constant ACTION_WITHDRAWAL u3)
(define-constant ERR_DEPOSIT_FAILED (err u100))
(define-constant ERR_NO_SUCH_CHANNEL (err u101))
(define-constant ERR_INVALID_PRINCIPAL (err u102))
(define-constant ERR_INVALID_SENDER_SIGNATURE (err u103))
(define-constant ERR_INVALID_OTHER_SIGNATURE (err u104))
(define-constant ERR_CONSENSUS_BUFF (err u105))
(define-constant ERR_UNAUTHORIZED (err u106))
(define-constant ERR_MAX_ALLOWED (err u107))
(define-constant ERR_INVALID_TOTAL_BALANCE (err u108))
(define-constant ERR_WITHDRAWAL_FAILED (err u109))
(define-constant ERR_CHANNEL_EXPIRED (err u110))
(define-constant ERR_NONCE_TOO_LOW (err u111))
(define-constant ERR_CLOSE_IN_PROGRESS (err u112))
(define-constant ERR_NO_CLOSE_IN_PROGRESS (err u113))
(define-constant ERR_SELF_DISPUTE (err u114))
(define-constant ERR_ALREADY_FUNDED (err u115))
(define-constant ERR_INVALID_WITHDRAWAL (err u116))
(define-constant ERR_UNAPPROVED_TOKEN (err u117))
(define-constant ERR_NOT_EXPIRED (err u118))
(define-constant ERR_NOT_INITIALIZED (err u119))
(define-constant ERR_ALREADY_INITIALIZED (err u120))
(define-constant ERR_NOT_VALID_YET (err u121))
(define-data-var initialized bool false)
(define-data-var supported-token (optional principal) none)
(define-map
  channels
  { token: (optional principal), principal-1: principal, principal-2: principal }
  { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) }
)
(define-map agents principal principal)
;;
(define-public (init (token (optional <sip-010>)))
  (begin
    (asserts! (not (var-get initialized)) ERR_ALREADY_INITIALIZED)
    (asserts! (is-eq tx-sender contract-deployer) ERR_UNAUTHORIZED)
    (var-set supported-token (contract-of-optional token))
    (ok (var-set initialized true))
  )
)
(define-public (register-agent (agent principal))
  (ok (map-set agents tx-sender agent))
)
(define-public (deregister-agent)
  (ok (map-delete agents tx-sender))
)
(define-public (fund-channel (token (optional <sip-010>)) (amount uint) (with principal) (nonce uint))
  (begin
    (try! (check-token token))

    (let
      (
        (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
        (existing-channel (map-get? channels channel-key))
        (channel
          (match
            existing-channel
            ch
            ch
            { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
          )
        )
        (updated-channel (try! (increase-sender-balance channel-key channel token amount)))
        (closer (get closer channel))
      )
      (asserts! (>= (get nonce channel) nonce) ERR_NONCE_TOO_LOW)
      (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
      (asserts! (not (is-funded tx-sender channel-key channel)) ERR_ALREADY_FUNDED)

      (map-set channels channel-key updated-channel)
      (print {
        event: ""fund-channel"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: tx-sender,
        amount: amount,
      })
      (ok channel-key)
    )
  )
)
(define-public (close-channel
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel {
        balance-1: balance-1,
        balance-2: balance-2,
        expires-at: MAX_HEIGHT,
        nonce: nonce,
        closer: none
      })
    )
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_CLOSE
        tx-sender
        none
        none
      )
    )
    (reset-channel channel-key nonce)
    (print {
      event: ""close-channel"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
    })
    (payout token tx-sender with my-balance their-balance)
  )
)
(define-public (force-cancel (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (+ burn-block-height WAITING_PERIOD))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (map-set
      channels
      channel-key
      (merge channel { expires-at: expires-at, closer: (some tx-sender) })
    )
    (print {
      event: ""force-cancel"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (ok expires-at)
  )
)
(define-public (force-close
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (expires-at (+ burn-block-height WAITING_PERIOD))
        (principal-1 (get principal-1 channel-key))
        (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
        (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
        (new-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: expires-at,
          closer: (some tx-sender),
          nonce: nonce
        })
      )
      (try!
        (verify-signatures
          my-signature
          tx-sender
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (map-set
        channels
        channel-key
        new-channel
      )
      (print {
        event: ""force-close"",
        channel-key: channel-key,
        channel: new-channel,
        sender: tx-sender,
      })

      (ok expires-at)
    )
  )
)
(define-public (dispute-closure
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (dispute-closure-inner
    tx-sender
    token
    with
    my-balance
    their-balance
    my-signature
    their-signature
    nonce
    action
    actor
    secret
    valid-after
  )
)
(define-public (agent-dispute-closure
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (agent (unwrap! (map-get? agents for) ERR_UNAUTHORIZED))
    )
    (asserts! (is-eq tx-sender agent) ERR_UNAUTHORIZED)
    (dispute-closure-inner
      for
      token
      with
      my-balance
      their-balance
      my-signature
      their-signature
      nonce
      action
      actor
      secret
      valid-after
    )
  )
)
(define-public (finalize  (token (optional <sip-010>)) (with principal))
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (closer (get closer channel))
      (expires-at (get expires-at channel))
    )    (asserts! (is-some closer) ERR_NO_CLOSE_IN_PROGRESS)
    (asserts! (> burn-block-height expires-at) ERR_NOT_EXPIRED)
    (reset-channel channel-key (get nonce channel))
    (print {
      event: ""finalize"",
      channel-key: channel-key,
      channel: channel,
      sender: tx-sender,
    })

    (payout
      token
      (get principal-1 channel-key)
      (get principal-2 channel-key)
      (get balance-1 channel)
      (get balance-2 channel)
    )
  )
)
(define-public (deposit
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_DEPOSIT
        tx-sender
        none
        none
      )
    )
    (try! (increase-sender-balance channel-key channel token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""deposit"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
(define-public (withdraw
    (amount uint)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) tx-sender with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (channel-nonce (get nonce channel))
      (closer (get closer channel))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq tx-sender principal-1) my-balance their-balance))
      (balance-2 (if (is-eq tx-sender principal-1) their-balance my-balance))
      (updated-channel
        (merge
          channel
          {
            balance-1: balance-1,
            balance-2: balance-2,
            nonce: nonce
          }
        )
      )
    )
    (asserts! (is-none closer) ERR_CLOSE_IN_PROGRESS)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (asserts!
      (> (+ (get balance-1 channel) (get balance-2 channel)) amount)
      ERR_INVALID_WITHDRAWAL
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (- (+ (get balance-1 channel) (get balance-2 channel)) amount)
      )
      ERR_INVALID_TOTAL_BALANCE
    )
    (try!
      (verify-signatures
        my-signature
        tx-sender
        their-signature
        with
        channel-key
        balance-1
        balance-2
        nonce
        ACTION_WITHDRAWAL
        tx-sender
        none
        none
      )
    )
    (try! (execute-withdraw token amount))

    (map-set
      channels
      channel-key
      updated-channel
    )
    (print {
      event: ""withdraw"",
      channel-key: channel-key,
      channel: updated-channel,
      sender: tx-sender,
      amount: amount,
      my-signature: my-signature,
      their-signature: their-signature,
    })
    (ok channel-key)
  )
)
;;
(define-read-only (get-channel (token (optional principal)) (with principal))
  (match (get-channel-key token tx-sender with)
    channel-key (map-get? channels channel-key)
    e none
  )
)
(define-read-only (make-structured-data-hash
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (structured-data (merge
        channel-key
        {
          balance-1: balance-1,
          balance-2: balance-2,
          nonce: nonce,
          action: action,
          actor: actor,
          hashed-secret: hashed-secret,
          valid-after: valid-after,
        }
      ))
      (data-hash (sha256 (unwrap! (to-consensus-buff? structured-data) ERR_CONSENSUS_BUFF)))
    )
    (ok (sha256 (concat structured-data-header data-hash)))
  )
)
(define-read-only (verify-signature
    (signature (buff 65))
    (signer principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (hashed-secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let ((hash (unwrap! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ) false)))
    (verify-hash-signature hash signature signer actor)
  )
)
(define-read-only (verify-signatures
    (signature-1 (buff 65))
    (signer-1 principal)
    (signature-2 (buff 65))
    (signer-2 principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (balance-1 uint)
    (balance-2 uint)
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let (
    (hashed-secret (match secret s (some (sha256 s)) none))
    (hash (try! (make-structured-data-hash
      channel-key
      balance-1
      balance-2
      nonce
      action
      actor
      hashed-secret
      valid-after
    ))))
    (asserts! (verify-hash-signature hash signature-1 signer-1 actor) ERR_INVALID_SENDER_SIGNATURE)
    (asserts! (verify-hash-signature hash signature-2 signer-2 actor) ERR_INVALID_OTHER_SIGNATURE)
    (ok true)
  )
)
;;
(define-private (contract-of-optional (trait (optional <sip-010>)))
  (match trait
    t
    (some (contract-of t))
    none
  )
)
(define-private (get-channel-key (token (optional principal)) (principal-1 principal) (principal-2 principal))
  (let
    (
      (p1 (unwrap! (to-consensus-buff? principal-1) ERR_INVALID_PRINCIPAL))
      (p2 (unwrap! (to-consensus-buff? principal-2) ERR_INVALID_PRINCIPAL))
    )
    (ok (if (< p1 p2)
      { token: token, principal-1: principal-1, principal-2: principal-2 }
      { token: token, principal-1: principal-2, principal-2: principal-1 }
    ))
  )
)
(define-private (increase-sender-balance
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
    (token (optional <sip-010>))
    (amount uint)
  )
  (begin
    (match token
      t
      (unwrap! (contract-call? t transfer amount tx-sender (as-contract tx-sender) none) ERR_DEPOSIT_FAILED)
      (unwrap! (stx-transfer? amount tx-sender (as-contract tx-sender)) ERR_DEPOSIT_FAILED)
    )
    (ok
      (if (is-eq tx-sender (get principal-1 channel-key))
        (merge channel { balance-1: (+ (get balance-1 channel) amount) })
        (merge channel { balance-2: (+ (get balance-2 channel) amount) })
      )
    )
  )
)
(define-private (execute-withdraw
    (token (optional <sip-010>))
    (amount uint)
  )
  (let ((sender tx-sender))
    (unwrap!
      (match token
        t
        (as-contract (contract-call? t transfer amount tx-sender sender none))
        (as-contract (stx-transfer? amount tx-sender sender))
      )
      ERR_WITHDRAWAL_FAILED
    )
    (ok true)
  )
)
(define-private (dispute-closure-inner
    (for principal)
    (token (optional <sip-010>))
    (with principal)
    (my-balance uint)
    (their-balance uint)
    (my-signature (buff 65))
    (their-signature (buff 65))
    (nonce uint)
    (action uint)
    (actor principal)
    (secret (optional (buff 32)))
    (valid-after (optional uint))
  )
  (let
    (
      (channel-key (try! (get-channel-key (contract-of-optional token) for with)))
      (channel (unwrap! (map-get? channels channel-key) ERR_NO_SUCH_CHANNEL))
      (expires-at (get expires-at channel))
      (channel-nonce (get nonce channel))
      (closer (unwrap! (get closer channel) ERR_NO_CLOSE_IN_PROGRESS))
      (principal-1 (get principal-1 channel-key))
      (balance-1 (if (is-eq for principal-1) my-balance their-balance))
      (balance-2 (if (is-eq for principal-1) their-balance my-balance))
    )
    (asserts! (not (is-eq for closer)) ERR_SELF_DISPUTE)
    (asserts! (< burn-block-height expires-at) ERR_CHANNEL_EXPIRED)
    (asserts! (> nonce channel-nonce) ERR_NONCE_TOO_LOW)
    (match valid-after
      after (asserts! (<= after burn-block-height) ERR_NOT_VALID_YET)
      false
    )
    (asserts!
      (is-eq
        (+ my-balance their-balance)
        (+ (get balance-1 channel) (get balance-2 channel))
      )
      ERR_INVALID_TOTAL_BALANCE
    )

    (let
      (
        (updated-channel {
          balance-1: balance-1,
          balance-2: balance-2,
          expires-at: MAX_HEIGHT,
          nonce: nonce,
          closer: none
        })
      )
      (try!
        (verify-signatures
          my-signature
          for
          their-signature
          with
          channel-key
          balance-1
          balance-2
          nonce
          action
          actor
          secret
          valid-after
        )
      )
      (reset-channel channel-key nonce)
      (print {
        event: ""dispute-closure"",
        channel-key: channel-key,
        channel: updated-channel,
        sender: for,
      })
      (payout token for with my-balance their-balance)
    )
  )
)
(define-private (is-funded
    (account principal)
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (channel { balance-1: uint, balance-2: uint, expires-at: uint, nonce: uint, closer: (optional principal) })
  )
  (or
    (and (is-eq account (get principal-1 channel-key)) (> (get balance-1 channel) u0))
    (and (is-eq account (get principal-2 channel-key)) (> (get balance-2 channel) u0))
  )
)
(define-private (payout
    (token (optional <sip-010>))
    (principal-1 principal)
    (principal-2 principal)
    (balance-1 uint)
    (balance-2 uint)
  )
  (begin
    (try! (transfer token principal-1 balance-1))
    (transfer token principal-2 balance-2)
  )
)
(define-private (transfer (token (optional <sip-010>)) (addr principal) (amount uint))
  (if (is-eq amount u0)    (ok (is-some token))
    (begin
      (match token
        t (unwrap! (as-contract (contract-call? t transfer amount tx-sender addr none)) ERR_WITHDRAWAL_FAILED)
        (unwrap! (as-contract (stx-transfer? amount tx-sender addr)) ERR_WITHDRAWAL_FAILED)
      )
      (ok (is-some token))
    )
  )
)
(define-private (reset-channel
    (channel-key { token: (optional principal), principal-1: principal, principal-2: principal })
    (nonce uint)
  )
  (map-set
    channels
    channel-key
    { balance-1: u0, balance-2: u0, expires-at: MAX_HEIGHT, nonce: nonce, closer: none }
  )
)
(define-private (verify-hash-signature
    (hash (buff 32))
    (signature (buff 65))
    (signer principal)
    (actor principal)
  )
  (or
    (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok signer))    (and
      (not (is-eq signer actor))
      (match (map-get? agents signer)
        agent (is-eq (principal-of? (unwrap! (secp256k1-recover? hash signature) false)) (ok agent))
        false
      )
    )
  )
)
(define-private (check-token (token (optional <sip-010>)))
  (begin    (asserts! (var-get initialized) ERR_NOT_INITIALIZED)
    (asserts! (is-eq (contract-of-optional token) (var-get supported-token)) ERR_UNAPPROVED_TOKEN)

    (ok true)
  )
)"
"Create a Clarity smart contract for a subnet. This contract should manage miners, register fungible and non-fungible token contracts, handle block commitments including withdrawal roots, process deposits and withdrawals (STX, fungible, and non-fungible tokens), validate operations using Merkle proofs, and manage asset transfers/minting securely. Base the implementation on the structure and logic inferred from the provided code (not provided here, but implied as a basis from the original instruction).","1. **Define Subnet Concept:** Understand that a subnet functions as a secondary blockchain tied to a main chain (L1), handling specific transactions and boosting scalability. The contract will manage asset movement between L1 and the subnet (L2).
2. **Error Constants:** Define error constants to give meaningful feedback during operation failures, covering cases like commit errors, invalid miners, transfer problems, and validation issues, improving user experience and debugging.
3. **Data Structures:** Set up maps to track block commits, withdrawal roots, and handled withdrawals. Also, set up a variable for the authorized miner to maintain subnet state and prevent double-spending.
4. **Traits for Interoperability:** Define traits for interacting with different token standards  NFTs, fungible tokens, and a subnet minting trait.  This allows uniform interaction with different token contracts.
5. **Miner Management:** Implement miner update functionality, allowing only the current miner to update to a new one, maintaining security.
6. **Token Registration:** Implement functions for registering both fungible and non-fungible token contracts (mapping L1 contracts to L2 counterparts).  Only the authorized miner should be able to register.
7. **Block Commitment:** Implement block commitment to anchor subnet state to the L1 chain. Each commitment should have a withdrawal root (Merkle root of withdrawals). Validate against committed blocks and miner authorization.
8. **NFT Deposit/Withdrawal:** Implement NFT deposit and withdrawal functions. Deposits involve users sending NFTs to the contract. Withdrawals require Merkle proof validation against the committed withdrawal root, then transferring the NFT.
9. **NFT Minting (if needed):** Include logic to mint NFTs if necessary during withdrawal (e.g., if an NFT originates on L2).
10. **FT Deposit/Withdrawal:** Implement similar functions for fungible tokens, also handling token amounts. Deposits involve sending tokens to the contract, and withdrawals need Merkle proof validation and transfers. Minting may be needed, if the contract lacks balance.
11. **STX Handling:** Implement STX deposit and withdrawal using `stx-transfer?`, as STX isn't a contract.  Use similar validation logic.
12. **Merkle Proof Validation:** This is crucial. Implement functions for hashing withdrawal data, verifying Merkle paths, and keeping track of processed withdrawals to prevent double-spending.
13. **Leaf Hashing:** Create distinct hashing formats for STX, NFT, and FT withdrawals. This creates unique identifiers for inclusion in the Merkle tree.
14. **Hash Verification:** Implement verification to traverse the Merkle tree using sibling hashes, reconstructing and comparing the root hash to the committed root.
15. **Mark Withdrawals Processed:** Function to mark withdrawals as processed after successful execution  avoiding multiple processing for the same withdrawal.
16. **Error Handling:** Throughout the code, ensure thorough error handling with input and state validation.  Provide specific error codes.
17. **Event Emission:** The contract should emit events for key actions like deposits and withdrawals for off-chain monitoring.
18. **Overall Design:** Ensure the complete design satisfies the requirements for a secure and well-managed subnet system.",";;title: subnet
(define-constant CONTRACT_ADDRESS (as-contract tx-sender))
(define-constant ERR_BLOCK_ALREADY_COMMITTED 1)
(define-constant ERR_INVALID_MINER 2)
(define-constant ERR_CONTRACT_CALL_FAILED 3)
(define-constant ERR_TRANSFER_FAILED 4)
(define-constant ERR_DISALLOWED_ASSET 5)
(define-constant ERR_ASSET_ALREADY_ALLOWED 6)
(define-constant ERR_MERKLE_ROOT_DOES_NOT_MATCH 7)
(define-constant ERR_INVALID_MERKLE_ROOT 8)
(define-constant ERR_WITHDRAWAL_ALREADY_PROCESSED 9)
(define-constant ERR_VALIDATION_FAILED 10)(define-constant ERR_INVALID_CHAIN_TIP 11)(define-constant ERR_CALLED_TOO_EARLY 12)
(define-constant ERR_MINT_FAILED 13)
(define-constant ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT 14)
(define-constant ERR_IN_COMPUTATION 15)(define-constant ERR_NFT_NOT_OWNED_BY_CONTRACT 16)
(define-constant ERR_VALIDATION_LEAF_FAILED 30)
(define-map block-commits uint (buff 32))(define-map withdrawal-roots-map (buff 32) bool)(define-map processed-withdrawal-leaves-map { withdrawal-leaf-hash: (buff 32), withdrawal-root-hash: (buff 32) } bool)
(define-data-var miner principal 'ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP)
(define-map allowed-contracts principal principal)
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)
(use-trait mint-from-subnet-trait .subnet-traits.mint-from-subnet-trait)
(define-public (update-miner (new-miner principal))
    (begin
        (asserts! (is-eq tx-sender (var-get miner)) (err ERR_INVALID_MINER))
        (ok (var-set miner new-miner))
    )
)
(define-public (register-new-ft-contract (ft-contract <ft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of ft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-public (register-new-nft-contract (nft-contract <nft-trait>) (l2-contract principal))
    (begin        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (map-insert allowed-contracts (contract-of nft-contract) l2-contract)
                  (err ERR_ASSET_ALREADY_ALLOWED))

        (ok true)
    )
)
(define-private (is-miner (miner-to-check principal))
    (is-eq miner-to-check (var-get miner))
)
(define-private (can-commit-block? (commit-block-height uint)  (target-chain-tip (buff 32)))
    (begin        (asserts! (is-none (map-get? block-commits commit-block-height)) (err ERR_BLOCK_ALREADY_COMMITTED))
        (asserts! (is-eq
            target-chain-tip
            (unwrap! (get-block-info? id-header-hash (- block-height u1)) (err ERR_CALLED_TOO_EARLY)) )
            (err ERR_INVALID_CHAIN_TIP))
        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))
        (asserts! (is-miner contract-caller) (err ERR_INVALID_MINER))

        (ok true)
    )
)
(define-private (inner-commit-block (block (buff 32)) (commit-block-height uint) (withdrawal-root (buff 32)))
    (begin
        (map-set block-commits commit-block-height block)
        (map-set withdrawal-roots-map withdrawal-root true)
        (print {
            event: ""block-commit"",
            block-commit: block,
            withdrawal-root: withdrawal-root,
            block-height: commit-block-height
        })
        (ok block)
    )
)
;;(define-public (commit-block (block (buff 32)) (target-chain-tip (buff 32)) (withdrawal-root (buff 32)))
    (let ((commit-block-height block-height))
        (try! (can-commit-block? commit-block-height target-chain-tip))
        (inner-commit-block block commit-block-height withdrawal-root)
    )
)

(define-private (inner-transfer-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract transfer id sender recipient))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-nft-asset
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? nft-mint-contract mint-from-subnet id sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-nft-asset
        (nft-contract <nft-trait>)
        (nft-mint-contract <mint-from-subnet-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
            (no-owner (is-eq nft-owner none))
        )

        (if contract-owns-nft
            (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
            (if no-owner                (inner-mint-nft-asset nft-mint-contract id CONTRACT_ADDRESS recipient)                (err ERR_MINT_FAILED)
            )
        )
    )
)
(define-public (deposit-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (sender principal)
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts! (try! (inner-transfer-nft-asset nft-contract id sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print {
            event: ""deposit-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            sender: sender,
            subnet-contract-id: subnet-contract-id,
        })

        (ok true)
    )
)

(define-public (inner-withdraw-nft-asset
        (nft-contract <nft-trait>)
        (l2-contract principal)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-nft l2-contract id recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match nft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-nft-asset nft-contract mint-contract id recipient))
                    (as-contract (inner-transfer-without-mint-nft-asset nft-contract id recipient))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
            (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED)
        )

        (ok true)
    )
)
(define-public (withdraw-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (nft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let (            (l2-contract (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))
        )
        (asserts!
            (try! (inner-withdraw-nft-asset
                nft-contract
                l2-contract
                id
                recipient
                withdrawal-id
                height
                nft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes
            ))
            (err ERR_TRANSFER_FAILED)
        )
        (print {
            event: ""withdraw-nft"",
            l1-contract-id: (as-contract nft-contract),
            nft-id: id,
            recipient: recipient
        })

        (ok true)
    )
)

(define-private (inner-transfer-without-mint-nft-asset
        (nft-contract <nft-trait>)
        (id uint)
        (recipient principal)
    )
    (let (
            (call-result (contract-call? nft-contract get-owner id))
            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))
        )

        (asserts! contract-owns-nft (err ERR_NFT_NOT_OWNED_BY_CONTRACT))
        (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)
    )
)

(define-private (inner-transfer-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract transfer amount sender recipient memo))
            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)

(define-private (inner-mint-ft-asset
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (sender principal)
        (recipient principal)
    )
    (let (
            (call-result (as-contract (contract-call? ft-mint-contract mint-from-subnet amount sender recipient)))
            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
        )        (asserts! mint-result (err ERR_MINT_FAILED))

        (ok true)
    )
)

(define-private (inner-transfer-or-mint-ft-asset
        (ft-contract <ft-trait>)
        (ft-mint-contract <mint-from-subnet-trait>)
        (amount uint)
        (recipient principal)
        (memo (optional (buff 34)))
    )
    (let (
            (call-result (contract-call? ft-contract get-balance CONTRACT_ADDRESS))
            (contract-ft-balance (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))
            (contract-owns-enough (>= contract-ft-balance amount))
            (amount-to-transfer (if contract-owns-enough amount contract-ft-balance))
            (amount-to-mint (- amount amount-to-transfer))
        )
        (asserts! (is-eq amount (+ amount-to-transfer amount-to-mint)) (err ERR_IN_COMPUTATION))

        (and
            (> amount-to-transfer u0)
            (try! (inner-transfer-ft-asset ft-contract amount-to-transfer CONTRACT_ADDRESS recipient memo))
        )
        (and
            (> amount-to-mint u0)
            (try! (inner-mint-ft-asset ft-mint-contract amount-to-mint CONTRACT_ADDRESS recipient))
        )

        (ok true)
    )
)
(define-public (deposit-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (sender principal)
        (memo (optional (buff 34)))
    )
    (let (            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET)))
        )        (asserts! (try! (inner-transfer-ft-asset ft-contract amount sender CONTRACT_ADDRESS memo)) (err ERR_TRANSFER_FAILED))

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""deposit-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                sender: sender,
                subnet-contract-id: subnet-contract-id,
            })
        )

        (ok true)
    )
)
(define-private (inner-withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))
        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))
        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-ft (contract-of ft-contract) amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts!
            (try!
                (match ft-mint-contract
                    mint-contract (as-contract (inner-transfer-or-mint-ft-asset ft-contract mint-contract amount recipient memo))
                    (as-contract (inner-transfer-ft-asset ft-contract amount CONTRACT_ADDRESS recipient memo))
                )
            )
            (err ERR_TRANSFER_FAILED)
        )

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (ok true)
    )
)
(define-public (withdraw-ft-asset
        (ft-contract <ft-trait>)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (memo (optional (buff 34)))
        (ft-mint-contract (optional <mint-from-subnet-trait>))
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (> amount u0) (err ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT))
        (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET))

        (asserts!
            (try! (inner-withdraw-ft-asset
                ft-contract
                amount
                recipient
                withdrawal-id
                height
                memo
                ft-mint-contract
                withdrawal-root
                withdrawal-leaf-hash
                sibling-hashes))
            (err ERR_TRANSFER_FAILED)
        )

        (let (
                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))
            )            (print {
                event: ""withdraw-ft"",
                l1-contract-id: (as-contract ft-contract),
                ft-name: ft-name,
                ft-amount: amount,
                recipient: recipient,
            })
        )

        (ok true)
    )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-private (inner-transfer-stx (amount uint) (sender principal) (recipient principal))
    (let (
            (call-result (stx-transfer? amount sender recipient))
            (transfer-result (unwrap! call-result (err ERR_TRANSFER_FAILED)))
        )        (asserts! transfer-result (err ERR_TRANSFER_FAILED))

        (ok true)
    )
)
(define-public (deposit-stx (amount uint) (sender principal))
    (begin        (asserts! (try! (inner-transfer-stx amount sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))
        (print { event: ""deposit-stx"", sender: sender, amount: amount })

        (ok true)
    )
)

(define-read-only (leaf-hash-withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""stx"",
            amount: amount,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-nft
        (asset-contract principal)
        (nft-id uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""nft"",
            nft-id: nft-id,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)

(define-read-only (leaf-hash-withdraw-ft
        (asset-contract principal)
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
    )
    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?
        {
            type: ""ft"",
            amount: amount,
            asset-contract: asset-contract,
            recipient: recipient,
            withdrawal-id: withdrawal-id,
            height: height
        })))
    )
)
(define-public (withdraw-stx
        (amount uint)
        (recipient principal)
        (withdrawal-id uint)
        (height uint)
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))

        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))        (asserts! (is-eq withdrawal-leaf-hash
                         (leaf-hash-withdraw-stx amount recipient withdrawal-id height))
                  (err ERR_VALIDATION_LEAF_FAILED))

        (asserts! (try! (as-contract (inner-transfer-stx amount tx-sender recipient))) (err ERR_TRANSFER_FAILED))

        (asserts!
          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })
          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))
        (print { event: ""withdraw-stx"", recipient: recipient, amount: amount })

        (ok true)
    )
)


(define-private (create-node-hash
        (curr-hash (buff 32))
        (sibling-hash (buff 32))
        (is-sibling-left-side bool)
    )
    (let (
            (concatted-hash (if is-sibling-left-side
                    (concat sibling-hash curr-hash)
                    (concat curr-hash sibling-hash)
                ))
          )

          (concat 0x01 concatted-hash)
    )
)
(define-private (hash-help
        (sibling {
            hash: (buff 32),
            is-left-side: bool,
        })
        (curr-node-hash (buff 32))
    )
    (let (
            (sibling-hash (get hash sibling))
            (is-sibling-left-side (get is-left-side sibling))
            (new-buff (create-node-hash curr-node-hash sibling-hash is-sibling-left-side))
        )
       (sha512/256 new-buff)
    )
)
(define-private (check-withdrawal-hashes
        (withdrawal-root (buff 32))
        (withdrawal-leaf-hash (buff 32))
        (sibling-hashes (list 50 {
            hash: (buff 32),
            is-left-side: bool,
        }))
    )
    (begin        (asserts! (is-some (map-get? withdrawal-roots-map withdrawal-root)) (err ERR_INVALID_MERKLE_ROOT))
        (asserts!
            (is-none
             (map-get? processed-withdrawal-leaves-map
                       { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root }))
            (err ERR_WITHDRAWAL_ALREADY_PROCESSED))

        (let ((calculated-withdrawal-root (fold hash-help sibling-hashes withdrawal-leaf-hash))
              (roots-match (is-eq calculated-withdrawal-root withdrawal-root)))
             (if roots-match
                (ok true)
                (err ERR_MERKLE_ROOT_DOES_NOT_MATCH))
        )
    )
)
(define-private (finish-withdraw
        (withdraw-info {
            withdrawal-leaf-hash: (buff 32),
            withdrawal-root-hash: (buff 32)
        })
    )
    (map-insert processed-withdrawal-leaves-map withdraw-info true)
)"
"Create a Clarity smart contract for an NFT named ""funny-dog"" that adheres to the nft-trait interface. This contract should allow for minting new NFTs up to a specified limit, transferring NFTs between owners, and fetching NFT metadata (URI and owner). It must also include error handling for unauthorized actions, exceeding the minting limit, and invalid transfers, and use a base URI for metadata.","Design a Clarity smart contract for the ""funny-dog"" NFT collection, adhering to the standard NFT trait. Start by implementing the `nft-trait` interface. Define the NFT with `define-non-fungible-token`, using `uint` for unique IDs.  Use a data variable to keep track of the last minted token ID. Store the contract owner's address in a constant. Define constants for different error conditions (unauthorized access, invalid transfers, exceeding collection size). Store a base URI template as a data variable. Create read-only functions for fetching the last token ID, token URI, and token owner. Implement a public transfer function that verifies the sender's ownership before transferring. Create a mint function, restricted to the contract owner, that checks the collection limit, mints the token, updates the last token ID, and returns the new ID. Include a constant, `COLLECTION_LIMIT` to enforce the maximum number of tokens. Ensure all ownership and minting restrictions are properly enforced.",";;title: funny dog
(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)

(define-non-fungible-token funny-dog uint)

(define-data-var last-token-id uint u0)

(define-constant CONTRACT_OWNER tx-sender)

(define-constant ERR_OWNER_ONLY (err u100))
(define-constant ERR_NOT_TOKEN_OWNER (err u101))
(define-constant ERR_SOLD_OUT (err u300))

(define-data-var base-uri (string-ascii 80) ""https://your.api.com/path/to/collection/{id}"")

(define-read-only (get-last-token-id)
  (ok (var-get last-token-id))
)

(define-read-only (get-token-uri (token-id uint))
  (ok (some (var-get base-uri)))
)

(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? funny-dog token-id))
)

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender sender) ERR_NOT_TOKEN_OWNER)
    (nft-transfer? funny-dog token-id sender recipient)
  )
)

(define-public (mint (recipient principal))
  (let ((token-id (+ (var-get last-token-id) u1)))
    (asserts! (< (var-get last-token-id) COLLECTION_LIMIT) ERR_SOLD_OUT)
    (asserts! (is-eq tx-sender CONTRACT_OWNER) ERR_OWNER_ONLY)
    (try! (nft-mint? funny-dog token-id recipient))

    (var-set last-token-id token-id)
    (ok token-id)
  )
)"
"Create a Clarity smart contract for a non-fungible token (NFT) marketplace. This marketplace should enable users to offer NFTs for sale, remove their listings, and buy listed NFTs using either STX or other token types. The contract should handle errors such as listings that have passed their expiration date, actions attempted by unauthorized users, and discrepancies in asset types. It should also include a feature to approve specific asset contracts, validate the details of each listing, and have secure functions for moving NFTs and other tokens. The goal is to make the contract robust and efficient, excluding any deployment and testing features.","Design an NFT marketplace smart contract in Clarity. Start by defining the core functionalities: creating listings, removing listings, and buying listed NFTs using either STX or fungible tokens. This requires separate purchase handling for each payment type. Define necessary traits (NFT and FT) for interacting with various token contracts, including their transfer helper functions. Manage the marketplace's state with a map storing listing details (seller, optional buyer, token ID, NFT contract, expiry, price, payment asset), a listing ID counter, and a whitelist for approved asset contracts to enhance security. Define clear error codes for scenarios such as expired listings, unauthorized access, and asset mismatches to improve readability and maintainability. For the listing function, ensure NFT asset and payment asset are whitelisted and transfer NFT to contract escrow. Create cancellation function to verify caller and return NFT if validation passes. Implement fulfillment functions (STX and FT) verifying listing, caller, expiry, asset contracts, and transferring NFT and payment. Address security by ensuring authorized actions and safe asset transfers with as-contract usage when appropriate. Make functions like getters read-only to save gas. Add documentation using clear naming conventions for better maintainability. The overall structure involves defining traits, data structures, secure transfer implementations, and error handling, supporting listings with sellers, restricted buyers, expiration, payment types, and all validated, secure, authorized operations.",";;title: nft-marketplace
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait  'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

(define-constant ERR_EXPIRY_IN_PAST (err u1000))
(define-constant ERR_PRICE_ZERO (err u1001))

(define-constant ERR_UNKNOWN_LISTING (err u2000))
(define-constant ERR_UNAUTHORISED (err u2001))
(define-constant ERR_LISTING_EXPIRED (err u2002))
(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))
(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))
(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))
(define-constant ERR_UNINTENDED_TAKER (err u2006))
(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))
(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))

(define-map listings
  uint
  {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  }
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
  (default-to true (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
  (begin
    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)
    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
  )
)

(define-private (transfer-nft
  (token-contract <nft-trait>)
  (token-id uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft
  (token-contract <ft-trait>)
  (amount uint)
  (sender principal)
  (recipient principal)
)
  (contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset
  (nft-asset-contract <nft-trait>)
  (nft-asset {
    taker: (optional principal),
    token-id: uint,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (let ((listing-id (var-get listing-nonce)))
    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)
    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)
    (asserts! (match (get payment-asset-contract nft-asset)
      payment-asset
      (is-whitelisted payment-asset)
      true
    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)
    (try! (transfer-nft
      nft-asset-contract
      (get token-id nft-asset)
      tx-sender
      (as-contract tx-sender)
    ))
    (map-set listings listing-id (merge
      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }
      nft-asset
    ))
    (var-set listing-nonce (+ listing-id u1))
    (ok listing-id)
  )
)

(define-read-only (get-listing (listing-id uint))
  (map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (maker (get maker listing))
  )
    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)
    (asserts! (is-eq
      (get nft-asset-contract listing)
      (contract-of nft-asset-contract)
    ) ERR_NFT_ASSET_MISMATCH)
    (map-delete listings listing-id)
    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
  )
)

(define-private (assert-can-fulfil
  (nft-asset-contract principal)
  (payment-asset-contract (optional principal))
  (listing {
    maker: principal,
    taker: (optional principal),
    token-id: uint,
    nft-asset-contract: principal,
    expiry: uint,
    price: uint,
    payment-asset-contract: (optional principal)
  })
)
  (begin
    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)
    (asserts!
      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)
      ERR_UNINTENDED_TAKER
    )
    (asserts! (< burn-block-height (get expiry listing)) ERR_LISTING_EXPIRED)
    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)
    (asserts!
      (is-eq (get payment-asset-contract listing) payment-asset-contract)
      ERR_PAYMENT_ASSET_MISMATCH
    )
    (ok true)
  )
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (stx-transfer? (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)

(define-public (fulfil-listing-ft
  (listing-id uint)
  (nft-asset-contract <nft-trait>)
  (payment-asset-contract <ft-trait>)
)
  (let (
    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))
    (taker tx-sender)
  )
    (try! (assert-can-fulfil
      (contract-of nft-asset-contract)
      (some (contract-of payment-asset-contract))
      listing
    ))
    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
    (map-delete listings listing-id)
    (ok listing-id)
  )
)"
"Create a Clarity smart contract for a decentralized NFT marketplace named 'tiny-market'. This contract should enable users to list NFTs for sale, cancel listings, and complete trades. It should support payments in STX and fungible tokens. Key features include whitelisting NFT contracts, storing listing details (seller, optional buyer, token ID, expiration, price, optional payment contract), checking expiration, validating prices, restricting payment assets, enforcing permissions, using NFT and FT traits, handling errors, and providing secure asset transfer functions.","1.  **Initial Setup**: Define the contract, utilizing traits for standard NFT and FT interactions. Establish a contract owner for administrative tasks. Create a `listings` map to store trade details (maker, taker, token ID, NFT contract, expiry, price, payment asset contract) and use `listing-nonce` variable for unique IDs. Create `whitelisted-asset-contracts` to manage the approved NFT contract for the marketplace.
2.  **Whitelist Management**: Implement `is-whitelisted` (read-only) to check if a contract is approved and `set-whitelisted` to allow the contract owner to manage the whitelist.
3.  **Helper Functions**: Create `transfer-nft` and `transfer-ft` to handle secure asset transfers using `contract-call?`.
4.  **Listing Assets**: Implement `list-asset` to allow users to list NFTs. Validate NFT contract whitelisting, expiry, price, an optional whitelisted payment asset. Transfer the NFT to the contract. Store listing and increment listing-nonce.
5.  **Retrieval and Cancellation**: Create `get-listing` (read-only) to fetch listing details. Implement the `cancel-listing` that only seller can cancel listing. Delete the listing and transferred back the asset.
6.  **Fulfillment Validation**: Create `assert-can-fulfil` to centralize checks: buyer != maker, taker matches caller (if specified), listing not expired, and correct NFT and payment assets used.
7.  **Fulfillment Functions**: Implement `fulfil-listing-stx` (for STX payments) and `fulfil-listing-ft` (for FT payments). Both functions should retrieve the listing, validate conditions, transfer NFT to buyer, transfer payment to seller, and remove the listing. Use `try!` for error handling and atomic transactions.
8 **Conclusion:** Ensure that there is secure and flexible NFT trading via robust state management, whitelisting, and transfer logic. The use of `try!` ensures that if any step fails, the entire transaction is reverted, preventing asset loss or unintended transfers.",";; title:tiny-market
(use-trait nft-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)
(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

(define-constant contract-owner tx-sender)

;; listing errors
(define-constant err-expiry-in-past (err u1000))
(define-constant err-price-zero (err u1001))

;; cancelling and fulfiling errors
(define-constant err-unknown-listing (err u2000))
(define-constant err-unauthorised (err u2001))
(define-constant err-listing-expired (err u2002))
(define-constant err-nft-asset-mismatch (err u2003))
(define-constant err-payment-asset-mismatch (err u2004))
(define-constant err-maker-taker-equal (err u2005))
(define-constant err-unintended-taker (err u2006))
(define-constant err-asset-contract-not-whitelisted (err u2007))
(define-constant err-payment-contract-not-whitelisted (err u2008))

(define-map listings
	uint
	{
		maker: principal,
		taker: (optional principal),
		token-id: uint,
		nft-asset-contract: principal,
		expiry: uint,
		price: uint,
		payment-asset-contract: (optional principal)
	}
)

(define-data-var listing-nonce uint u0)

(define-map whitelisted-asset-contracts principal bool)

(define-read-only (is-whitelisted (asset-contract principal))
	(default-to false (map-get? whitelisted-asset-contracts asset-contract))
)

(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))
	(begin
		(asserts! (is-eq contract-owner tx-sender) err-unauthorised)
		(ok (map-set whitelisted-asset-contracts asset-contract whitelisted))
	)
)

(define-private (transfer-nft (token-contract <nft-trait>) (token-id uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer token-id sender recipient)
)

(define-private (transfer-ft (token-contract <ft-trait>) (amount uint) (sender principal) (recipient principal))
	(contract-call? token-contract transfer amount sender recipient none)
)

(define-public (list-asset (nft-asset-contract <nft-trait>) (nft-asset {taker: (optional principal), token-id: uint, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(let ((listing-id (var-get listing-nonce)))
		(asserts! (is-whitelisted (contract-of nft-asset-contract)) err-asset-contract-not-whitelisted)
		(asserts! (> (get expiry nft-asset) block-height) err-expiry-in-past)
		(asserts! (> (get price nft-asset) u0) err-price-zero)
		(asserts! (match (get payment-asset-contract nft-asset) payment-asset (is-whitelisted payment-asset) true) err-payment-contract-not-whitelisted)
		(try! (transfer-nft nft-asset-contract (get token-id nft-asset) tx-sender (as-contract tx-sender)))
		(map-set listings listing-id (merge {maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract)} nft-asset))
		(var-set listing-nonce (+ listing-id u1))
		(ok listing-id)
	)
)

(define-read-only (get-listing (listing-id uint))
	(map-get? listings listing-id)
)

(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(maker (get maker listing))
		)
		(asserts! (is-eq maker tx-sender) err-unauthorised)
		(asserts! (is-eq (get nft-asset-contract listing) (contract-of nft-asset-contract)) err-nft-asset-mismatch)
		(map-delete listings listing-id)
		(as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))
	)
)

(define-private (assert-can-fulfil (nft-asset-contract principal) (payment-asset-contract (optional principal)) (listing {maker: principal, taker: (optional principal), token-id: uint, nft-asset-contract: principal, expiry: uint, price: uint, payment-asset-contract: (optional principal)}))
	(begin
		(asserts! (not (is-eq (get maker listing) tx-sender)) err-maker-taker-equal)
		(asserts! (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true) err-unintended-taker)
		(asserts! (< block-height (get expiry listing)) err-listing-expired)
		(asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) err-nft-asset-mismatch)
		(asserts! (is-eq (get payment-asset-contract listing) payment-asset-contract) err-payment-asset-mismatch)
		(ok true)
	)
)

(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (stx-transfer? (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)

(define-public (fulfil-listing-ft (listing-id uint) (nft-asset-contract <nft-trait>) (payment-asset-contract <ft-trait>))
	(let (
		(listing (unwrap! (map-get? listings listing-id) err-unknown-listing))
		(taker tx-sender)
		)
		(try! (assert-can-fulfil (contract-of nft-asset-contract) (some (contract-of payment-asset-contract)) listing))
		(try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))
		(try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))
		(map-delete listings listing-id)
		(ok listing-id)
	)
)"
